System.register('ionic/components', ['ionic/components/app/app', 'ionic/components/app/id', 'ionic/components/action-sheet/action-sheet', 'ionic/components/button/button', 'ionic/components/card/card', 'ionic/components/checkbox/checkbox', 'ionic/components/content/content', 'ionic/components/form/input', 'ionic/components/icon/icon', 'ionic/components/item/item', 'ionic/components/item/item-group', 'ionic/components/menu/menu', 'ionic/components/menu/menu-types', 'ionic/components/menu/menu-toggle', 'ionic/components/text-input/text-input', 'ionic/components/text-input/label', 'ionic/components/list/list', 'ionic/components/show-hide-when/show-hide-when', 'ionic/components/modal/modal', 'ionic/components/nav/nav', 'ionic/components/nav/nav-controller', 'ionic/components/nav/view-controller', 'ionic/components/nav/nav-push', 'ionic/components/nav/nav-router', 'ionic/components/nav-bar/nav-bar', 'ionic/components/popup/popup', 'ionic/components/slides/slides', 'ionic/components/radio/radio', 'ionic/components/scroll/scroll', 'ionic/components/scroll/pull-to-refresh', 'ionic/components/search-bar/search-bar', 'ionic/components/segment/segment', 'ionic/components/switch/switch', 'ionic/components/tabs/tabs', 'ionic/components/tabs/tab', 'ionic/components/toolbar/toolbar'], function (_export) {
  'use strict';

  return {
    setters: [function (_ionicComponentsAppApp) {
      for (var _key in _ionicComponentsAppApp) {
        if (_key !== 'default') _export(_key, _ionicComponentsAppApp[_key]);
      }
    }, function (_ionicComponentsAppId) {
      for (var _key2 in _ionicComponentsAppId) {
        if (_key2 !== 'default') _export(_key2, _ionicComponentsAppId[_key2]);
      }
    }, function (_ionicComponentsActionSheetActionSheet) {
      for (var _key3 in _ionicComponentsActionSheetActionSheet) {
        if (_key3 !== 'default') _export(_key3, _ionicComponentsActionSheetActionSheet[_key3]);
      }
    }, function (_ionicComponentsButtonButton) {
      for (var _key4 in _ionicComponentsButtonButton) {
        if (_key4 !== 'default') _export(_key4, _ionicComponentsButtonButton[_key4]);
      }
    }, function (_ionicComponentsCardCard) {
      for (var _key5 in _ionicComponentsCardCard) {
        if (_key5 !== 'default') _export(_key5, _ionicComponentsCardCard[_key5]);
      }
    }, function (_ionicComponentsCheckboxCheckbox) {
      for (var _key6 in _ionicComponentsCheckboxCheckbox) {
        if (_key6 !== 'default') _export(_key6, _ionicComponentsCheckboxCheckbox[_key6]);
      }
    }, function (_ionicComponentsContentContent) {
      for (var _key7 in _ionicComponentsContentContent) {
        if (_key7 !== 'default') _export(_key7, _ionicComponentsContentContent[_key7]);
      }
    }, function (_ionicComponentsFormInput) {
      for (var _key8 in _ionicComponentsFormInput) {
        if (_key8 !== 'default') _export(_key8, _ionicComponentsFormInput[_key8]);
      }
    }, function (_ionicComponentsIconIcon) {
      for (var _key9 in _ionicComponentsIconIcon) {
        if (_key9 !== 'default') _export(_key9, _ionicComponentsIconIcon[_key9]);
      }
    }, function (_ionicComponentsItemItem) {
      for (var _key10 in _ionicComponentsItemItem) {
        if (_key10 !== 'default') _export(_key10, _ionicComponentsItemItem[_key10]);
      }
    }, function (_ionicComponentsItemItemGroup) {
      for (var _key11 in _ionicComponentsItemItemGroup) {
        if (_key11 !== 'default') _export(_key11, _ionicComponentsItemItemGroup[_key11]);
      }
    }, function (_ionicComponentsMenuMenu) {
      for (var _key12 in _ionicComponentsMenuMenu) {
        if (_key12 !== 'default') _export(_key12, _ionicComponentsMenuMenu[_key12]);
      }
    }, function (_ionicComponentsMenuMenuTypes) {
      for (var _key13 in _ionicComponentsMenuMenuTypes) {
        if (_key13 !== 'default') _export(_key13, _ionicComponentsMenuMenuTypes[_key13]);
      }
    }, function (_ionicComponentsMenuMenuToggle) {
      for (var _key14 in _ionicComponentsMenuMenuToggle) {
        if (_key14 !== 'default') _export(_key14, _ionicComponentsMenuMenuToggle[_key14]);
      }
    }, function (_ionicComponentsTextInputTextInput) {
      for (var _key15 in _ionicComponentsTextInputTextInput) {
        if (_key15 !== 'default') _export(_key15, _ionicComponentsTextInputTextInput[_key15]);
      }
    }, function (_ionicComponentsTextInputLabel) {
      for (var _key16 in _ionicComponentsTextInputLabel) {
        if (_key16 !== 'default') _export(_key16, _ionicComponentsTextInputLabel[_key16]);
      }
    }, function (_ionicComponentsListList) {
      for (var _key17 in _ionicComponentsListList) {
        if (_key17 !== 'default') _export(_key17, _ionicComponentsListList[_key17]);
      }
    }, function (_ionicComponentsShowHideWhenShowHideWhen) {
      for (var _key18 in _ionicComponentsShowHideWhenShowHideWhen) {
        if (_key18 !== 'default') _export(_key18, _ionicComponentsShowHideWhenShowHideWhen[_key18]);
      }
    }, function (_ionicComponentsModalModal) {
      for (var _key19 in _ionicComponentsModalModal) {
        if (_key19 !== 'default') _export(_key19, _ionicComponentsModalModal[_key19]);
      }
    }, function (_ionicComponentsNavNav) {
      for (var _key20 in _ionicComponentsNavNav) {
        if (_key20 !== 'default') _export(_key20, _ionicComponentsNavNav[_key20]);
      }
    }, function (_ionicComponentsNavNavController) {
      for (var _key21 in _ionicComponentsNavNavController) {
        if (_key21 !== 'default') _export(_key21, _ionicComponentsNavNavController[_key21]);
      }
    }, function (_ionicComponentsNavViewController) {
      for (var _key22 in _ionicComponentsNavViewController) {
        if (_key22 !== 'default') _export(_key22, _ionicComponentsNavViewController[_key22]);
      }
    }, function (_ionicComponentsNavNavPush) {
      for (var _key23 in _ionicComponentsNavNavPush) {
        if (_key23 !== 'default') _export(_key23, _ionicComponentsNavNavPush[_key23]);
      }
    }, function (_ionicComponentsNavNavRouter) {
      for (var _key24 in _ionicComponentsNavNavRouter) {
        if (_key24 !== 'default') _export(_key24, _ionicComponentsNavNavRouter[_key24]);
      }
    }, function (_ionicComponentsNavBarNavBar) {
      for (var _key25 in _ionicComponentsNavBarNavBar) {
        if (_key25 !== 'default') _export(_key25, _ionicComponentsNavBarNavBar[_key25]);
      }
    }, function (_ionicComponentsPopupPopup) {
      for (var _key26 in _ionicComponentsPopupPopup) {
        if (_key26 !== 'default') _export(_key26, _ionicComponentsPopupPopup[_key26]);
      }
    }, function (_ionicComponentsSlidesSlides) {
      for (var _key27 in _ionicComponentsSlidesSlides) {
        if (_key27 !== 'default') _export(_key27, _ionicComponentsSlidesSlides[_key27]);
      }
    }, function (_ionicComponentsRadioRadio) {
      for (var _key28 in _ionicComponentsRadioRadio) {
        if (_key28 !== 'default') _export(_key28, _ionicComponentsRadioRadio[_key28]);
      }
    }, function (_ionicComponentsScrollScroll) {
      for (var _key29 in _ionicComponentsScrollScroll) {
        if (_key29 !== 'default') _export(_key29, _ionicComponentsScrollScroll[_key29]);
      }
    }, function (_ionicComponentsScrollPullToRefresh) {
      for (var _key30 in _ionicComponentsScrollPullToRefresh) {
        if (_key30 !== 'default') _export(_key30, _ionicComponentsScrollPullToRefresh[_key30]);
      }
    }, function (_ionicComponentsSearchBarSearchBar) {
      for (var _key31 in _ionicComponentsSearchBarSearchBar) {
        if (_key31 !== 'default') _export(_key31, _ionicComponentsSearchBarSearchBar[_key31]);
      }
    }, function (_ionicComponentsSegmentSegment) {
      for (var _key32 in _ionicComponentsSegmentSegment) {
        if (_key32 !== 'default') _export(_key32, _ionicComponentsSegmentSegment[_key32]);
      }
    }, function (_ionicComponentsSwitchSwitch) {
      for (var _key33 in _ionicComponentsSwitchSwitch) {
        if (_key33 !== 'default') _export(_key33, _ionicComponentsSwitchSwitch[_key33]);
      }
    }, function (_ionicComponentsTabsTabs) {
      for (var _key34 in _ionicComponentsTabsTabs) {
        if (_key34 !== 'default') _export(_key34, _ionicComponentsTabsTabs[_key34]);
      }
    }, function (_ionicComponentsTabsTab) {
      for (var _key35 in _ionicComponentsTabsTab) {
        if (_key35 !== 'default') _export(_key35, _ionicComponentsTabsTab[_key35]);
      }
    }, function (_ionicComponentsToolbarToolbar) {
      for (var _key36 in _ionicComponentsToolbarToolbar) {
        if (_key36 !== 'default') _export(_key36, _ionicComponentsToolbarToolbar[_key36]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/index", [], function (_export) {
  "use strict";

  return {
    setters: [],
    execute: function () {}
  };
});
/*
 * export everything here
 */
System.register('ionic/ionic', ['./config/config', './config/modes', './config/decorators', './net/http', './components', './platform/platform', './platform/registry', './platform/plugins', './platform/storage', './util/click-block', './util/focus', './util/events', './animations/animation', './animations/builtins', './transitions/transition', './transitions/ios-transition', './transitions/md-transition'], function (_export) {
  'use strict';

  return {
    setters: [function (_configConfig) {
      for (var _key in _configConfig) {
        if (_key !== 'default') _export(_key, _configConfig[_key]);
      }
    }, function (_configModes) {
      for (var _key2 in _configModes) {
        if (_key2 !== 'default') _export(_key2, _configModes[_key2]);
      }
    }, function (_configDecorators) {
      for (var _key3 in _configDecorators) {
        if (_key3 !== 'default') _export(_key3, _configDecorators[_key3]);
      }
    }, function (_netHttp) {
      for (var _key4 in _netHttp) {
        if (_key4 !== 'default') _export(_key4, _netHttp[_key4]);
      }
    }, function (_components) {
      for (var _key5 in _components) {
        if (_key5 !== 'default') _export(_key5, _components[_key5]);
      }
    }, function (_platformPlatform) {
      for (var _key6 in _platformPlatform) {
        if (_key6 !== 'default') _export(_key6, _platformPlatform[_key6]);
      }
    }, function (_platformRegistry) {
      for (var _key7 in _platformRegistry) {
        if (_key7 !== 'default') _export(_key7, _platformRegistry[_key7]);
      }
    }, function (_platformPlugins) {
      for (var _key8 in _platformPlugins) {
        if (_key8 !== 'default') _export(_key8, _platformPlugins[_key8]);
      }

      for (var _key18 in _platformPlugins) {
        if (_key18 !== 'default') _export(_key18, _platformPlugins[_key18]);
      }
    }, function (_platformStorage) {
      for (var _key9 in _platformStorage) {
        if (_key9 !== 'default') _export(_key9, _platformStorage[_key9]);
      }
    }, function (_utilClickBlock) {
      for (var _key10 in _utilClickBlock) {
        if (_key10 !== 'default') _export(_key10, _utilClickBlock[_key10]);
      }
    }, function (_utilFocus) {
      for (var _key11 in _utilFocus) {
        if (_key11 !== 'default') _export(_key11, _utilFocus[_key11]);
      }
    }, function (_utilEvents) {
      for (var _key12 in _utilEvents) {
        if (_key12 !== 'default') _export(_key12, _utilEvents[_key12]);
      }
    }, function (_animationsAnimation) {
      for (var _key13 in _animationsAnimation) {
        if (_key13 !== 'default') _export(_key13, _animationsAnimation[_key13]);
      }
    }, function (_animationsBuiltins) {
      for (var _key14 in _animationsBuiltins) {
        if (_key14 !== 'default') _export(_key14, _animationsBuiltins[_key14]);
      }
    }, function (_transitionsTransition) {
      for (var _key15 in _transitionsTransition) {
        if (_key15 !== 'default') _export(_key15, _transitionsTransition[_key15]);
      }
    }, function (_transitionsIosTransition) {
      for (var _key16 in _transitionsIosTransition) {
        if (_key16 !== 'default') _export(_key16, _transitionsIosTransition[_key16]);
      }
    }, function (_transitionsMdTransition) {
      for (var _key17 in _transitionsMdTransition) {
        if (_key17 !== 'default') _export(_key17, _transitionsMdTransition[_key17]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/util', ['ionic/util/dom', 'ionic/util/util'], function (_export) {
  'use strict';

  var domUtil, dom;
  return {
    setters: [function (_ionicUtilDom) {
      domUtil = _ionicUtilDom;
    }, function (_ionicUtilUtil) {
      for (var _key in _ionicUtilUtil) {
        if (_key !== 'default') _export(_key, _ionicUtilUtil[_key]);
      }
    }],
    execute: function () {
      dom = domUtil;

      _export('dom', dom);
    }
  };
});
System.register('ionic/animations/animation', ['../util/dom', '../util/util'], function (_export) {
    /**
      Animation Steps/Process
      -----------------------
      1) Construct animation (doesn't start)
      2) Client play()'s animation, returns promise
      3) Add before classes to elements
      4) Remove before classes from elements
      5) Elements staged in "from" effect w/ inline styles
      6) Call onReady()
      7) Wait for RENDER_DELAY milliseconds (give browser time to render)
      8) Call onPlay()
      8) Run from/to animation on elements
      9) Animations finish async
     10) Set inline styles w/ the "to" effects on elements
     11) Add after classes to elements
     12) Remove after classes from elements
     13) Call onFinish()
     14) Resolve play()'s promise
    **/
    'use strict';

    var CSS, extend, Animation, Animate, TRANSFORMS, ANIMATE_PROPERTIES, CUBIC_BEZIERS, EASING_FN, AnimationRegistry;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertEffects(effects, fromEffect, toEffect, easingConfig) {
        easingConfig.opts = easingConfig.opts || {};
        var increment = easingConfig.opts.increment || 0.04;
        var easingFn = EASING_FN[easingConfig.name];
        var pos = undefined,
            tweenEffect = undefined,
            addEffect = undefined,
            property = undefined,
            toProperty = undefined,
            fromValue = undefined,
            diffValue = undefined;
        for (pos = increment; pos <= 1 - increment; pos += increment) {
            tweenEffect = {};
            addEffect = false;
            for (property in toEffect) {
                toProperty = toEffect[property];
                if (toProperty.tween) {
                    fromValue = fromEffect[property].num;
                    diffValue = toProperty.num - fromValue;
                    tweenEffect[property] = {
                        value: roundValue(easingFn(pos, easingConfig.opts) * diffValue + fromValue) + toProperty.unit
                    };
                    addEffect = true;
                }
            }
            if (addEffect) {
                effects.push(convertProperties(tweenEffect));
            }
        }
    }
    function parseEffect(inputEffect) {
        var val = undefined,
            r = undefined,
            num = undefined,
            property = undefined;
        var outputEffect = {};
        for (property in inputEffect) {
            val = inputEffect[property];
            r = val.toString().match(/(^-?\d*\.?\d*)(.*)/);
            num = parseFloat(r[1]);
            outputEffect[property] = {
                value: val,
                num: num,
                unit: r[0] != r[2] ? r[2] : '',
                tween: !isNaN(num) && ANIMATE_PROPERTIES.indexOf(property) > -1
            };
        }
        return outputEffect;
    }
    function convertProperties(inputEffect) {
        var outputEffect = {};
        var transforms = [];
        var value = undefined,
            property = undefined;
        for (property in inputEffect) {
            value = inputEffect[property].value;
            if (TRANSFORMS.indexOf(property) > -1) {
                transforms.push(property + '(' + value + ')');
            } else {
                outputEffect[property] = value;
            }
        }
        if (transforms.length) {
            transforms.push('translateZ(0px)');
            outputEffect.transform = transforms.join(' ');
        }
        return outputEffect;
    }
    function inlineStyle(ele, effect) {
        if (ele && effect) {
            var transforms = [];
            var value = undefined,
                property = undefined;
            for (property in effect) {
                value = effect[property].value;
                if (TRANSFORMS.indexOf(property) > -1) {
                    transforms.push(property + '(' + value + ')');
                } else {
                    ele.style[property] = value;
                }
            }
            if (transforms.length) {
                transforms.push('translateZ(0px)');
                ele.style[CSS.transform] = transforms.join(' ');
            }
        }
    }
    function roundValue(val) {
        return Math.round(val * 10000) / 10000;
    }
    return {
        setters: [function (_utilDom) {
            CSS = _utilDom.CSS;
        }, function (_utilUtil) {
            extend = _utilUtil.extend;
        }],
        execute: function () {
            Animation = (function () {
                function Animation(ele) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Animation);

                    this._el = [];
                    this._chld = [];
                    this._ani = [];
                    this._opts = extend({
                        renderDelay: 36
                    }, opts);
                    this._bfAdd = [];
                    this._bfSty = {};
                    this._bfRmv = [];
                    this._afAdd = [];
                    this._afRmv = [];
                    this._readys = [];
                    this._plays = [];
                    this._finishes = [];
                    this.elements(ele);
                    if (!document.documentElement.animate) {
                        console.error('Web Animations polyfill missing');
                    }
                }

                _createClass(Animation, [{
                    key: 'elements',
                    value: function elements(ele) {
                        if (ele) {
                            if (typeof ele === 'string') {
                                // string query selector
                                ele = document.querySelectorAll(ele);
                            }
                            if (ele.length) {
                                // array of elements
                                for (var i = 0; i < ele.length; i++) {
                                    this.addElement(ele[i]);
                                }
                            } else {
                                // single element
                                this.addElement(ele);
                            }
                        }
                        return this;
                    }
                }, {
                    key: 'addElement',
                    value: function addElement(ele) {
                        // ensure only HTML Element nodes
                        if (ele) {
                            if (ele.nativeElement) {
                                // angular ElementRef
                                ele = ele.nativeElement;
                            }
                            if (ele.nodeType === 1) {
                                this._el.push(ele);
                            }
                        }
                    }
                }, {
                    key: 'parent',
                    value: function parent(parentAnimation) {
                        this._parent = parentAnimation;
                        return this;
                    }
                }, {
                    key: 'add',
                    value: function add(childAnimations) {
                        childAnimations = Array.isArray(childAnimations) ? childAnimations : arguments;
                        for (var i = 0; i < childAnimations.length; i++) {
                            childAnimations[i].parent(this);
                            this._chld.push(childAnimations[i]);
                        }
                        return this;
                    }
                }, {
                    key: 'duration',
                    value: function duration(value) {
                        if (arguments.length) {
                            this._duration = value;
                            return this;
                        }
                        return this._duration || this._parent && this._parent.duration();
                    }
                }, {
                    key: 'easing',
                    value: function easing(name, opts) {
                        if (arguments.length) {
                            this._easing = {
                                name: name,
                                opts: opts
                            };
                            return this;
                        }
                        return this._easing || this._parent && this._parent.easing();
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        if (arguments.length) {
                            this._rate = value;
                            var i = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i].playbackRate(value);
                            }
                            for (i = 0; i < this._ani.length; i++) {
                                this._ani[i].playbackRate(value);
                            }
                            return this;
                        }
                        return typeof this._rate !== 'undefined' ? this._rate : this._parent && this._parent.playbackRate();
                    }
                }, {
                    key: 'reverse',
                    value: function reverse() {
                        return this.playbackRate(-1);
                    }
                }, {
                    key: 'forward',
                    value: function forward() {
                        return this.playbackRate(1);
                    }
                }, {
                    key: 'from',
                    value: function from(property, value) {
                        if (!this._from) {
                            this._from = {};
                        }
                        this._from[property] = value;
                        return this;
                    }
                }, {
                    key: 'to',
                    value: function to(property, value) {
                        if (!this._to) {
                            this._to = {};
                        }
                        this._to[property] = value;
                        return this;
                    }
                }, {
                    key: 'fromTo',
                    value: function fromTo(property, from, to) {
                        return this.from(property, from).to(property, to);
                    }
                }, {
                    key: 'fadeIn',
                    value: function fadeIn() {
                        return this.fromTo('opacity', 0.01, 1);
                    }
                }, {
                    key: 'fadeOut',
                    value: function fadeOut() {
                        return this.fromTo('opacity', 1, 0);
                    }
                }, {
                    key: 'play',
                    value: function play() {
                        var _this = this;

                        var self = this;
                        // the actual play() method which may or may not start async
                        function beginPlay() {
                            var promises = [];
                            for (var i = 0, l = self._chld.length; i < l; i++) {
                                promises.push(self._chld[i].play());
                            }
                            self._ani.forEach(function (animation) {
                                promises.push(new Promise(function (resolve) {
                                    animation.play(resolve);
                                }));
                            });
                            return Promise.all(promises);
                        }
                        if (!self._parent) {
                            var _ret = (function () {
                                var kickoff = function kickoff() {
                                    // synchronously call all onPlay()'s before play()
                                    self._onPlay();
                                    beginPlay().then(function () {
                                        self._onFinish();
                                        resolve();
                                    });
                                };

                                // this is the top level animation and is in full control
                                // of when the async play() should actually kick off
                                // stage all animations and child animations at their starting point
                                self.stage();
                                var resolve = undefined;
                                var promise = new Promise(function (res) {
                                    resolve = res;
                                });

                                if (self._duration > _this._opts.renderDelay) {
                                    // begin each animation when everything is rendered in their starting point
                                    // give the browser some time to render everything in place before starting
                                    setTimeout(kickoff, _this._opts.renderDelay);
                                } else {
                                    // no need to render everything in there place before animating in
                                    // just kick it off immediately to render them in their "to" locations
                                    kickoff();
                                }
                                return {
                                    v: promise
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        }
                        // this is a child animation, it is told exactly when to
                        // start by the top level animation
                        return beginPlay();
                    }
                }, {
                    key: 'stage',
                    value: function stage() {
                        // before the RENDER_DELAY
                        // before the animations have started
                        if (!this._isStaged) {
                            this._isStaged = true;
                            var i = undefined,
                                p = undefined,
                                l = undefined,
                                j = undefined,
                                ele = undefined,
                                animation = undefined;
                            for (i = 0, l = this._chld.length; i < l; i++) {
                                this._chld[i].stage();
                            }
                            for (i = 0; i < this._el.length; i++) {
                                ele = this._el[i];
                                for (j = 0; j < this._bfAdd.length; j++) {
                                    ele.classList.add(this._bfAdd[j]);
                                }
                                for (p in this._bfSty) {
                                    ele.style[p] = this._bfSty[p];
                                }
                                for (j = 0; j < this._bfRmv.length; j++) {
                                    ele.classList.remove(this._bfRmv[j]);
                                }
                            }
                            if (this._to) {
                                // only animate the elements if there are defined "to" effects
                                for (i = 0; i < this._el.length; i++) {
                                    animation = new Animate(this._el[i], this._from, this._to, this.duration(), this.easing(), this.playbackRate(), this._opts.renderDelay);
                                    if (animation.shouldAnimate) {
                                        this._ani.push(animation);
                                    }
                                }
                            }
                            for (i = 0; i < this._readys.length; i++) {
                                this._readys[i](this);
                            }
                        }
                    }
                }, {
                    key: '_onPlay',
                    value: function _onPlay() {
                        // after the RENDER_DELAY
                        // before the animations have started
                        var i = undefined;
                        this._isFinished = false;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i]._onPlay();
                        }
                        for (i = 0; i < this._plays.length; i++) {
                            this._plays[i](this);
                        }
                    }
                }, {
                    key: '_onFinish',
                    value: function _onFinish() {
                        // after the animations have finished
                        if (!this._isFinished && !this.isProgress) {
                            this._isFinished = true;
                            var i = undefined,
                                j = undefined,
                                ele = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i]._onFinish();
                            }
                            if (this.playbackRate() < 0) {
                                // reverse direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._bfAdd.length; j++) {
                                        ele.classList.remove(this._bfAdd[j]);
                                    }
                                    for (j = 0; j < this._bfRmv.length; j++) {
                                        ele.classList.add(this._bfRmv[j]);
                                    }
                                }
                            } else {
                                // normal direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._afAdd.length; j++) {
                                        ele.classList.add(this._afAdd[j]);
                                    }
                                    for (j = 0; j < this._afRmv.length; j++) {
                                        ele.classList.remove(this._afRmv[j]);
                                    }
                                }
                            }
                            for (i = 0; i < this._finishes.length; i++) {
                                this._finishes[i](this);
                            }
                        }
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].pause();
                        }
                    }
                }, {
                    key: 'progressStart',
                    value: function progressStart() {
                        this.isProgress = true;
                        for (var i = 0; i < this._chld.length; i++) {
                            this._chld[i].progressStart();
                        }
                        this.duration(1000);
                        this.play();
                        this.pause();
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        value = Math.min(1, Math.max(0, value));
                        this.isProgress = true;
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].progress(value);
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].progress(value);
                        }
                    }
                }, {
                    key: 'progressEnd',
                    value: function progressEnd(shouldComplete) {
                        var rate = arguments.length <= 1 || arguments[1] === undefined ? 3 : arguments[1];

                        var promises = [];
                        this.isProgress = false;
                        for (var i = 0; i < this._chld.length; i++) {
                            promises.push(this._chld[i].progressEnd(shouldComplete));
                        }
                        this._ani.forEach(function (animation) {
                            if (shouldComplete) {
                                animation.playbackRate(rate);
                            } else {
                                animation.playbackRate(rate * -1);
                            }
                            promises.push(new Promise(function (resolve) {
                                animation.play(resolve);
                            }));
                        });
                        return Promise.all(promises);
                    }
                }, {
                    key: 'onReady',
                    value: function onReady(fn, clear) {
                        if (clear) {
                            this._readys = [];
                        }
                        this._readys.push(fn);
                        return this;
                    }
                }, {
                    key: 'onPlay',
                    value: function onPlay(fn, clear) {
                        if (clear) {
                            this._plays = [];
                        }
                        this._plays.push(fn);
                        return this;
                    }
                }, {
                    key: 'onFinish',
                    value: function onFinish(fn, clear) {
                        if (clear) {
                            this._finishes = [];
                        }
                        this._finishes.push(fn);
                        return this;
                    }
                }, {
                    key: 'clone',
                    value: function clone() {
                        function copy(dest, src) {
                            // undo what stage() may have already done
                            extend(dest, src);
                            dest._isFinished = dest._isStaged = dest.isProgress = false;
                            dest._chld = [];
                            dest._ani = [];
                            for (var i = 0; i < src._chld.length; i++) {
                                dest.add(copy(new Animation(), src._chld[i]));
                            }
                            return dest;
                        }
                        return copy(new Animation(), this);
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].dispose();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].dispose();
                        }
                        this._el = this._parent = this._chld = this._ani = this._readys = this._plays = this._finishes = null;
                    }

                    /*
                     STATIC CLASSES
                     */
                }, {
                    key: 'before',
                    get: function get() {
                        var _this2 = this;

                        return {
                            addClass: function addClass(className) {
                                _this2._bfAdd.push(className);
                                return _this2;
                            },
                            removeClass: function removeClass(className) {
                                _this2._bfRmv.push(className);
                                return _this2;
                            },
                            setStyles: function setStyles(styles) {
                                _this2._bfSty = styles;
                            }
                        };
                    }
                }, {
                    key: 'after',
                    get: function get() {
                        var _this3 = this;

                        return {
                            addClass: function addClass(className) {
                                _this3._afAdd.push(className);
                                return _this3;
                            },
                            removeClass: function removeClass(className) {
                                _this3._afRmv.push(className);
                                return _this3;
                            }
                        };
                    }
                }], [{
                    key: 'create',
                    value: function create(element, name) {
                        var AnimationClass = AnimationRegistry[name];
                        if (!AnimationClass) {
                            // couldn't find an animation by the given name
                            // fallback to just the base Animation class
                            AnimationClass = Animation;
                        }
                        return new AnimationClass(element);
                    }
                }, {
                    key: 'register',
                    value: function register(name, AnimationClass) {
                        AnimationRegistry[name] = AnimationClass;
                    }
                }]);

                return Animation;
            })();

            _export('Animation', Animation);

            Animate = (function () {
                function Animate(ele, fromEffect, toEffect, duration, easingConfig, playbackRate, renderDelay) {
                    _classCallCheck(this, Animate);

                    // https://w3c.github.io/web-animations/
                    // not using the direct API methods because they're still in flux
                    // however, element.animate() seems locked in and uses the latest
                    // and correct API methods under the hood, so really doesn't matter
                    if (!fromEffect) {
                        return console.error(ele.tagName, 'animation fromEffect required, toEffect:', toEffect);
                    }
                    this.toEffect = parseEffect(toEffect);
                    this.shouldAnimate = duration > renderDelay;
                    if (!this.shouldAnimate) {
                        return inlineStyle(ele, this.toEffect);
                    }
                    this.ele = ele;
                    // stage where the element will start from
                    this.fromEffect = parseEffect(fromEffect);
                    inlineStyle(ele, this.fromEffect);
                    this.duration = duration;
                    this.rate = typeof playbackRate !== 'undefined' ? playbackRate : 1;
                    this.easing = easingConfig && easingConfig.name || 'linear';
                    this.effects = [convertProperties(this.fromEffect)];
                    if (this.easing in EASING_FN) {
                        insertEffects(this.effects, this.fromEffect, this.toEffect, easingConfig);
                    } else if (this.easing in CUBIC_BEZIERS) {
                        this.easing = 'cubic-bezier(' + CUBIC_BEZIERS[this.easing] + ')';
                    }
                    this.effects.push(convertProperties(this.toEffect));
                }

                _createClass(Animate, [{
                    key: 'play',
                    value: function play(callback) {
                        var self = this;
                        if (self.ani) {
                            self.ani.play();
                        } else {
                            // https://developers.google.com/web/updates/2014/05/Web-Animations---element-animate-is-now-in-Chrome-36
                            // https://w3c.github.io/web-animations/
                            // Future versions will use "new window.Animation" rather than "element.animate()"
                            self.ani = self.ele.animate(self.effects, {
                                duration: self.duration || 0,
                                easing: self.easing,
                                playbackRate: self.rate // old way of setting playbackRate, but still necessary
                            });
                            self.ani.playbackRate = self.rate;
                        }
                        self.ani.onfinish = function () {
                            // lock in where the element will stop at
                            // if the playbackRate is negative then it needs to return
                            // to its "from" effects
                            inlineStyle(self.ele, self.rate < 0 ? self.fromEffect : self.toEffect);
                            self.ani = null;
                            callback && callback();
                        };
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this.ani && this.ani.pause();
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        if (this.ani) {
                            // passed a number between 0 and 1
                            if (this.ani.playState !== 'paused') {
                                this.ani.pause();
                            }
                            // don't let the progress finish the animation
                            // leave it off JUST before it's finished
                            value = Math.min(0.999, Math.max(0.001, value));
                            this.ani.currentTime = this.duration * value;
                        }
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        this.rate = value;
                        if (this.ani) {
                            this.ani.playbackRate = value;
                        }
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.ele = this.ani = this.effects = this.toEffect = null;
                    }
                }]);

                return Animate;
            })();

            TRANSFORMS = ['translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'perspective'];
            ANIMATE_PROPERTIES = TRANSFORMS.concat('opacity');

            // Robert Penner's Easing Functions
            // http://robertpenner.com/easing/
            CUBIC_BEZIERS = {
                // default browser suppored easing
                // ease
                // ease-in
                // ease-out
                // ease-in-out
                // Cubic
                'ease-in-cubic': '0.55,0.055,0.675,0.19',
                'ease-out-cubic': '0.215,0.61,0.355,1',
                'ease-in-Out-cubic': '0.645,0.045,0.355,1',
                // Circ
                'ease-in-circ': '0.6,0.04,0.98,0.335',
                'ease-out-circ': '0.075,0.82,0.165,1',
                'ease-in-out-circ': '0.785,0.135,0.15,0.86',
                // Expo
                'ease-in-expo': '0.95,0.05,0.795,0.035',
                'ease-out-expo': '0.19,1,0.22,1',
                'ease-in-out-expo': '1,0,0,1',
                // Quad
                'ease-in-quad': '0.55,0.085,0.68,0.53',
                'ease-out-quad': '0.25,0.46,0.45,0.94',
                'ease-in-out-quad': '0.455,0.03,0.515,0.955',
                // Quart
                'ease-in-quart': '0.895,0.03,0.685,0.22',
                'ease-out-quart': '0.165,0.84,0.44,1',
                'ease-in-out-quart': '0.77,0,0.175,1',
                // Quint
                'ease-in-quint': '0.755,0.05,0.855,0.06',
                'ease-out-quint': '0.23,1,0.32,1',
                'ease-in-out-quint': '0.86,0,0.07,1',
                // Sine
                'ease-in-sine': '0.47,0,0.745,0.715',
                'ease-out-sine': '0.39,0.575,0.565,1',
                'ease-in-out-sine': '0.445,0.05,0.55,0.95',
                // Back
                'ease-in-back': '0.6,-0.28,0.735,0.045',
                'ease-out-back': '0.175,0.885,0.32,1.275',
                'ease-in-out-back': '0.68,-0.55,0.265,1.55'
            };
            EASING_FN = {
                'elastic': function elastic(pos) {
                    return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                },
                'swing-from-to': function swingFromTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                },
                'swing-from': function swingFrom(pos, opts) {
                    var s = opts.s || 1.70158;
                    return pos * pos * ((s + 1) * pos - s);
                },
                'swing-to': function swingTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                },
                'bounce': function bounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'bounce-past': function bouncePast(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
                    } else if (pos < 2.5 / 2.75) {
                        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
                    }
                    return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
                },
                'ease-out-bounce': function easeOutBounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'ease-from-to': function easeFromTo(pos) {
                    if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
                    return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                },
                'ease-from': function easeFrom(pos, opts) {
                    return Math.pow(pos, opts.s || 4);
                },
                'ease-to': function easeTo(pos, opts) {
                    return Math.pow(pos, opts.s || 0.25);
                },
                /*
                 * scripty2, Thomas Fuchs (MIT Licence)
                 * https://raw.github.com/madrobby/scripty2/master/src/effects/transitions/transitions.js
                 */
                'spring': function spring(pos, opts) {
                    var damping = opts.damping || 4.5;
                    var elasticity = opts.elasticity || 6;
                    return 1 - Math.cos(pos * damping * Math.PI) * Math.exp(-pos * elasticity);
                },
                'sinusoidal': function sinusoidal(pos) {
                    return -Math.cos(pos * Math.PI) / 2 + 0.5;
                }
            };
            AnimationRegistry = {};
        }
    };
});
System.register('ionic/animations/builtins', ['./animation'], function (_export) {
    'use strict';

    var Animation, SlideIn, SlideOut, FadeIn, FadeOut;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_animation) {
            Animation = _animation.Animation;
        }],
        execute: function () {
            SlideIn = (function (_Animation) {
                _inherits(SlideIn, _Animation);

                function SlideIn(element) {
                    _classCallCheck(this, SlideIn);

                    _get(Object.getPrototypeOf(SlideIn.prototype), 'constructor', this).call(this, element);
                    this.easing('cubic-bezier(0.1,0.7,0.1,1)').duration(400).fromTo('translateY', '100%', '0%');
                }

                return SlideIn;
            })(Animation);

            Animation.register('slide-in', SlideIn);

            SlideOut = (function (_Animation2) {
                _inherits(SlideOut, _Animation2);

                function SlideOut(element) {
                    _classCallCheck(this, SlideOut);

                    _get(Object.getPrototypeOf(SlideOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                return SlideOut;
            })(Animation);

            Animation.register('slide-out', SlideOut);

            FadeIn = (function (_Animation3) {
                _inherits(FadeIn, _Animation3);

                function FadeIn(element) {
                    _classCallCheck(this, FadeIn);

                    _get(Object.getPrototypeOf(FadeIn.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-in').duration(400).fadeIn();
                }

                return FadeIn;
            })(Animation);

            Animation.register('fade-in', FadeIn);

            FadeOut = (function (_Animation4) {
                _inherits(FadeOut, _Animation4);

                function FadeOut(element) {
                    _classCallCheck(this, FadeOut);

                    _get(Object.getPrototypeOf(FadeOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fadeOut();
                }

                return FadeOut;
            })(Animation);

            Animation.register('fade-out', FadeOut);
        }
    };
});
System.register('ionic/animations/scroll-to', ['../util/dom'], function (_export) {
    'use strict';

    var raf, ScrollTo;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            raf = _utilDom.raf;
        }],
        execute: function () {
            ScrollTo = (function () {
                function ScrollTo(ele, x, y, duration) {
                    _classCallCheck(this, ScrollTo);

                    if (typeof ele === 'string') {
                        // string query selector
                        ele = document.querySelector(ele);
                    }
                    if (ele) {
                        if (ele.nativeElement) {
                            // angular ElementRef
                            ele = ele.nativeElement;
                        }
                        if (ele.nodeType === 1) {
                            this._el = ele;
                        }
                    }
                }

                _createClass(ScrollTo, [{
                    key: 'start',
                    value: function start(x, y, duration, tolerance) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var self = this;
                        if (!self._el) {
                            // invalid element
                            return Promise.resolve();
                        }
                        x = x || 0;
                        y = y || 0;
                        tolerance = tolerance || 0;
                        var ele = self._el;
                        var fromY = ele.scrollTop;
                        var fromX = ele.scrollLeft;
                        var xDistance = Math.abs(x - fromX);
                        var yDistance = Math.abs(y - fromY);
                        if (yDistance <= tolerance && xDistance <= tolerance) {
                            // prevent scrolling if already close to there
                            this._el = ele = null;
                            return Promise.resolve();
                        }
                        return new Promise(function (resolve, reject) {
                            var start = Date.now();
                            // start scroll loop
                            self.isPlaying = true;
                            raf(step);
                            // decelerating to zero velocity
                            function easeOutCubic(t) {
                                return --t * t * t + 1;
                            }
                            // scroll loop
                            function step() {
                                var time = Math.min(1, (Date.now() - start) / duration);
                                // where .5 would be 50% of time on a linear scale easedT gives a
                                // fraction based on the easing method
                                var easedT = easeOutCubic(time);
                                if (fromY != y) {
                                    ele.scrollTop = parseInt(easedT * (y - fromY) + fromY, 10);
                                }
                                if (fromX != x) {
                                    ele.scrollLeft = parseInt(easedT * (x - fromX) + fromX, 10);
                                }
                                if (time < 1 && self.isPlaying) {
                                    raf(step);
                                } else if (!self.isPlaying) {
                                    // stopped
                                    this._el = ele = null;
                                    reject();
                                } else {
                                    // done
                                    this._el = ele = null;
                                    resolve();
                                }
                            }
                        });
                    }
                }, {
                    key: 'stop',
                    value: function stop() {
                        this.isPlaying = false;
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.stop();
                        this._el = null;
                    }
                }]);

                return ScrollTo;
            })();

            _export('ScrollTo', ScrollTo);
        }
    };
});
System.register('ionic/components/ion', ['ionic/util/dom'], function (_export) {
    /**
     * Base class for all Ionic components. Exposes some common functionality
     * that all Ionic components need, such as accessing underlying native elements and
     * sending/receiving app-level events.
     */
    'use strict';

    var dom, Ion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtilDom) {
            dom = _ionicUtilDom;
        }],
        execute: function () {
            Ion = (function () {
                function Ion(elementRef, config) {
                    _classCallCheck(this, Ion);

                    this.elementRef = elementRef;
                    this.config = config;
                }

                _createClass(Ion, [{
                    key: 'onInit',
                    value: function onInit() {
                        var cls = this.constructor;
                        if (cls.defaultProperties && this.config) {
                            for (var prop in cls.defaultProperties) {
                                // Priority:
                                // ---------
                                // 1) Value set from within constructor
                                // 2) Value set from the host element's attribute
                                // 3) Value set by the users global config
                                // 4) Value set by the default mode/platform config
                                // 5) Value set from the component's default
                                if (this[prop]) {
                                    // this property has already been set on the instance
                                    // could be from the user setting the element's attribute
                                    // or from the user setting it within the constructor
                                    continue;
                                }
                                // get the property values from a global user/platform config
                                var configVal = this.config.setting(prop);
                                if (configVal) {
                                    this[prop] = configVal;
                                    continue;
                                }
                                // wasn't set yet, so go with property's default value
                                this[prop] = cls.defaultProperties[prop];
                            }
                        }
                    }
                }, {
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this.elementRef;
                    }
                }, {
                    key: 'getNativeElement',
                    value: function getNativeElement() {
                        return this.elementRef.nativeElement;
                    }
                }, {
                    key: 'getDimensions',
                    value: function getDimensions() {
                        return dom.getDimensions(this);
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        return this.getDimensions().w;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        return this.getDimensions().h;
                    }
                }]);

                return Ion;
            })();

            _export('Ion', Ion);
        }
    };
});
System.register('ionic/config/annotations', ['angular2/angular2', 'ionic/util', '../components/app/app', '../ionic'], function (_export) {
    /**
     * The core Ionic directives.  Automatically available in every IonicView
     * template.
     */
    'use strict';

    var CORE_DIRECTIVES, FORM_DIRECTIVES, NgStyle, Component, Directive, View, forwardRef, util, ionicBootstrap, Menu, MenuToggle, Button, Content, Scroll, Refresher, Slides, Slide, SlideLazy, Tabs, Tab, Card, List, ListHeader, Item, ItemGroup, ItemGroupTitle, Toolbar, ToolbarTitle, ToolbarItem, Icon, Checkbox, Switch, TextInput, TextInputElement, Label, Segment, SegmentButton, SegmentControlValueAccessor, RadioGroup, RadioButton, Nav, NavbarTemplate, Navbar, NavPush, NavPop, NavRouter, IdRef, ShowWhen, HideWhen, IonicDirectives, IonicViewImpl;

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    /**
     * TODO
     */

    _export('IonicView', IonicView);

    /**
     * TODO
     */

    _export('IonicDirective', IonicDirective);

    _export('IonicComponent', IonicComponent);

    _export('App', App);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    /**
     * TODO
     */

    function IonicView(args) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new IonicViewImpl(args));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicDirective(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Directive(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicComponent(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Component(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function appendConfig(cls, config) {
        config.host = config.host || {};
        cls.defaultProperties = config.defaultProperties || {};
        config.properties = config.properties || [];
        for (var prop in cls.defaultProperties) {
            // add the property to the component "properties"
            config.properties.push(prop);
            // set the component "hostProperties", so the instance's
            // property value will be used to set the element's attribute
            config.host['[attr.' + util.pascalCaseToDashCase(prop) + ']'] = prop;
        }
        cls.delegates = config.delegates;
        var componentId = config.classId || config.selector && config.selector.replace('ion-', '');
        config.host['class'] = ((config.host['class'] || '') + ' ' + componentId).trim();
        return config;
    }
    /**
     * TODO
     */

    function App() {
        var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        return function (cls) {
            // get current annotations
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            // create @Component
            args.selector = args.selector || 'ion-app';
            annotations.push(new Component(args));
            // create @View
            // if no template was provided, default so it has a root ion-nav
            if (!args.templateUrl && !args.template) {
                args.template = '<ion-nav></ion-nav>';
            }
            annotations.push(new IonicViewImpl(args));
            // redefine with added annotations
            Reflect.defineMetadata('annotations', annotations, cls);
            ionicBootstrap(cls, args.config);
            return cls;
        };
    }

    return {
        setters: [function (_angular2Angular2) {
            CORE_DIRECTIVES = _angular2Angular2.CORE_DIRECTIVES;
            FORM_DIRECTIVES = _angular2Angular2.FORM_DIRECTIVES;
            NgStyle = _angular2Angular2.NgStyle;
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_componentsAppApp) {
            ionicBootstrap = _componentsAppApp.ionicBootstrap;
        }, function (_ionic) {
            Menu = _ionic.Menu;
            MenuToggle = _ionic.MenuToggle;
            Button = _ionic.Button;
            Content = _ionic.Content;
            Scroll = _ionic.Scroll;
            Refresher = _ionic.Refresher;
            Slides = _ionic.Slides;
            Slide = _ionic.Slide;
            SlideLazy = _ionic.SlideLazy;
            Tabs = _ionic.Tabs;
            Tab = _ionic.Tab;
            Card = _ionic.Card;
            List = _ionic.List;
            ListHeader = _ionic.ListHeader;
            Item = _ionic.Item;
            ItemGroup = _ionic.ItemGroup;
            ItemGroupTitle = _ionic.ItemGroupTitle;
            Toolbar = _ionic.Toolbar;
            ToolbarTitle = _ionic.ToolbarTitle;
            ToolbarItem = _ionic.ToolbarItem;
            Icon = _ionic.Icon;
            Checkbox = _ionic.Checkbox;
            Switch = _ionic.Switch;
            TextInput = _ionic.TextInput;
            TextInputElement = _ionic.TextInputElement;
            Label = _ionic.Label;
            Segment = _ionic.Segment;
            SegmentButton = _ionic.SegmentButton;
            SegmentControlValueAccessor = _ionic.SegmentControlValueAccessor;
            RadioGroup = _ionic.RadioGroup;
            RadioButton = _ionic.RadioButton;
            Nav = _ionic.Nav;
            NavbarTemplate = _ionic.NavbarTemplate;
            Navbar = _ionic.Navbar;
            NavPush = _ionic.NavPush;
            NavPop = _ionic.NavPop;
            NavRouter = _ionic.NavRouter;
            IdRef = _ionic.IdRef;
            ShowWhen = _ionic.ShowWhen;
            HideWhen = _ionic.HideWhen;
        }],
        execute: function () {
            IonicDirectives = [
            // TODO: Why is forwardRef() required when they're already imported above????
            // Angular
            CORE_DIRECTIVES, FORM_DIRECTIVES, NgStyle,
            // Content
            forwardRef(function () {
                return Menu;
            }), forwardRef(function () {
                return MenuToggle;
            }), forwardRef(function () {
                return Button;
            }), forwardRef(function () {
                return Content;
            }), forwardRef(function () {
                return Scroll;
            }), forwardRef(function () {
                return Refresher;
            }),
            // Lists
            forwardRef(function () {
                return Card;
            }), forwardRef(function () {
                return List;
            }), forwardRef(function () {
                return ListHeader;
            }), forwardRef(function () {
                return Item;
            }), forwardRef(function () {
                return ItemGroup;
            }), forwardRef(function () {
                return ItemGroupTitle;
            }),
            // Slides
            forwardRef(function () {
                return Slides;
            }), forwardRef(function () {
                return Slide;
            }), forwardRef(function () {
                return SlideLazy;
            }),
            // Tabs
            forwardRef(function () {
                return Tabs;
            }), forwardRef(function () {
                return Tab;
            }),
            // Toolbar
            forwardRef(function () {
                return Toolbar;
            }), forwardRef(function () {
                return ToolbarTitle;
            }), forwardRef(function () {
                return ToolbarItem;
            }),
            // Media
            forwardRef(function () {
                return Icon;
            }),
            // Forms
            forwardRef(function () {
                return Segment;
            }), forwardRef(function () {
                return SegmentButton;
            }), forwardRef(function () {
                return SegmentControlValueAccessor;
            }), forwardRef(function () {
                return Checkbox;
            }), forwardRef(function () {
                return RadioGroup;
            }), forwardRef(function () {
                return RadioButton;
            }), forwardRef(function () {
                return Switch;
            }), forwardRef(function () {
                return TextInput;
            }), forwardRef(function () {
                return TextInputElement;
            }), forwardRef(function () {
                return Label;
            }),
            // Nav
            forwardRef(function () {
                return Nav;
            }), forwardRef(function () {
                return NavbarTemplate;
            }), forwardRef(function () {
                return Navbar;
            }), forwardRef(function () {
                return NavPush;
            }), forwardRef(function () {
                return NavPop;
            }), forwardRef(function () {
                return NavRouter;
            }), forwardRef(function () {
                return IdRef;
            }), forwardRef(function () {
                return ShowWhen;
            }), forwardRef(function () {
                return HideWhen;
            })];

            _export('IonicDirectives', IonicDirectives);

            IonicViewImpl = (function (_View) {
                _inherits(IonicViewImpl, _View);

                function IonicViewImpl() {
                    var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, IonicViewImpl);

                    args.directives = (args.directives || []).concat(IonicDirectives);
                    _get(Object.getPrototypeOf(IonicViewImpl.prototype), 'constructor', this).call(this, args);
                }

                return IonicViewImpl;
            })(View);
        }
    };
});
System.register('ionic/config/config', ['../util/util'], function (_export) {
    /**
    * TODO
    */
    'use strict';

    var isObject, isDefined, isFunction, extend, IonicConfig, modeConfigs;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilUtil) {
            isObject = _utilUtil.isObject;
            isDefined = _utilUtil.isDefined;
            isFunction = _utilUtil.isFunction;
            extend = _utilUtil.extend;
        }],
        execute: function () {
            IonicConfig = (function () {
                /**
                 * TODO
                 * @param  {Object} settings   The settings for your app
                 */

                function IonicConfig(settings) {
                    _classCallCheck(this, IonicConfig);

                    // defaults
                    this._settings = {};
                    // override defaults w/ user config
                    if (settings) {
                        extend(this._settings, settings);
                    }
                }

                /**
                * TODO
                */

                _createClass(IonicConfig, [{
                    key: 'setting',
                    value: function setting() {
                        var args = arguments;
                        var arg0 = args[0];
                        var arg1 = args[1];
                        var settings = this._settings;
                        switch (args.length) {
                            case 0:
                                // setting() = get settings object
                                return settings;
                            case 1:
                                // setting({...}) = set settings object
                                // setting('key') = get value
                                if (isObject(arg0)) {
                                    // setting({...}) = set settings object
                                    // arg0 = setting object
                                    this._settings = arg0;
                                    return this;
                                }
                                // time for the big show, get the value
                                // setting('key') = get value
                                // arg0 = key
                                if (!isDefined(settings[arg0])) {
                                    // if the value was already set this will all be skipped
                                    // if there was no user config then it'll check each of
                                    // the user config's platforms, which already contains
                                    // settings from default platform configs
                                    settings[arg0] = null;
                                    // check the platform settings object for this value
                                    // loop though each of the active platforms
                                    var activePlatformKeys = this._platforms;
                                    var platformSettings = settings.platforms;
                                    var platformObj = null;
                                    if (platformSettings) {
                                        var platformValue = undefined;
                                        for (var i = 0; i < activePlatformKeys.length; i++) {
                                            platformObj = platformSettings[activePlatformKeys[i]];
                                            if (platformObj) {
                                                if (isDefined(platformObj[arg0])) {
                                                    // check assigned platform settings
                                                    platformValue = platformObj[arg0];
                                                } else if (platformObj.mode) {
                                                    // check the platform default mode settings
                                                    platformObj = IonicConfig.modeConfig(platformObj.mode);
                                                    if (platformObj) {
                                                        platformValue = platformObj[arg0];
                                                    }
                                                }
                                            }
                                        }
                                        if (isDefined(platformValue)) {
                                            settings[arg0] = platformValue;
                                        }
                                    }
                                }
                                // return key's value
                                // either it came directly from the user config
                                // or it was from the users platform configs
                                // or it was from the default platform configs
                                // in that order
                                if (isFunction(settings[arg0])) {
                                    settings[arg0] = settings[arg0](this._platform);
                                }
                                return settings[arg0];
                            case 2:
                                // setting('ios', {...}) = set platform config object
                                // setting('key', 'value') = set key/value pair
                                if (isObject(arg1)) {
                                    // setting('ios', {...}) = set platform config object
                                    // arg0 = platform
                                    // arg1 = platform config object
                                    settings.platforms = settings.platforms || {};
                                    settings.platforms[arg0] = arg1;
                                } else {
                                    // setting('key', 'value') = set key/value pair
                                    // arg0 = key
                                    // arg1 = value
                                    settings[arg0] = arg1;
                                }
                                return this;
                            case 3:
                                // setting('ios', 'key', 'value') = set key/value pair for platform
                                // arg0 = platform
                                // arg1 = key
                                // arg2 = value
                                settings.platforms = settings.platforms || {};
                                settings.platforms[arg0] = settings.platforms[arg0] || {};
                                settings.platforms[arg0][arg1] = args[2];
                                return this;
                        }
                    }

                    /**
                     * TODO
                     * @param  {Object} platform   The platform
                     */
                }, {
                    key: 'setPlatform',
                    value: function setPlatform(platform) {
                        this._platform = platform;
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        this._platforms = platform.platforms();
                        // copy default platform settings into the user config platform settings
                        // user config platform settings should override default platform settings
                        this._settings.platforms = extend(platform.settings(), this._settings.platforms || {});
                    }
                }], [{
                    key: 'modeConfig',
                    value: function modeConfig(mode, config) {
                        var args = arguments;
                        if (args.length === 2) {
                            // modeConfig('ios', {...})
                            modeConfigs[mode] = extend(modeConfigs[mode] || {}, config);
                        } else {
                            // modeConfig('ios')
                            return modeConfigs[mode];
                        }
                    }
                }]);

                return IonicConfig;
            })();

            _export('IonicConfig', IonicConfig);

            modeConfigs = {};
        }
    };
});
System.register('ionic/config/decorators', ['angular2/angular2', 'ionic/util', '../components/app/app', '../ionic'], function (_export) {
    /**
     * The core Ionic directives.  Automatically available in every IonicView
     * template.
     */
    'use strict';

    var CORE_DIRECTIVES, FORM_DIRECTIVES, NgStyle, Component, Directive, View, forwardRef, util, ionicBootstrap, Menu, MenuToggle, Button, Content, Scroll, Refresher, Slides, Slide, SlideLazy, Tabs, Tab, Card, List, ListHeader, Item, ItemGroup, ItemGroupTitle, Toolbar, ToolbarTitle, ToolbarItem, Icon, Checkbox, Switch, TextInput, TextInputElement, Label, Segment, SegmentButton, SegmentControlValueAccessor, RadioGroup, RadioButton, Nav, NavbarTemplate, Navbar, NavPush, NavPop, NavRouter, IdRef, ShowWhen, HideWhen, IONIC_DIRECTIVES, IonicViewImpl;

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    /**
     * TODO
     */

    _export('IonicView', IonicView);

    /**
     * TODO
     */

    _export('IonicDirective', IonicDirective);

    _export('IonicComponent', IonicComponent);

    _export('App', App);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    /**
     * TODO
     */

    function IonicView(args) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new IonicViewImpl(args));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicDirective(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Directive(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicComponent(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Component(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function appendConfig(cls, config) {
        config.host = config.host || {};
        cls.defaultProperties = config.defaultProperties || {};
        config.properties = config.properties || [];
        for (var prop in cls.defaultProperties) {
            // add the property to the component "properties"
            config.properties.push(prop);
            // set the component "hostProperties", so the instance's
            // property value will be used to set the element's attribute
            config.host['[attr.' + util.pascalCaseToDashCase(prop) + ']'] = prop;
        }
        cls.delegates = config.delegates;
        var componentId = config.classId || config.selector && config.selector.replace('ion-', '');
        config.host['class'] = ((config.host['class'] || '') + ' ' + componentId).trim();
        return config;
    }
    /**
     * TODO
     */

    function App() {
        var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        return function (cls) {
            // get current annotations
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            // create @Component
            args.selector = args.selector || 'ion-app';
            annotations.push(new Component(args));
            // create @View
            // if no template was provided, default so it has a root ion-nav
            if (!args.templateUrl && !args.template) {
                args.template = '<ion-nav></ion-nav>';
            }
            annotations.push(new IonicViewImpl(args));
            // redefine with added annotations
            Reflect.defineMetadata('annotations', annotations, cls);
            ionicBootstrap(cls, args.views, args.config);
            return cls;
        };
    }

    return {
        setters: [function (_angular2Angular2) {
            CORE_DIRECTIVES = _angular2Angular2.CORE_DIRECTIVES;
            FORM_DIRECTIVES = _angular2Angular2.FORM_DIRECTIVES;
            NgStyle = _angular2Angular2.NgStyle;
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_componentsAppApp) {
            ionicBootstrap = _componentsAppApp.ionicBootstrap;
        }, function (_ionic) {
            Menu = _ionic.Menu;
            MenuToggle = _ionic.MenuToggle;
            Button = _ionic.Button;
            Content = _ionic.Content;
            Scroll = _ionic.Scroll;
            Refresher = _ionic.Refresher;
            Slides = _ionic.Slides;
            Slide = _ionic.Slide;
            SlideLazy = _ionic.SlideLazy;
            Tabs = _ionic.Tabs;
            Tab = _ionic.Tab;
            Card = _ionic.Card;
            List = _ionic.List;
            ListHeader = _ionic.ListHeader;
            Item = _ionic.Item;
            ItemGroup = _ionic.ItemGroup;
            ItemGroupTitle = _ionic.ItemGroupTitle;
            Toolbar = _ionic.Toolbar;
            ToolbarTitle = _ionic.ToolbarTitle;
            ToolbarItem = _ionic.ToolbarItem;
            Icon = _ionic.Icon;
            Checkbox = _ionic.Checkbox;
            Switch = _ionic.Switch;
            TextInput = _ionic.TextInput;
            TextInputElement = _ionic.TextInputElement;
            Label = _ionic.Label;
            Segment = _ionic.Segment;
            SegmentButton = _ionic.SegmentButton;
            SegmentControlValueAccessor = _ionic.SegmentControlValueAccessor;
            RadioGroup = _ionic.RadioGroup;
            RadioButton = _ionic.RadioButton;
            Nav = _ionic.Nav;
            NavbarTemplate = _ionic.NavbarTemplate;
            Navbar = _ionic.Navbar;
            NavPush = _ionic.NavPush;
            NavPop = _ionic.NavPop;
            NavRouter = _ionic.NavRouter;
            IdRef = _ionic.IdRef;
            ShowWhen = _ionic.ShowWhen;
            HideWhen = _ionic.HideWhen;
        }],
        execute: function () {
            IONIC_DIRECTIVES = [
            // TODO: Why is forwardRef() required when they're already imported above????
            // Angular
            CORE_DIRECTIVES, FORM_DIRECTIVES, NgStyle,
            // Content
            forwardRef(function () {
                return Menu;
            }), forwardRef(function () {
                return MenuToggle;
            }), forwardRef(function () {
                return Button;
            }), forwardRef(function () {
                return Content;
            }), forwardRef(function () {
                return Scroll;
            }), forwardRef(function () {
                return Refresher;
            }),
            // Lists
            forwardRef(function () {
                return Card;
            }), forwardRef(function () {
                return List;
            }), forwardRef(function () {
                return ListHeader;
            }), forwardRef(function () {
                return Item;
            }), forwardRef(function () {
                return ItemGroup;
            }), forwardRef(function () {
                return ItemGroupTitle;
            }),
            // Slides
            forwardRef(function () {
                return Slides;
            }), forwardRef(function () {
                return Slide;
            }), forwardRef(function () {
                return SlideLazy;
            }),
            // Tabs
            forwardRef(function () {
                return Tabs;
            }), forwardRef(function () {
                return Tab;
            }),
            // Toolbar
            forwardRef(function () {
                return Toolbar;
            }), forwardRef(function () {
                return ToolbarTitle;
            }), forwardRef(function () {
                return ToolbarItem;
            }),
            // Media
            forwardRef(function () {
                return Icon;
            }),
            // Forms
            forwardRef(function () {
                return Segment;
            }), forwardRef(function () {
                return SegmentButton;
            }), forwardRef(function () {
                return SegmentControlValueAccessor;
            }), forwardRef(function () {
                return Checkbox;
            }), forwardRef(function () {
                return RadioGroup;
            }), forwardRef(function () {
                return RadioButton;
            }), forwardRef(function () {
                return Switch;
            }), forwardRef(function () {
                return TextInput;
            }), forwardRef(function () {
                return TextInputElement;
            }), forwardRef(function () {
                return Label;
            }),
            // Nav
            forwardRef(function () {
                return Nav;
            }), forwardRef(function () {
                return NavbarTemplate;
            }), forwardRef(function () {
                return Navbar;
            }), forwardRef(function () {
                return NavPush;
            }), forwardRef(function () {
                return NavPop;
            }), forwardRef(function () {
                return NavRouter;
            }), forwardRef(function () {
                return IdRef;
            }), forwardRef(function () {
                return ShowWhen;
            }), forwardRef(function () {
                return HideWhen;
            })];

            _export('IONIC_DIRECTIVES', IONIC_DIRECTIVES);

            IonicViewImpl = (function (_View) {
                _inherits(IonicViewImpl, _View);

                function IonicViewImpl() {
                    var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, IonicViewImpl);

                    args.directives = (args.directives || []).concat(IONIC_DIRECTIVES);
                    _get(Object.getPrototypeOf(IonicViewImpl.prototype), 'constructor', this).call(this, args);
                }

                return IonicViewImpl;
            })(View);
        }
    };
});
System.register('ionic/config/modes', ['./config'], function (_export) {
    // iOS Mode Settings
    'use strict';

    var IonicConfig;
    return {
        setters: [function (_config) {
            IonicConfig = _config.IonicConfig;
        }],
        execute: function () {
            IonicConfig.modeConfig('ios', {
                actionSheetEnter: 'action-sheet-slide-in',
                actionSheetLeave: 'action-sheet-slide-out',
                actionSheetCancelIcon: '',
                actionSheetDestructiveIcon: '',
                backButtonText: 'Back',
                backButtonIcon: 'ion-ios-arrow-back',
                iconMode: 'ios',
                tabBarPlacement: 'bottom',
                viewTransition: 'ios'
            });
            // Material Design Mode Settings
            IonicConfig.modeConfig('md', {
                actionSheetEnter: 'action-sheet-md-slide-in',
                actionSheetLeave: 'action-sheet-md-slide-out',
                actionSheetCancelIcon: 'ion-md-close',
                actionSheetDestructiveIcon: 'ion-md-trash',
                backButtonText: '',
                backButtonIcon: 'ion-md-arrow-back',
                iconMode: 'md',
                tabBarPlacement: 'top',
                viewTransition: 'md',
                type: 'overlay',
                mdRipple: true
            });
        }
    };
});
System.register('ionic/gestures/drag-gesture', ['ionic/gestures/gesture', 'ionic/util'], function (_export) {
    'use strict';

    var Gesture, util, DragGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            DragGesture = (function (_Gesture) {
                _inherits(DragGesture, _Gesture);

                function DragGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, DragGesture);

                    util.defaults(opts, {});
                    _get(Object.getPrototypeOf(DragGesture.prototype), 'constructor', this).call(this, element, opts);
                }

                _createClass(DragGesture, [{
                    key: 'listen',
                    value: function listen() {
                        var _this = this;

                        _get(Object.getPrototypeOf(DragGesture.prototype), 'listen', this).call(this);
                        this.on('panstart', function (ev) {
                            if (_this.onDragStart(ev) !== false) {
                                _this.dragging = true;
                            }
                            // ev.stopPropagation();
                        });
                        this.on('panmove', function (ev) {
                            if (!_this.dragging) return;
                            if (_this.onDrag(ev) === false) {
                                _this.dragging = false;
                            }
                            // ev.stopPropagation()
                        });
                        this.on('panend', function (ev) {
                            if (!_this.dragging) return;
                            _this.onDragEnd(ev);
                            _this.dragging = false;
                            // ev.stopPropagation()
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag() {}
                }, {
                    key: 'onDragStart',
                    value: function onDragStart() {}
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd() {}
                }]);

                return DragGesture;
            })(Gesture);

            _export('DragGesture', DragGesture);
        }
    };
});
System.register('ionic/gestures/gesture', ['ionic/util', 'ionic/gestures/hammer'], function (_export) {
    /**
     * A gesture recognizer class.
     *
     * TODO(mlynch): Re-enable the DOM event simulation that was causing issues (or verify hammer does this already, it might);
     */
    'use strict';

    var util, Hammer, Gesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicGesturesHammer) {
            Hammer = _ionicGesturesHammer.Hammer;
        }],
        execute: function () {
            Gesture = (function () {
                function Gesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Gesture);

                    util.defaults(opts, {
                        domEvents: true
                    });
                    this.element = element;
                    // Map 'x' or 'y' string to hammerjs opts
                    this.direction = opts.direction || 'x';
                    opts.direction = this.direction === 'x' ? Hammer.DIRECTION_HORIZONTAL : Hammer.DIRECTION_VERTICAL;
                    this._options = opts;
                    this._callbacks = {};
                }

                _createClass(Gesture, [{
                    key: 'options',
                    value: function options() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        util.extend(this._options, opts);
                    }
                }, {
                    key: 'on',
                    value: function on(type, cb) {
                        if (type == 'pinch' || type == 'rotate') {
                            this.hammertime.get('pinch').set({ enable: true });
                        }
                        this.hammertime.on(type, cb);
                        (this._callbacks[type] || (this._callbacks[type] = [])).push(cb);
                        //this.element.addEventListener(type, cb);
                    }
                }, {
                    key: 'listen',
                    value: function listen() {
                        this.hammertime = Hammer(this.element, this._options);
                    }
                }, {
                    key: 'unlisten',
                    value: function unlisten() {
                        if (this.hammertime) {
                            for (var type in this._callbacks) {
                                for (var i = 0; i < this._callbacks[type].length; i++) {
                                    //this.element.removeEventListener(type, this._callbacks[type][i]);
                                    this.hammertime.off(type, this._callbacks[type]);
                                }
                            }
                            this.hammertime.destroy();
                            this.hammertime = null;
                            this._callbacks = {};
                        }
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.unlisten();
                    }
                }]);

                return Gesture;
            })();

            _export('Gesture', Gesture);
        }
    };
});
System.register('ionic/gestures/hammer', [], function (_export) {
    /*! Hammer.JS - v2.0.4 - 2014-09-28
     * http://hammerjs.github.io/
     *
     * Copyright (c) 2014 Jorik Tangelder;
     * Licensed under the MIT license */
    //(function(window, document, exportName, undefined) {
    //'use strict';
    'use strict';

    var VENDOR_PREFIXES, TEST_ELEMENT, TYPE_FUNCTION, round, abs, now, _uniqueId, MOBILE_REGEX, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS, SUPPORT_ONLY_TOUCH, INPUT_TYPE_TOUCH, INPUT_TYPE_PEN, INPUT_TYPE_MOUSE, INPUT_TYPE_KINECT, COMPUTE_INTERVAL, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, PROPS_XY, PROPS_CLIENT_XY, MOUSE_INPUT_MAP, MOUSE_ELEMENT_EVENTS, MOUSE_WINDOW_EVENTS, POINTER_INPUT_MAP, IE10_POINTER_TYPE_ENUM, POINTER_ELEMENT_EVENTS, POINTER_WINDOW_EVENTS, SINGLE_TOUCH_INPUT_MAP, SINGLE_TOUCH_TARGET_EVENTS, SINGLE_TOUCH_WINDOW_EVENTS, TOUCH_INPUT_MAP, TOUCH_TARGET_EVENTS, PREFIXED_TOUCH_ACTION, NATIVE_TOUCH_ACTION, TOUCH_ACTION_COMPUTE, TOUCH_ACTION_AUTO, TOUCH_ACTION_MANIPULATION, TOUCH_ACTION_NONE, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, STOP, FORCED_STOP;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge]
     * @returns {Object} dest
     */
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }
    /**
     * get a unique id
     * @returns {number} uniqueId
     */

    function uniqueId() {
        return _uniqueId++;
    }
    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };
        this.init();
    }

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [all, changed];
    }

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }
        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }
    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // pan-x and pan-y can be combined
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }
        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }
    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }
    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }
    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
     * @const {string}
     */

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function (value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }
    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    return {
        setters: [],
        execute: function () {
            VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
            TEST_ELEMENT = document.createElement('div');
            TYPE_FUNCTION = 'function';
            round = Math.round;
            abs = Math.abs;
            now = Date.now;
            _uniqueId = 1;
            MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
            SUPPORT_TOUCH = 'ontouchstart' in window;
            SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
            INPUT_TYPE_TOUCH = 'touch';
            INPUT_TYPE_PEN = 'pen';
            INPUT_TYPE_MOUSE = 'mouse';
            INPUT_TYPE_KINECT = 'kinect';
            COMPUTE_INTERVAL = 25;
            INPUT_START = 1;
            INPUT_MOVE = 2;
            INPUT_END = 4;
            INPUT_CANCEL = 8;
            DIRECTION_NONE = 1;
            DIRECTION_LEFT = 2;
            DIRECTION_RIGHT = 4;
            DIRECTION_UP = 8;
            DIRECTION_DOWN = 16;
            DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
            PROPS_XY = ['x', 'y'];
            PROPS_CLIENT_XY = ['clientX', 'clientY'];
            Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function handler() {},
                /**
                 * bind the events
                 */
                init: function init() {
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                /**
                 * unbind the events
                 */
                destroy: function destroy() {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };
            MOUSE_ELEMENT_EVENTS = 'mousedown';
            MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
            inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];
                    // on start we want to have the left mouse button down
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }
                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }
                    // mouse must be down, and mouse events are allowed (see the TouchMouse input)
                    if (!this.pressed || !this.allow) {
                        return;
                    }
                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }
                    this.callback(this.manager, eventType, {
                        pointers: [ev],
                        changedPointers: [ev],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });
            POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };

            // in IE10 the pointer types is defined as an enum
            IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
            };
            POINTER_ELEMENT_EVENTS = 'pointerdown';
            POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

            // IE10 has prefixed support, and case-sensitive
            if (window.MSPointerEvent) {
                POINTER_ELEMENT_EVENTS = 'MSPointerDown';
                POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
            }inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                    var store = this.store;
                    var removePointer = false;
                    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                    var isTouch = pointerType == INPUT_TYPE_TOUCH;
                    // get index of the event in the store
                    var storeIndex = inArray(store, ev.pointerId, 'pointerId');
                    // start and mouse must be down
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store.push(ev);
                            storeIndex = store.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }
                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (storeIndex < 0) {
                        return;
                    }
                    // update the event in the store
                    store[storeIndex] = ev;
                    this.callback(this.manager, eventType, {
                        pointers: store,
                        changedPointers: [ev],
                        pointerType: pointerType,
                        srcEvent: ev
                    });
                    if (removePointer) {
                        // remove from the store
                        store.splice(storeIndex, 1);
                    }
                }
            });
            SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
            SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                    // should we handle the touch events?
                    if (type === INPUT_START) {
                        this.started = true;
                    }
                    if (!this.started) {
                        return;
                    }
                    var touches = normalizeSingleTouches.call(this, ev, type);
                    // when done, reset the started state
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                    // when we're in a touch event, so  block all upcoming mouse events
                    // most mobile browser also emit mouseevents, right after touchstart
                    if (isTouch) {
                        this.mouse.allow = false;
                    } else if (isMouse && !this.mouse.allow) {
                        return;
                    }
                    // reset the allowMouse when we're done
                    if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                        this.mouse.allow = true;
                    }
                    this.callback(manager, inputEvent, inputData);
                },
                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });
            PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

            // magical touchAction value
            TOUCH_ACTION_COMPUTE = 'compute';
            TOUCH_ACTION_AUTO = 'auto';
            TOUCH_ACTION_MANIPULATION = 'manipulation';
            // not implemented
            TOUCH_ACTION_NONE = 'none';
            TOUCH_ACTION_PAN_X = 'pan-x';
            TOUCH_ACTION_PAN_Y = 'pan-y';
            TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function set(value) {
                    // find out the touch-action by the event handlers
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }
                    if (NATIVE_TOUCH_ACTION) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },
                /**
                 * just re-set the touchAction value
                 */
                update: function update() {
                    this.set(this.manager.options.touchAction);
                },
                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function compute() {
                    var actions = [];
                    each(this.manager.recognizers, function (recognizer) {
                        if (boolOrFn(recognizer.options.enable, [recognizer])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(' '));
                },
                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function preventDefaults(input) {
                    // not needed with native support for the touchAction property
                    if (NATIVE_TOUCH_ACTION) {
                        return;
                    }
                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;
                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }
                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE);
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                        return this.preventSrc(srcEvent);
                    }
                },
                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function preventSrc(srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            };STATE_POSSIBLE = 1;
            STATE_BEGAN = 2;
            STATE_CHANGED = 4;
            STATE_ENDED = 8;
            STATE_RECOGNIZED = STATE_ENDED;
            STATE_CANCELLED = 16;
            STATE_FAILED = 32;
            Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},
                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },
                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function recognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                        return this;
                    }
                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },
                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },
                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function requireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                        return this;
                    }
                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },
                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function dropRequireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },
                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function hasRequireFailures() {
                    return this.requireFail.length > 0;
                },
                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function canRecognizeWith(otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },
                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function emit(input) {
                    var self = this;
                    var state = this.state;
                    function emit(withState) {
                        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
                    }
                    // 'panstart' and 'panmove'
                    if (state < STATE_ENDED) {
                        emit(true);
                    }
                    emit(); // simple 'eventName' events
                    // panend and pancancel
                    if (state >= STATE_ENDED) {
                        emit(true);
                    }
                },
                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function tryEmit(input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    // it's failing anyway
                    this.state = STATE_FAILED;
                },
                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function canEmit() {
                    var i = 0;
                    while (i < this.requireFail.length) {
                        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                },
                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var inputDataClone = extend({}, inputData);
                    // is is enabled and allow recognizing?
                    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }
                    // reset when we've reached the end
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }
                    this.state = this.process(inputDataClone);
                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },
                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function process(inputData) {},
                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function getTouchAction() {},
                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function reset() {}
            };inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                    /**
                     * @type {Number}
                     * @default 1
                     */
                    pointers: 1
                },
                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function attrTest(input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function process(input) {
                    var state = this.state;
                    var eventType = input.eventType;
                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);
                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                    event: 'pan',
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },
                getTouchAction: function getTouchAction() {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },
                directionTest: function directionTest(input) {
                    var options = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;
                    // lock to axis?
                    if (!(direction & options.direction)) {
                        if (options.direction & DIRECTION_HORIZONTAL) {
                            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options.threshold && direction & options.direction;
                },
                attrTest: function attrTest(input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function emit(input) {
                    this.pX = input.deltaX;
                    this.pY = input.deltaY;
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this._super.emit.call(this, input);
                }
            });inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'pinch',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function emit(input) {
                    this._super.emit.call(this, input);
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? 'in' : 'out';
                        this.manager.emit(this.options.event + inOut, input);
                    }
                }
            });inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                    event: 'press',
                    pointers: 1,
                    time: 500,
                    threshold: 5 // a minimal movement is ok, but keep it low
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_AUTO];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTime = input.deltaTime > options.time;
                    this._input = input;
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit(input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }
                    if (input && input.eventType & INPUT_END) {
                        this.manager.emit(this.options.event + 'up', input);
                    } else {
                        this._input.timeStamp = now();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                    event: 'rotate',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                    event: 'swipe',
                    threshold: 10,
                    velocity: 0.65,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },
                getTouchAction: function getTouchAction() {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function attrTest(input) {
                    var direction = this.options.direction;
                    var velocity;
                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.velocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.velocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.velocityY;
                    }
                    return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function emit(input) {
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this.manager.emit(this.options.event, input);
                }
            });inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'tap',
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 2,
                    posThreshold: 10 // a multi-tap can be a bit off the initial position
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_MANIPULATION];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTouchTime = input.deltaTime < options.time;
                    this.reset();
                    if (input.eventType & INPUT_START && this.count === 0) {
                        return this.failTimeout();
                    }
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }
                        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;
                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }
                        this._input = input;
                        // if tap count matches we have recognized it,
                        // else it has began recognizing...
                        var tapCount = this.count % options.taps;
                        if (tapCount === 0) {
                            // no failing requirements, immediately trigger the tap event
                            // or wait as long as the multitap interval to trigger
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },
                failTimeout: function failTimeout() {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit() {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });Hammer.VERSION = '2.0.4';
            /**
             * default settings
             * @namespace
             */
            Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,
                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,
                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,
                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,
                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,
                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],
                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                    /**
                     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userSelect: 'none',
                    /**
                     * Disable the Windows Phone grippers when pressing an element.
                     * @type {String}
                     * @default 'none'
                     */
                    touchSelect: 'none',
                    /**
                     * Disables the default callout shown when you touch and hold a touch target.
                     * On iOS, when you touch and hold a touch target such as a link, Safari displays
                     * a callout containing information about the link. This property allows you to disable that callout.
                     * @type {String}
                     * @default 'none'
                     */
                    touchCallout: 'none',
                    /**
                     * Specifies whether zooming is enabled. Used by IE10>
                     * @type {String}
                     * @default 'none'
                     */
                    contentZooming: 'none',
                    /**
                     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userDrag: 'none',
                    /**
                     * Overrides the highlight color shown when the user taps a link or a JavaScript
                     * clickable element in iOS. This property obeys the alpha value, if specified.
                     * @type {String}
                     * @default 'rgba(0,0,0,0)'
                     */
                    tapHighlightColor: 'rgba(0,0,0,0)'
                }
            };
            STOP = 1;
            FORCED_STOP = 2;
            Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // Options that need a little more setup
                    if (options.touchAction) {
                        this.touchAction.update();
                    }
                    if (options.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = options.inputTarget;
                        this.input.init();
                    }
                    return this;
                },
                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function stop(force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },
                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }
                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(inputData);
                    var recognizer;
                    var recognizers = this.recognizers;
                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var curRecognizer = session.curRecognizer;
                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                        curRecognizer = session.curRecognizer = null;
                    }
                    var i = 0;
                    while (i < recognizers.length) {
                        recognizer = recognizers[i];
                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }
                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i++;
                    }
                },
                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function get(recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }
                    var recognizers = this.recognizers;
                    for (var i = 0; i < recognizers.length; i++) {
                        if (recognizers[i].options.event == recognizer) {
                            return recognizers[i];
                        }
                    }
                    return null;
                },
                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function add(recognizer) {
                    if (invokeArrayArg(recognizer, 'add', this)) {
                        return this;
                    }
                    // remove existing
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }
                    this.recognizers.push(recognizer);
                    recognizer.manager = this;
                    this.touchAction.update();
                    return recognizer;
                },
                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function remove(recognizer) {
                    if (invokeArrayArg(recognizer, 'remove', this)) {
                        return this;
                    }
                    var recognizers = this.recognizers;
                    recognizer = this.get(recognizer);
                    recognizers.splice(inArray(recognizers, recognizer), 1);
                    this.touchAction.update();
                    return this;
                },
                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function on(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        handlers[event] = handlers[event] || [];
                        handlers[event].push(handler);
                    });
                    return this;
                },
                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function off(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        if (!handler) {
                            delete handlers[event];
                        } else {
                            handlers[event].splice(inArray(handlers[event], handler), 1);
                        }
                    });
                    return this;
                },
                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function emit(event, data) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) {
                        triggerDomEvent(event, data);
                    }
                    // no handlers, so skip it all
                    var handlers = this.handlers[event] && this.handlers[event].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }
                    data.type = event;
                    data.preventDefault = function () {
                        data.srcEvent.preventDefault();
                    };
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                },
                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function destroy() {
                    this.element && toggleCssProps(this, false);
                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };extend(Hammer, {
                INPUT_START: INPUT_START,
                INPUT_MOVE: INPUT_MOVE,
                INPUT_END: INPUT_END,
                INPUT_CANCEL: INPUT_CANCEL,
                STATE_POSSIBLE: STATE_POSSIBLE,
                STATE_BEGAN: STATE_BEGAN,
                STATE_CHANGED: STATE_CHANGED,
                STATE_ENDED: STATE_ENDED,
                STATE_RECOGNIZED: STATE_RECOGNIZED,
                STATE_CANCELLED: STATE_CANCELLED,
                STATE_FAILED: STATE_FAILED,
                DIRECTION_NONE: DIRECTION_NONE,
                DIRECTION_LEFT: DIRECTION_LEFT,
                DIRECTION_RIGHT: DIRECTION_RIGHT,
                DIRECTION_UP: DIRECTION_UP,
                DIRECTION_DOWN: DIRECTION_DOWN,
                DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL: DIRECTION_VERTICAL,
                DIRECTION_ALL: DIRECTION_ALL,
                Manager: Manager,
                Input: Input,
                TouchAction: TouchAction,
                TouchInput: TouchInput,
                MouseInput: MouseInput,
                PointerEventInput: PointerEventInput,
                TouchMouseInput: TouchMouseInput,
                SingleTouchInput: SingleTouchInput,
                Recognizer: Recognizer,
                AttrRecognizer: AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each: each,
                merge: merge,
                extend: extend,
                inherit: inherit,
                bindFn: bindFn,
                prefixed: prefixed
            });
            /*
            if (typeof define == TYPE_FUNCTION && define.amd) {
                define(function() {
                    return Hammer;
                });
            } else if (typeof module != 'undefined' && module.exports) {
                module.exports = Hammer;
            } else {
                window[exportName] = Hammer;
            }
            */

            _export('Hammer', Hammer);

            //})(window, document, 'Hammer');
        }
    };
});
System.register('ionic/gestures/slide-edge-gesture', ['ionic/gestures/slide-gesture', '../util/util', '../util/dom'], function (_export) {
    'use strict';

    var SlideGesture, defaults, windowDimensions, SlideEdgeGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }, function (_utilUtil) {
            defaults = _utilUtil.defaults;
        }, function (_utilDom) {
            windowDimensions = _utilDom.windowDimensions;
        }],
        execute: function () {
            SlideEdgeGesture = (function (_SlideGesture) {
                _inherits(SlideEdgeGesture, _SlideGesture);

                function SlideEdgeGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideEdgeGesture);

                    defaults(opts, {
                        edge: 'left',
                        threshold: 50
                    });
                    _get(Object.getPrototypeOf(SlideEdgeGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                }

                _createClass(SlideEdgeGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        var _this = this;

                        this._d = this.getContainerDimensions();
                        return this.edges.every(function (edge) {
                            return _this._checkEdge(edge, ev.center);
                        });
                    }
                }, {
                    key: 'getContainerDimensions',
                    value: function getContainerDimensions() {
                        return {
                            left: 0,
                            top: 0,
                            width: windowDimensions().width,
                            height: windowDimensions().height
                        };
                    }
                }, {
                    key: '_checkEdge',
                    value: function _checkEdge(edge, pos) {
                        switch (edge) {
                            case 'left':
                                return pos.x <= this._d.left + this.threshold;
                            case 'right':
                                return pos.x >= this._d.width - this.threshold;
                            case 'top':
                                return pos.y <= this._d.top + this.threshold;
                            case 'bottom':
                                return pos.y >= this._d.height - this.threshold;
                        }
                    }
                }]);

                return SlideEdgeGesture;
            })(SlideGesture);

            _export('SlideEdgeGesture', SlideEdgeGesture);
        }
    };
});
System.register('ionic/gestures/slide-gesture', ['ionic/gestures/drag-gesture', 'ionic/util'], function (_export) {
    'use strict';

    var DragGesture, util, SlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesDragGesture) {
            DragGesture = _ionicGesturesDragGesture.DragGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            SlideGesture = (function (_DragGesture) {
                _inherits(SlideGesture, _DragGesture);

                function SlideGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideGesture);

                    _get(Object.getPrototypeOf(SlideGesture.prototype), 'constructor', this).call(this, element, opts);
                    this.element = element;
                }

                /*
                 * Get the min and max for the slide. pageX/pageY.
                 * Only called on dragstart.
                 */

                _createClass(SlideGesture, [{
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries(slide, ev) {
                        return {
                            min: 0,
                            max: this.element.offsetWidth
                        };
                    }

                    /*
                     * Get the element's pos when the drag starts.
                     * For example, an open side menu starts at 100% and a closed
                     * sidemenu starts at 0%.
                     */
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return 0;
                    }
                }, {
                    key: 'canStart',
                    value: function canStart() {
                        return true;
                    }
                }, {
                    key: 'onDragStart',
                    value: function onDragStart(ev) {
                        var _this = this;

                        if (!this.canStart(ev)) return false;
                        this.slide = {};
                        var promise = this.onSlideBeforeStart(this.slide, ev) || Promise.resolve();
                        promise.then(function () {
                            var _getSlideBoundaries = _this.getSlideBoundaries(_this.slide, ev);

                            var min = _getSlideBoundaries.min;
                            var max = _getSlideBoundaries.max;

                            _this.slide.min = min;
                            _this.slide.max = max;
                            _this.slide.elementStartPos = _this.getElementStartPos(_this.slide, ev);
                            _this.slide.pointerStartPos = ev.center[_this.direction];
                            _this.slide.started = true;
                            _this.onSlideStart(_this.slide, ev);
                        })['catch'](function () {
                            _this.slide = null;
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.slide.pos = ev.center[this.direction];
                        this.slide.distance = util.clamp(this.slide.min, this.slide.pos - this.slide.pointerStartPos + this.slide.elementStartPos, this.slide.max);
                        this.slide.delta = this.slide.pos - this.slide.pointerStartPos;
                        this.onSlide(this.slide, ev);
                    }
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.onSlideEnd(this.slide, ev);
                        this.slide = null;
                    }
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart() {}
                }, {
                    key: 'onSlideStart',
                    value: function onSlideStart() {}
                }, {
                    key: 'onSlide',
                    value: function onSlide() {}
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd() {}
                }]);

                return SlideGesture;
            })(DragGesture);

            _export('SlideGesture', SlideGesture);
        }
    };
});
System.register('ionic/net/http', ['ionic/util'], function (_export) {
    //TODO(mlynch): surely, there must be another way, sir?
    'use strict';

    var util, Http;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            window._jsonpcallbacks = {
                counter: 0
            };
            /**
             * The Http class makes it easy to send GET/POST/PUT/DELETE/PATCH requests
             * and send/receive JSON (or anything else) through a simple API.
             *
             * Http uses the `fetch()` API underneath, or a polyfill if it's not natively supported.
             */

            Http = (function () {
                function Http() {
                    _classCallCheck(this, Http);
                }

                _createClass(Http, null, [{
                    key: 'fetch',

                    /**
                     * The raw fetch() operation.
                     *
                     * Generally, you want to use one of get()/post()/put()/delete() but
                     * this is useful if you want to do something crazy.
                     *
                     * @param url the URL to pass to fetch
                     * @param options the options to configure the fetch
                     * @return es6 promise from the fetch.
                     */
                    value: function fetch(url, options) {
                        return window.fetch(url, options).then(function (response) {
                            // status "0" to handle local files fetching (e.g. Cordova/Phonegap etc.)
                            if (response.status === 200 || response.status === 0) {
                                // We have a good response, let's check the response headers and return
                                // deserialized JSON or return the text from the response.
                                if (response.headers.get('Content-Type') === 'application/json') {
                                    return response.json();
                                }
                                return response.text();
                            } else {
                                return Promise.reject(response, new Error(response.statusText));
                            }
                        })['catch'](function (err) {
                            return Promise.reject(err);
                        });
                    }
                }, {
                    key: 'jsonp',
                    value: function jsonp(url, callbackId, options) {
                        return new Promise(function (resolve, reject) {
                            var script = document.createElement('script');
                            script.src = url;
                            script.async = true;
                            script.type = 'text/javascript';
                            var callback = function callback(event) {
                                script.removeEventListener('load', callback);
                                script.removeEventListener('error', callback);
                                document.body.removeChild(script);
                                var text = undefined,
                                    status = undefined;
                                if (event) {
                                    if (event.type === "load" && !window._jsonpcallbacks[callbackId].called) {
                                        event = { type: "error" };
                                    }
                                    text = event.type;
                                    status = event.type === "error" ? 404 : 200;
                                    resolve(window._jsonpcallbacks[callbackId].data, status, text);
                                } else {
                                    reject();
                                }
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                            };
                            script.addEventListener('load', callback);
                            script.addEventListener('error', callback);
                            document.body.appendChild(script);
                            return callback;
                        });
                    }
                }, {
                    key: '_method',
                    value: function _method(method, url, data, options, sendsJson) {
                        options = util.defaults(options, {
                            method: method,
                            headers: {
                                'Accept': 'application/json,text/plain,*/*'
                            }
                        });
                        if (options.body) {
                            options.body = typeof data === 'string' ? data : JSON.stringify(data);
                        }
                        if (sendsJson) {
                            options.headers['Content-Type'] = 'application/json';
                        }
                        if (options.method == 'jsonp') {
                            var callbackId;

                            var _ret = (function () {
                                // Adopted from Angular 1
                                var callbacks = window._jsonpcallbacks;
                                callbackId = '_' + (callbacks.counter++).toString(36);

                                callbacks[callbackId] = function (data) {
                                    callbacks[callbackId].data = data;
                                    callbacks[callbackId].called = true;
                                };
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                                url = url.replace('JSON_CALLBACK', '_jsonpcallbacks.' + callbackId);
                                return {
                                    v: Http.jsonp(url, callbackId, options)
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        } else {
                            return Http.fetch(url, options);
                        }
                    }

                    /**
                     * Send a GET request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'get',
                    value: function get(url) {
                        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        return Http._method('get', url, {}, options);
                    }

                    /**
                     * Send a POST request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'post',
                    value: function post(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('post', url, data, options, true);
                    }

                    /**
                     * Send a PUT request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PUT to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'put',
                    value: function put(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('put', url, data, options, true);
                    }

                    /**
                     * Send a DELETE request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to DELETE to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'delete',
                    value: function _delete(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('delete', url, data, options, true);
                    }

                    /**
                     * Send a PATH request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PATH to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'patch',
                    value: function patch(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('patch', url, data, options, true);
                    }
                }]);

                return Http;
            })();

            _export('Http', Http);
        }
    };
});
System.register('ionic/platform/platform', ['../util/util', '../util/dom'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var util, dom, IonicPlatform, PlatformNode, platformRegistry, platformDefault;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertSuperset(platformNode) {
        var supersetPlaformName = platformNode.superset();
        if (supersetPlaformName) {
            // add a platform in between two exist platforms
            // so we can build the correct hierarchy of active platforms
            var supersetPlatform = new PlatformNode(supersetPlaformName);
            supersetPlatform.parent(platformNode.parent());
            supersetPlatform.child(platformNode);
            if (supersetPlatform.parent()) {
                supersetPlatform.parent().child(supersetPlatform);
            }
            platformNode.parent(supersetPlatform);
        }
    }
    return {
        setters: [function (_utilUtil) {
            util = _utilUtil;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            IonicPlatform = (function () {
                function IonicPlatform() {
                    var _this = this;

                    _classCallCheck(this, IonicPlatform);

                    this._settings = {};
                    this._platforms = [];
                    this._versions = {};
                    this._onResizes = [];
                    this._readyPromise = new Promise(function (res) {
                        _this._readyResolve = res;
                    });
                }

                // Methods
                // **********************************************
                /**
                 * TODO
                 * @param {TODO} platformName  TODO
                 * @returns {TODO} TODO
                 */

                _createClass(IonicPlatform, [{
                    key: 'is',
                    value: function is(platformName) {
                        return this._platforms.indexOf(platformName) > -1;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'platforms',
                    value: function platforms() {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        return this._platforms;
                    }

                    /**
                     * TODO
                     * @param {TODO} platformName  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'versions',
                    value: function versions(platformName) {
                        if (arguments.length) {
                            // get a specific platform's version
                            return this._versions[platformName];
                        }
                        // get all the platforms that have a valid parsed version
                        return this._versions;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'ready',
                    value: function ready() {
                        return this._readyPromise;
                    }

                    /**
                     * @private
                     * TODO
                     * @param {TODO} config  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'prepareReady',
                    value: function prepareReady(config) {
                        var self = this;
                        function resolve() {
                            self._readyResolve(config);
                        }
                        if (this._engineReady) {
                            // the engine provide a ready promise, use this instead
                            this._engineReady(resolve);
                        } else {
                            // there is no custom ready method from the engine
                            // use the default dom ready
                            dom.ready(resolve);
                        }
                    }

                    // Methods meant to be overridden by the engine
                    // **********************************************
                    // Provided NOOP methods so they do not error when
                    // called by engines (the browser) doesn't provide them
                }, {
                    key: 'on',
                    value: function on() {}
                }, {
                    key: 'onHardwareBackButton',
                    value: function onHardwareBackButton() {}
                }, {
                    key: 'registerBackButtonAction',
                    value: function registerBackButtonAction() {}
                }, {
                    key: 'exitApp',
                    value: function exitApp() {}
                }, {
                    key: 'fullScreen',
                    value: function fullScreen() {}
                }, {
                    key: 'showStatusBar',
                    value: function showStatusBar() {}

                    // Getter/Setter Methods
                    // **********************************************
                }, {
                    key: 'url',
                    value: function url(val) {
                        if (arguments.length) {
                            this._url = val;
                            this._qs = util.getQuerystring(val);
                        }
                        return this._url;
                    }
                }, {
                    key: 'query',
                    value: function query(key) {
                        return (this._qs || {})[key];
                    }
                }, {
                    key: 'userAgent',
                    value: function userAgent(val) {
                        if (arguments.length) {
                            this._ua = val;
                        }
                        return this._ua;
                    }
                }, {
                    key: 'navigatorPlatform',
                    value: function navigatorPlatform(val) {
                        if (arguments.length) {
                            this._bPlt = val;
                        }
                        return this._bPlt || '';
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        return dom.windowDimensions().width;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        return dom.windowDimensions().height;
                    }
                }, {
                    key: 'isPortrait',
                    value: function isPortrait() {
                        return this.width() < this.height();
                    }
                }, {
                    key: 'isLandscape',
                    value: function isLandscape() {
                        return !this.isPortrait();
                    }
                }, {
                    key: 'isKeyboardOpen',
                    value: function isKeyboardOpen() {
                        return dom.hasFocusedTextInput();
                    }
                }, {
                    key: 'onKeyboardClose',
                    value: function onKeyboardClose(callback) {
                        var self = this;
                        var promise = null;
                        if (!callback) {
                            // a callback wasn't provided, so let's return a promise instead
                            promise = new Promise(function (resolve) {
                                callback = resolve;
                            });
                        }
                        function checkKeyboard() {
                            if (!self.isKeyboardOpen()) {
                                callback();
                            } else {
                                setTimeout(checkKeyboard, 500);
                            }
                        }
                        setTimeout(checkKeyboard, 100);
                        return promise;
                    }
                }, {
                    key: 'windowResize',
                    value: function windowResize() {
                        var self = this;
                        clearTimeout(self._resizeTimer);
                        self._resizeTimer = setTimeout(function () {
                            dom.flushDimensionCache();
                            for (var i = 0; i < self._onResizes.length; i++) {
                                try {
                                    self._onResizes[i]();
                                } catch (e) {
                                    console.error(e);
                                }
                            }
                        }, 500);
                    }
                }, {
                    key: 'onResize',
                    value: function onResize(cb) {
                        // TODO: Make more good
                        this._onResizes.push(cb);
                    }

                    // Platform Registry
                    // **********************************************
                    /**
                     * TODO
                     * @param {TODO} platformConfig  TODO
                     */
                }, {
                    key: 'testQuery',

                    /**
                     * TODO
                     * @param {TODO} queryValue  TODO
                     * @returns {boolean} TODO
                     */
                    value: function testQuery(queryValue) {
                        var val = this.query('ionicplatform');
                        if (val) {
                            var valueSplit = val.toLowerCase().split(';');
                            for (var i = 0; i < valueSplit.length; i++) {
                                if (valueSplit[i] == queryValue) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }

                    /**
                     * TODO
                     * @param {TODO} userAgentExpression  TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'testUserAgent',
                    value: function testUserAgent(userAgentExpression) {
                        var rgx = new RegExp(userAgentExpression, 'i');
                        return rgx.test(this._ua);
                    }

                    /**
                     * TODO
                     * @param {TODO} userAgentExpression  TODO
                     * @returns {Object} TODO
                     */
                }, {
                    key: 'matchUserAgentVersion',
                    value: function matchUserAgentVersion(userAgentExpression) {
                        var val = this._ua.match(userAgentExpression);
                        if (val) {
                            return {
                                major: val[1],
                                minor: val[2]
                            };
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} queryValue  TODO
                     * @param {TODO} userAgentExpression  TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'isPlatform',
                    value: function isPlatform(queryValue, userAgentExpression) {
                        if (!userAgentExpression) {
                            userAgentExpression = queryValue;
                        }
                        return this.testQuery(queryValue) || this.testUserAgent(userAgentExpression);
                    }

                    /**
                     * TODO
                     * @param {TODO} config  TODO
                     */
                }, {
                    key: 'load',
                    value: function load(config) {
                        var rootPlatformNode = null;
                        var engineNode = null;
                        var self = this;
                        this.platformOverride = config.setting('platform');
                        // figure out the most specific platform and active engine
                        var tmpPlatform = null;
                        for (var platformName in platformRegistry) {
                            tmpPlatform = this.matchPlatform(platformName);
                            if (tmpPlatform) {
                                // we found a platform match!
                                // check if its more specific than the one we already have
                                if (tmpPlatform.isEngine) {
                                    // because it matched then this should be the active engine
                                    // you cannot have more than one active engine
                                    engineNode = tmpPlatform;
                                } else if (!rootPlatformNode || tmpPlatform.depth > rootPlatformNode.depth) {
                                    // only find the root node for platforms that are not engines
                                    // set this node as the root since we either don't already
                                    // have one, or this one is more specific that the current one
                                    rootPlatformNode = tmpPlatform;
                                }
                            }
                        }
                        if (!rootPlatformNode) {
                            rootPlatformNode = new PlatformNode(platformDefault);
                        }
                        // build a Platform instance filled with the
                        // hierarchy of active platforms and settings
                        if (rootPlatformNode) {
                            // check if we found an engine node (cordova/node-webkit/etc)
                            if (engineNode) {
                                // add the engine to the first in the platform hierarchy
                                // the original rootPlatformNode now becomes a child
                                // of the engineNode, which is not the new root
                                engineNode.child(rootPlatformNode);
                                rootPlatformNode.parent(engineNode);
                                rootPlatformNode = engineNode;
                                // add any events which the engine would provide
                                // for example, Cordova provides its own ready event
                                var engineMethods = engineNode.methods();
                                engineMethods._engineReady = engineMethods.ready;
                                delete engineMethods.ready;
                                util.extend(this, engineMethods);
                            }
                            var platformNode = rootPlatformNode;
                            while (platformNode) {
                                insertSuperset(platformNode);
                                platformNode = platformNode.child();
                            }
                            // make sure the root noot is actually the root
                            // incase a node was inserted before the root
                            platformNode = rootPlatformNode.parent();
                            while (platformNode) {
                                rootPlatformNode = platformNode;
                                platformNode = platformNode.parent();
                            }
                            platformNode = rootPlatformNode;
                            while (platformNode) {
                                // set the array of active platforms with
                                // the last one in the array the most important
                                this._platforms.push(platformNode.name());
                                // copy default platform settings into this platform settings obj
                                this._settings[platformNode.name()] = util.extend({}, platformNode.settings());
                                // get the platforms version if a version parser was provided
                                this._versions[platformNode.name()] = platformNode.version(this);
                                // go to the next platform child
                                platformNode = platformNode.child();
                            }
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} platformName  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'matchPlatform',
                    value: function matchPlatform(platformName) {
                        // build a PlatformNode and assign config data to it
                        // use it's getRoot method to build up its hierarchy
                        // depending on which platforms match
                        var platformNode = new PlatformNode(platformName);
                        var rootNode = platformNode.getRoot(this, 0);
                        if (rootNode) {
                            rootNode.depth = 0;
                            var childPlatform = rootNode.child();
                            while (childPlatform) {
                                rootNode.depth++;
                                childPlatform = childPlatform.child();
                            }
                        }
                        return rootNode;
                    }
                }, {
                    key: 'settings',
                    value: function settings(val) {
                        if (arguments.length) {
                            this._settings = val;
                        }
                        return this._settings;
                    }
                }], [{
                    key: 'register',
                    value: function register(platformConfig) {
                        platformRegistry[platformConfig.name] = platformConfig;
                    }
                }, {
                    key: 'registry',
                    value: function registry() {
                        return platformRegistry;
                    }

                    /**
                     * TODO
                     * @param {TODO} platformName  TODO
                     * @returns {string} TODO
                     */
                }, {
                    key: 'get',
                    value: function get(platformName) {
                        return platformRegistry[platformName] || {};
                    }
                }, {
                    key: 'setDefault',
                    value: function setDefault(platformName) {
                        platformDefault = platformName;
                    }
                }]);

                return IonicPlatform;
            })();

            _export('IonicPlatform', IonicPlatform);

            PlatformNode = (function () {
                function PlatformNode(platformName) {
                    _classCallCheck(this, PlatformNode);

                    this.c = IonicPlatform.get(platformName);
                    this.isEngine = this.c.isEngine;
                }

                _createClass(PlatformNode, [{
                    key: 'name',
                    value: function name() {
                        return this.c.name;
                    }
                }, {
                    key: 'settings',
                    value: function settings() {
                        return this.c.settings || {};
                    }
                }, {
                    key: 'superset',
                    value: function superset() {
                        return this.c.superset;
                    }
                }, {
                    key: 'methods',
                    value: function methods() {
                        return this.c.methods || {};
                    }
                }, {
                    key: 'parent',
                    value: function parent(val) {
                        if (arguments.length) {
                            this._parent = val;
                        }
                        return this._parent;
                    }
                }, {
                    key: 'child',
                    value: function child(val) {
                        if (arguments.length) {
                            this._child = val;
                        }
                        return this._child;
                    }
                }, {
                    key: 'isMatch',
                    value: function isMatch(p) {
                        if (typeof this.c.isMatched !== 'boolean') {
                            if (p.platformOverride && !this.isEngine) {
                                this.c.isMatched = p.platformOverride === this.c.name;
                            } else if (!this.c.isMatch) {
                                this.c.isMatched = false;
                            } else {
                                this.c.isMatched = this.c.isMatch(p);
                            }
                        }
                        return this.c.isMatched;
                    }
                }, {
                    key: 'version',
                    value: function version(p) {
                        if (this.c.versionParser) {
                            var v = this.c.versionParser(p);
                            if (v) {
                                var str = v.major + '.' + v.minor;
                                return {
                                    str: str,
                                    num: parseFloat(str),
                                    major: parseInt(v.major, 10),
                                    minor: parseInt(v.minor, 10)
                                };
                            }
                        }
                    }
                }, {
                    key: 'getRoot',
                    value: function getRoot(p) {
                        if (this.isMatch(p)) {
                            var parents = this.getSubsetParents(this.name());
                            if (!parents.length) {
                                return this;
                            }
                            var platform = null;
                            var rootPlatform = null;
                            for (var i = 0; i < parents.length; i++) {
                                platform = new PlatformNode(parents[i]);
                                platform.child(this);
                                rootPlatform = platform.getRoot(p);
                                if (rootPlatform) {
                                    this.parent(platform);
                                    return rootPlatform;
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getSubsetParents',
                    value: function getSubsetParents(subsetPlatformName) {
                        var platformRegistry = IonicPlatform.registry();
                        var parentPlatformNames = [];
                        var platform = null;
                        for (var platformName in platformRegistry) {
                            platform = platformRegistry[platformName];
                            if (platform.subsets && platform.subsets.indexOf(subsetPlatformName) > -1) {
                                parentPlatformNames.push(platformName);
                            }
                        }
                        return parentPlatformNames;
                    }
                }]);

                return PlatformNode;
            })();

            platformRegistry = {};
            platformDefault = null;
        }
    };
});
System.register('ionic/platform/plugin', [], function (_export) {
    'use strict';

    var NativePluginDecorator;

    _export('NativePlugin', NativePlugin);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function NativePlugin(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new NativePluginDecorator(cls, config));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    return {
        setters: [],
        execute: function () {
            NativePluginDecorator = function NativePluginDecorator(cls, config) {
                var _this = this;

                _classCallCheck(this, NativePluginDecorator);

                this.cls = cls;
                this.config = config;
                cls.ifPlugin = function (cb) {
                    var returnType = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

                    // Convert to boolean the plugin param
                    var exists = !!check;
                    if (typeof _this.config.pluginCheck === 'function') {
                        exists = _this.config.pluginCheck();
                    }
                    if (exists) {
                        return cb();
                    }
                    // We don't have the plugin, so print a warning message
                    cls.pluginWarn();
                    // If the user supplied a default return value, return it here.
                    if (returnType) {
                        return typeof returnType === 'function' ? returnType() : returnType;
                    }
                    return false;
                };
                cls.pluginWarn = function () {
                    if (cls._pluginWarned) {
                        // Only warn once
                        return;
                    }
                    var platformString = [];
                    for (var k in _this.config.engines) {
                        platformString.push('\t' + k + ': ' + _this.config.engines[k]);
                    }
                    console.warn('Plugin for ' + _this.config.name + ' not installed. For native functionality, please install the correct plugin for your platform:\n' + platformString.join('\n'));
                    // Set a flag so we don't warn again
                    cls._pluginWarned = true;
                };
            };

            _export('NativePluginDecorator', NativePluginDecorator);
        }
    };
});
System.register('ionic/platform/plugins', ['./plugin', './applinks/applinks', './barcode/barcode', './battery/battery', './camera/camera', './contacts/contacts', './dialogs/dialogs', './device/device', './device-motion/device-motion', './device-orientation/device-orientation', './geolocation/geolocation', './keyboard/keyboard', './statusbar/statusbar', './vibration/vibration'], function (_export) {
  'use strict';

  return {
    setters: [function (_plugin) {
      for (var _key in _plugin) {
        if (_key !== 'default') _export(_key, _plugin[_key]);
      }
    }, function (_applinksApplinks) {
      for (var _key2 in _applinksApplinks) {
        if (_key2 !== 'default') _export(_key2, _applinksApplinks[_key2]);
      }
    }, function (_barcodeBarcode) {
      for (var _key3 in _barcodeBarcode) {
        if (_key3 !== 'default') _export(_key3, _barcodeBarcode[_key3]);
      }
    }, function (_batteryBattery) {
      for (var _key4 in _batteryBattery) {
        if (_key4 !== 'default') _export(_key4, _batteryBattery[_key4]);
      }
    }, function (_cameraCamera) {
      for (var _key5 in _cameraCamera) {
        if (_key5 !== 'default') _export(_key5, _cameraCamera[_key5]);
      }
    }, function (_contactsContacts) {
      for (var _key6 in _contactsContacts) {
        if (_key6 !== 'default') _export(_key6, _contactsContacts[_key6]);
      }
    }, function (_dialogsDialogs) {
      for (var _key7 in _dialogsDialogs) {
        if (_key7 !== 'default') _export(_key7, _dialogsDialogs[_key7]);
      }
    }, function (_deviceDevice) {
      for (var _key8 in _deviceDevice) {
        if (_key8 !== 'default') _export(_key8, _deviceDevice[_key8]);
      }
    }, function (_deviceMotionDeviceMotion) {
      for (var _key9 in _deviceMotionDeviceMotion) {
        if (_key9 !== 'default') _export(_key9, _deviceMotionDeviceMotion[_key9]);
      }
    }, function (_deviceOrientationDeviceOrientation) {
      for (var _key10 in _deviceOrientationDeviceOrientation) {
        if (_key10 !== 'default') _export(_key10, _deviceOrientationDeviceOrientation[_key10]);
      }
    }, function (_geolocationGeolocation) {
      for (var _key11 in _geolocationGeolocation) {
        if (_key11 !== 'default') _export(_key11, _geolocationGeolocation[_key11]);
      }
    }, function (_keyboardKeyboard) {
      for (var _key12 in _keyboardKeyboard) {
        if (_key12 !== 'default') _export(_key12, _keyboardKeyboard[_key12]);
      }
    }, function (_statusbarStatusbar) {
      for (var _key13 in _statusbarStatusbar) {
        if (_key13 !== 'default') _export(_key13, _statusbarStatusbar[_key13]);
      }
    }, function (_vibrationVibration) {
      for (var _key14 in _vibrationVibration) {
        if (_key14 !== 'default') _export(_key14, _vibrationVibration[_key14]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/platform/registry', ['./platform', '../util/dom'], function (_export) {
    'use strict';

    var IonicPlatform, windowLoad;
    return {
        setters: [function (_platform) {
            IonicPlatform = _platform.IonicPlatform;
        }, function (_utilDom) {
            windowLoad = _utilDom.windowLoad;
        }],
        execute: function () {
            IonicPlatform.register({
                name: 'core',
                settings: {
                    mode: 'ios',
                    keyboardHeight: 290
                }
            });
            IonicPlatform.setDefault('core');
            IonicPlatform.register({
                name: 'mobile'
            });
            IonicPlatform.register({
                name: 'phablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    return smallest > 390 && smallest < 520 && (largest > 620 && largest < 800);
                }
            });
            IonicPlatform.register({
                name: 'tablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    return smallest > 460 && smallest < 820 && (largest > 780 && largest < 1400);
                }
            });
            IonicPlatform.register({
                name: 'android',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    mode: 'md',
                    keyboardHeight: 290,
                    keyboardScrollAssist: true,
                    hoverCSS: false
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('android', 'android|silk');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Android (\d+).(\d+)?/);
                }
            });
            IonicPlatform.register({
                name: 'ios',
                superset: 'mobile',
                subsets: ['ipad', 'iphone'],
                settings: {
                    mode: 'ios',
                    keyboardScrollAssist: function keyboardScrollAssist(p) {
                        return (/iphone|ipad|ipod/i.test(p.navigatorPlatform())
                        );
                    },
                    keyboardHeight: 290,
                    hoverCSS: false,
                    swipeBackEnabled: function swipeBackEnabled(p) {
                        return true; // TODO: remove me! Force it to always work for iOS mode for now
                        return (/iphone|ipad|ipod/i.test(p.navigatorPlatform())
                        );
                    },
                    swipeBackThreshold: 40
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ios', 'iphone|ipad|ipod');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/OS (\d+)_(\d+)?/);
                }
            });
            IonicPlatform.register({
                name: 'ipad',
                superset: 'tablet',
                settings: {
                    keyboardHeight: 500
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ipad');
                }
            });
            IonicPlatform.register({
                name: 'iphone',
                subsets: ['phablet'],
                isMatch: function isMatch(p) {
                    return p.isPlatform('iphone');
                }
            });
            IonicPlatform.register({
                name: 'windowsphone',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    mode: 'md'
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('windowsphone', 'windows phone');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Windows Phone (\d+).(\d+)?/);
                }
            });
            IonicPlatform.register({
                name: 'cordova',
                isEngine: true,
                methods: {
                    ready: function ready(resolve) {
                        function isReady() {
                            document.removeEventListener('deviceready', isReady);
                            resolve();
                        }
                        windowLoad(function () {
                            document.addEventListener('deviceready', isReady);
                        });
                    }
                },
                isMatch: function isMatch() {
                    return !!(window.cordova || window.PhoneGap || window.phonegap);
                }
            });
        }
    };
});
System.register('ionic/platform/storage', ['./storage/storage', './storage/local-storage', './storage/sql'], function (_export) {
  'use strict';

  return {
    setters: [function (_storageStorage) {
      for (var _key in _storageStorage) {
        if (_key !== 'default') _export(_key, _storageStorage[_key]);
      }
    }, function (_storageLocalStorage) {
      for (var _key2 in _storageLocalStorage) {
        if (_key2 !== 'default') _export(_key2, _storageLocalStorage[_key2]);
      }
    }, function (_storageSql) {
      for (var _key3 in _storageSql) {
        if (_key3 !== 'default') _export(_key3, _storageSql[_key3]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/transitions/ios-transition', ['./transition', '../animations/animation'], function (_export) {
    'use strict';

    var Transition, Animation, DURATION, EASING, OPACITY, TRANSLATEX, OFF_LEFT, CENTER, OFF_OPACITY, IOSTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            DURATION = 550;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            OPACITY = 'opacity';
            TRANSLATEX = 'translateX';
            OFF_LEFT = '-33%';
            CENTER = '0%';
            OFF_OPACITY = 0.8;

            IOSTransition = (function (_Transition) {
                _inherits(IOSTransition, _Transition);

                function IOSTransition(nav, opts) {
                    _classCallCheck(this, IOSTransition);

                    _get(Object.getPrototypeOf(IOSTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves to center
                    this.enteringView.to(TRANSLATEX, CENTER).to(OPACITY, 1).before.setStyles({ zIndex: this.entering.index });
                    this.enteringTitle.fadeIn().to(TRANSLATEX, CENTER);
                    this.enteringNavbarBackground.to(TRANSLATEX, CENTER);
                    // leaving view moves off screen
                    this.leavingView.from(TRANSLATEX, CENTER).from(OPACITY, 1).before.setStyles({ zIndex: this.leaving.index });
                    this.leavingTitle.from(TRANSLATEX, CENTER).from(OPACITY, 1);
                    this.leavingNavbarBackground.from(TRANSLATEX, CENTER);
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEX, OFF_LEFT).from(OPACITY, OFF_OPACITY).to(OPACITY, 1);
                        this.enteringTitle.from(TRANSLATEX, OFF_LEFT);
                        this.enteringNavbarBackground.from(TRANSLATEX, OFF_LEFT);
                        this.leavingView.to(TRANSLATEX, '100%').to(OPACITY, 1);
                        this.leavingTitle.to(TRANSLATEX, '100%').to(OPACITY, 0);
                        this.leavingNavbarBackground.to(TRANSLATEX, '100%');
                        if (this.leaving.enableBack() && this.viewWidth() > 200) {
                            var leavingBackButtonText = new Animation(this.leaving.backBtnTextRef());
                            leavingBackButtonText.fromTo(TRANSLATEX, CENTER, this.viewWidth() / 2 + 'px');
                            this.leavingNavbar.add(leavingBackButtonText);
                        }
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEX, '99.5%').from(OPACITY, 1);
                        this.enteringTitle.from(TRANSLATEX, '99.5%');
                        this.enteringNavbarBackground.from(TRANSLATEX, '99.5%');
                        this.leavingView.to(TRANSLATEX, OFF_LEFT).to(OPACITY, OFF_OPACITY);
                        this.leavingTitle.to(TRANSLATEX, OFF_LEFT).to(OPACITY, 0);
                        this.leavingNavbarBackground.to(TRANSLATEX, OFF_LEFT);
                        if (this.entering.enableBack() && this.viewWidth() > 200) {
                            var enteringBackButtonText = new Animation(this.entering.backBtnTextRef());
                            enteringBackButtonText.fromTo(TRANSLATEX, this.viewWidth() / 2 + 'px', CENTER);
                            this.enteringNavbar.add(enteringBackButtonText);
                        }
                    }
                }

                return IOSTransition;
            })(Transition);

            Transition.register('ios', IOSTransition);
        }
    };
});
System.register('ionic/transitions/md-transition', ['./transition', '../animations/animation'], function (_export) {
    'use strict';

    var Transition, Animation, DURATION, EASING, TRANSLATEY, OFF_BOTTOM, CENTER, MaterialTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            DURATION = 300;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            TRANSLATEY = 'translateY';
            OFF_BOTTOM = '40px';
            CENTER = '0px';

            MaterialTransition = (function (_Transition) {
                _inherits(MaterialTransition, _Transition);

                function MaterialTransition(nav, opts) {
                    _classCallCheck(this, MaterialTransition);

                    _get(Object.getPrototypeOf(MaterialTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves in bottom to center
                    this.enteringView.to(TRANSLATEY, CENTER).before.setStyles({ zIndex: this.entering.index });
                    // entering item moves in bottom to center
                    this.enteringNavbar.to(TRANSLATEY, CENTER).before.setStyles({ zIndex: this.entering.index + 10 });
                    // leaving view stays put
                    this.leavingView.before.setStyles({ zIndex: this.leaving.index });
                    this.leavingNavbar.before.setStyles({ zIndex: this.leaving.index + 10 });
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEY, CENTER);
                        this.enteringNavbar.from(TRANSLATEY, CENTER);
                        // leaving view goes center to bottom
                        this.leavingView.fromTo(TRANSLATEY, CENTER, OFF_BOTTOM).fadeOut();
                        this.leavingNavbar.fromTo(TRANSLATEY, CENTER, OFF_BOTTOM).fadeOut();
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEY, OFF_BOTTOM).fadeIn();
                        this.enteringNavbar.from(TRANSLATEY, OFF_BOTTOM).fadeIn();
                    }
                    var itemLength = nav.length();
                    if (nav.tabs && (itemLength === 1 || itemLength === 2)) {
                        var tabBarEle = nav.tabs.elementRef.nativeElement.querySelector('.tab-bar-container');
                        var tabBar = new Animation(tabBarEle);
                        if (itemLength === 1 && opts.direction == 'back') {
                            tabBar.fromTo('height', '0px', '69px');
                            tabBar.fadeIn();
                        } else if (itemLength === 2 && opts.direction == 'forward') {
                            tabBar.fromTo('height', '69px', '0px');
                            tabBar.fadeOut();
                        }
                        this.add(tabBar);
                    }
                }

                return MaterialTransition;
            })(Transition);

            Transition.register('md', MaterialTransition);
        }
    };
});
System.register('ionic/transitions/transition', ['../animations/animation'], function (_export) {
    'use strict';

    var Animation, SHOW_NAVBAR_CSS, SHOW_VIEW_CSS, SHOW_BACK_BUTTON, TransitionRegistry, Transition;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            SHOW_NAVBAR_CSS = 'show-navbar';
            SHOW_VIEW_CSS = 'show-view';
            SHOW_BACK_BUTTON = 'show-back-button';
            TransitionRegistry = {};

            Transition = (function (_Animation) {
                _inherits(Transition, _Animation);

                function Transition(nav, opts) {
                    _classCallCheck(this, Transition);

                    _get(Object.getPrototypeOf(Transition.prototype), 'constructor', this).call(this);
                    // get the entering and leaving items
                    var enteringView = this.entering = nav.getStagedEnteringView();
                    var leavingView = this.leaving = nav.getStagedLeavingView();
                    // create animation for the entering item's "ion-view" element
                    this.enteringView = new Animation(enteringView.viewElementRef());
                    this.enteringView.before.addClass(SHOW_VIEW_CSS);
                    this.enteringView.onPlay(function () {
                        enteringView.postRender();
                    });
                    this.add(this.enteringView);
                    if (opts.navbar !== false) {
                        var enteringNavbar = this.enteringNavbar = new Animation(enteringView.navbarRef());
                        enteringNavbar.before.addClass(SHOW_NAVBAR_CSS);
                        if (enteringView.enableBack()) {
                            // only animate in the back button if the entering view has it enabled
                            var enteringBackButton = this.enteringBackButton = new Animation(enteringView.backBtnRef());
                            enteringBackButton.before.addClass(SHOW_BACK_BUTTON).fadeIn();
                            enteringNavbar.add(enteringBackButton);
                        }
                        this.enteringTitle = new Animation(enteringView.titleRef());
                        enteringNavbar.add(this.enteringTitle);
                        this.add(enteringNavbar);
                        this.enteringNavbarItems = new Animation(enteringView.navbarItemRefs());
                        enteringNavbar.add(this.enteringNavbarItems.fadeIn());
                        this.enteringNavbarBackground = new Animation(enteringView.navbarBackgroundRef());
                        enteringNavbar.add(this.enteringNavbarBackground);
                    }
                    if (leavingView) {
                        // setup the leaving item if one exists (initial viewing wouldn't have a leaving item)
                        this.leavingView = new Animation(leavingView.viewElementRef());
                        this.leavingView.after.removeClass(SHOW_VIEW_CSS);
                        var leavingNavbar = this.leavingNavbar = new Animation(leavingView.navbarRef());
                        leavingNavbar.after.removeClass(SHOW_NAVBAR_CSS);
                        var leavingBackButton = this.leavingBackButton = new Animation(leavingView.backBtnRef());
                        leavingBackButton.after.removeClass(SHOW_BACK_BUTTON).fadeOut();
                        leavingNavbar.add(leavingBackButton);
                        this.leavingTitle = new Animation(leavingView.titleRef());
                        leavingNavbar.add(this.leavingTitle);
                        this.leavingNavbarItems = new Animation(leavingView.navbarItemRefs());
                        leavingNavbar.add(this.leavingNavbarItems.fadeOut());
                        this.leavingNavbarBackground = new Animation(leavingView.navbarBackgroundRef());
                        leavingNavbar.add(this.leavingNavbarBackground);
                        this.add(this.leavingView, leavingNavbar);
                    }
                }

                _createClass(Transition, [{
                    key: 'viewWidth',
                    value: function viewWidth() {
                        // TODO: MAKE MORE BETTER
                        return this._w || (this._w = this.leaving && this.leaving.viewElementRef().nativeElement.offsetWidth);
                    }

                    /*
                     STATIC CLASSES
                     */
                }], [{
                    key: 'create',
                    value: function create(nav) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var name = opts.animation || 'ios';
                        var TransitionClass = TransitionRegistry[name];
                        if (!TransitionClass) {
                            // transition wasn't found, default to a 'none' transition
                            // which doesn't animate anything, just shows and hides
                            TransitionClass = Transition;
                        }
                        return new TransitionClass(nav, opts);
                    }
                }, {
                    key: 'register',
                    value: function register(name, TransitionClass) {
                        TransitionRegistry[name] = TransitionClass;
                    }
                }]);

                return Transition;
            })(Animation);

            _export('Transition', Transition);
        }
    };
});
System.register('ionic/native/plugin', [], function (_export) {
    'use strict';

    var NativePluginDecorator;

    _export('NativePlugin', NativePlugin);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function NativePlugin(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new NativePluginDecorator(cls, config));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    return {
        setters: [],
        execute: function () {
            NativePluginDecorator = function NativePluginDecorator(cls, config) {
                var _this = this;

                _classCallCheck(this, NativePluginDecorator);

                this.cls = cls;
                this.config = config;
                cls.ifPlugin = function (check, cb) {
                    var returnType = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

                    // Convert to boolean the plugin param
                    var exists = !!check;
                    if (typeof check === 'function') {
                        exists = check();
                    }
                    if (exists) {
                        return cb();
                    }
                    cls.pluginWarn();
                    return typeof returnType === 'function' ? returnType() : returnType;
                };
                cls.pluginWarn = function () {
                    if (cls._pluginWarned) {
                        // Only warn once
                        return;
                    }
                    var platformString = [];
                    for (var k in _this.config.platforms) {
                        platformString.push('\t' + k + ': ' + _this.config.platforms[k]);
                    }
                    console.warn('Plugin for ' + _this.config.name + ' not installed. For native functionality, please install the correct plugin for your platform:\n' + platformString.join('\n'));
                    // Set a flag so we don't warn again
                    cls._pluginWarned = true;
                };
            };

            _export('NativePluginDecorator', NativePluginDecorator);
        }
    };
});
System.register('ionic/native/plugins', ['./plugin', './battery/battery', './camera/camera', './contacts/contacts', './dialogs/dialogs', './device/device', './device-motion/device-motion', './device-orientation/device-orientation', './geolocation/geolocation', './vibration/vibration'], function (_export) {
  'use strict';

  return {
    setters: [function (_plugin) {
      for (var _key in _plugin) {
        if (_key !== 'default') _export(_key, _plugin[_key]);
      }
    }, function (_batteryBattery) {
      for (var _key2 in _batteryBattery) {
        if (_key2 !== 'default') _export(_key2, _batteryBattery[_key2]);
      }
    }, function (_cameraCamera) {
      for (var _key3 in _cameraCamera) {
        if (_key3 !== 'default') _export(_key3, _cameraCamera[_key3]);
      }
    }, function (_contactsContacts) {
      for (var _key4 in _contactsContacts) {
        if (_key4 !== 'default') _export(_key4, _contactsContacts[_key4]);
      }
    }, function (_dialogsDialogs) {
      for (var _key5 in _dialogsDialogs) {
        if (_key5 !== 'default') _export(_key5, _dialogsDialogs[_key5]);
      }
    }, function (_deviceDevice) {
      for (var _key6 in _deviceDevice) {
        if (_key6 !== 'default') _export(_key6, _deviceDevice[_key6]);
      }
    }, function (_deviceMotionDeviceMotion) {
      for (var _key7 in _deviceMotionDeviceMotion) {
        if (_key7 !== 'default') _export(_key7, _deviceMotionDeviceMotion[_key7]);
      }
    }, function (_deviceOrientationDeviceOrientation) {
      for (var _key8 in _deviceOrientationDeviceOrientation) {
        if (_key8 !== 'default') _export(_key8, _deviceOrientationDeviceOrientation[_key8]);
      }
    }, function (_geolocationGeolocation) {
      for (var _key9 in _geolocationGeolocation) {
        if (_key9 !== 'default') _export(_key9, _geolocationGeolocation[_key9]);
      }
    }, function (_vibrationVibration) {
      for (var _key10 in _vibrationVibration) {
        if (_key10 !== 'default') _export(_key10, _vibrationVibration[_key10]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/util/activator', ['./dom'], function (_export) {
    'use strict';

    var raf, pointerCoord, hasPointerMoved, Activator;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_dom) {
            raf = _dom.raf;
            pointerCoord = _dom.pointerCoord;
            hasPointerMoved = _dom.hasPointerMoved;
        }],
        execute: function () {
            Activator = (function () {
                function Activator(app, config, window, document) {
                    _classCallCheck(this, Activator);

                    var self = this;
                    self.app = app;
                    self.config = config;
                    self.win = window;
                    self.doc = document;
                    self.id = 0;
                    self.queue = {};
                    self.active = {};
                    self.activatedClass = 'activated';
                    self.deactivateTimeout = 180;
                    this.deactivateAttempt = 0;
                    self.pointerTolerance = 4;
                    self.isTouch = false;
                    self.disableClick = 0;
                    self.disableClickLimit = 2500;
                    self.tapPolyfill = config.setting('tapPolyfill');
                    function bindDom(type, listener, useCapture) {
                        document.addEventListener(type, listener, useCapture);
                    }
                    bindDom('click', function (ev) {
                        self.click(ev);
                    }, true);
                    bindDom('touchstart', function (ev) {
                        self.isTouch = true;
                        self.pointerStart(ev);
                    });
                    bindDom('touchend', function (ev) {
                        self.isTouch = true;
                        self.touchEnd(ev);
                    });
                    bindDom('touchcancel', function (ev) {
                        self.isTouch = true;
                        self.pointerCancel(ev);
                    });
                    bindDom('mousedown', function (ev) {
                        self.mouseDown(ev);
                    }, true);
                    bindDom('mouseup', function (ev) {
                        self.mouseUp(ev);
                    }, true);
                    self.pointerMove = function (ev) {
                        var moveCoord = pointerCoord(ev);
                        console.log('pointerMove', moveCoord, self.start);
                        if (hasPointerMoved(10, self.start, moveCoord)) {
                            self.pointerCancel();
                        }
                    };
                    self.moveListeners = function (shouldAdd) {
                        document.removeEventListener('touchmove', self.pointerMove);
                        document.removeEventListener('mousemove', self.pointerMove);
                        if (shouldAdd) {
                            bindDom('touchmove', self.pointerMove);
                            bindDom('mousemove', self.pointerMove);
                        }
                    };
                }

                /**
                 * TODO
                 * @param {TODO} ev  TODO
                 */

                _createClass(Activator, [{
                    key: 'touchEnd',
                    value: function touchEnd(ev) {
                        var self = this;
                        if (self.tapPolyfill && self.start) {
                            var endCoord = pointerCoord(ev);
                            if (!hasPointerMoved(self.pointerTolerance, self.start, endCoord)) {
                                console.debug('create click');
                                self.disableClick = Date.now();
                                var clickEvent = self.doc.createEvent('MouseEvents');
                                clickEvent.initMouseEvent('click', true, true, self.win, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
                                clickEvent.isIonicTap = true;
                                ev.target.dispatchEvent(clickEvent);
                            }
                        }
                        self.pointerEnd(ev);
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseDown',
                    value: function mouseDown(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseDown prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else if (!self.isTouch) {
                            this.pointerStart(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseUp',
                    value: function mouseUp(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseUp prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        if (!self.isTouch) {
                            this.pointerEnd(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'pointerStart',
                    value: function pointerStart(ev) {
                        var targetEle = this.getActivatableTarget(ev.target);
                        if (targetEle) {
                            this.start = pointerCoord(ev);
                            this.queueActivate(targetEle);
                            this.moveListeners(true);
                        } else {
                            this.start = null;
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerEnd',
                    value: function pointerEnd(ev) {
                        this.queueDeactivate();
                        this.moveListeners(false);
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerCancel',
                    value: function pointerCancel() {
                        console.debug('pointerCancel');
                        this.deactivate();
                        this.moveListeners(false);
                        this.disableClick = Date.now();
                    }
                }, {
                    key: 'isDisabledClick',
                    value: function isDisabledClick() {
                        return this.disableClick + this.disableClickLimit > Date.now();
                    }

                    /**
                     * Whether the supplied click event should be allowed or not.
                     * @param {MouseEvent} ev  The click event.
                     * @return {boolean} True if click event should be allowed, otherwise false.
                     */
                }, {
                    key: 'allowClick',
                    value: function allowClick(ev) {
                        if (!ev.isIonicTap) {
                            if (this.isDisabledClick()) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * TODO
                     * @param {MouseEvent} ev  TODO
                     */
                }, {
                    key: 'click',
                    value: function click(ev) {
                        if (!this.allowClick(ev)) {
                            console.debug('click prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        this.isTouch = false;
                    }
                }, {
                    key: 'getActivatableTarget',
                    value: function getActivatableTarget(ele) {
                        var targetEle = ele;
                        for (var x = 0; x < 4; x++) {
                            if (!targetEle) break;
                            if (this.isActivatable(targetEle)) return targetEle;
                            targetEle = targetEle.parentElement;
                        }
                        return null;
                    }
                }, {
                    key: 'isActivatable',
                    value: function isActivatable(ele) {
                        if (/^(A|BUTTON)$/.test(ele.tagName)) {
                            return true;
                        }
                        var attributes = ele.attributes;
                        for (var i = 0, l = attributes.length; i < l; i++) {
                            if (/click|tappable/.test(attributes[i].name)) {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'queueActivate',
                    value: function queueActivate(ele) {
                        var self = this;
                        self.queue[++self.id] = ele;
                        if (self.id > 19) self.id = 0;
                        raf(function () {
                            // activate all elements in the queue
                            for (var key in self.queue) {
                                if (self.queue[key]) {
                                    self.queue[key].classList.add(self.activatedClass);
                                    self.active[key] = self.queue[key];
                                }
                            }
                            self.queue = {};
                        });
                    }
                }, {
                    key: 'queueDeactivate',
                    value: function queueDeactivate() {
                        var self = this;
                        setTimeout(function () {
                            self.deactivate();
                        }, this.deactivateTimeout);
                    }
                }, {
                    key: 'deactivate',
                    value: function deactivate() {
                        var self = this;
                        if (this.app.isTransitioning() && this.deactivateAttempt < 10) {
                            // the app is actively transitioning, don't bother deactivating
                            // anything this makes it easier on the GPU so it doesn't
                            // have to redraw any buttons during a transition
                            // retry
                            ++this.deactivateAttempt;
                            this.queueDeactivate();
                        } else {
                            // not actively transitioning, good to deactivate any elements
                            // clear out any elements that are queued to be set to active
                            self.queue = {};
                            // in the next frame, remove the active class from all active elements
                            raf(function () {
                                for (var key in self.active) {
                                    if (self.active[key]) {
                                        self.active[key].classList.remove(self.activatedClass);
                                    }
                                    delete self.active[key];
                                }
                            });
                            this.deactivateAttempt = 0;
                        }
                    }
                }]);

                return Activator;
            })();

            _export('Activator', Activator);
        }
    };
});
System.register('ionic/util/click-block', [], function (_export) {
    'use strict';

    var CSS_CLICK_BLOCK, DEFAULT_EXPIRE, cbEle, fallbackTimerId, isShowing, ClickBlock;

    function disableInput(ev) {
        ev.preventDefault();
        ev.stopPropagation();
    }
    function show(expire) {
        clearTimeout(fallbackTimerId);
        fallbackTimerId = setTimeout(hide, expire || DEFAULT_EXPIRE);
        if (!isShowing) {
            isShowing = true;
            if (cbEle) {
                cbEle.classList.add(CSS_CLICK_BLOCK);
            } else {
                cbEle = document.createElement('div');
                cbEle.className = 'click-block ' + CSS_CLICK_BLOCK;
                document.body.appendChild(cbEle);
            }
            cbEle.addEventListener('touchmove', disableInput);
        }
    }
    function hide() {
        clearTimeout(fallbackTimerId);
        if (isShowing) {
            cbEle.classList.remove(CSS_CLICK_BLOCK);
            isShowing = false;
            cbEle.removeEventListener('touchmove', disableInput);
        }
    }
    return {
        setters: [],
        execute: function () {
            CSS_CLICK_BLOCK = 'click-block-active';
            DEFAULT_EXPIRE = 330;
            cbEle = undefined;
            fallbackTimerId = undefined;
            isShowing = false;

            ClickBlock = function ClickBlock(shouldShow, expire) {
                (shouldShow ? show : hide)(expire);
            };

            _export('ClickBlock', ClickBlock);
        }
    };
});
System.register('ionic/util/dom', [], function (_export) {
    'use strict';

    var nativeRaf, nativeCancelRaf, raf, rafCancel, CSS, dimensionCache, dimensionIds;

    _export('rafPromise', rafPromise);

    _export('transitionEnd', transitionEnd);

    _export('animationStart', animationStart);

    _export('animationEnd', animationEnd);

    _export('ready', ready);

    _export('windowLoad', windowLoad);

    _export('pointerCoord', pointerCoord);

    _export('hasPointerMoved', hasPointerMoved);

    _export('hasFocus', hasFocus);

    _export('isTextInput', isTextInput);

    _export('hasFocusedTextInput', hasFocusedTextInput);

    _export('closest', closest);

    /**
     * Get the element offsetWidth and offsetHeight. Values are cached
     * to reduce DOM reads. Cache is cleared on a window resize.
     * @param {TODO} ele  TODO
     */

    _export('removeElement', removeElement);

    _export('getDimensions', getDimensions);

    _export('windowDimensions', windowDimensions);

    _export('flushDimensionCache', flushDimensionCache);

    function rafPromise() {
        return new Promise(function (resolve) {
            return raf(resolve);
        });
    }

    function transitionEnd(el) {
        return cssPromise(el, CSS.transitionEnd);
    }

    function animationStart(el, animationName) {
        return cssPromise(el, CSS.animationStart, animationName);
    }

    function animationEnd(el, animationName) {
        return cssPromise(el, CSS.animationEnd, animationName);
    }

    function cssPromise(el, eventNames, animationName) {
        return new Promise(function (resolve) {
            eventNames.split(' ').forEach(function (eventName) {
                el.addEventListener(eventName, onEvent);
            });
            function onEvent(ev) {
                if (ev.animationName && animationName) {
                    // do not resolve if a bubbled up ev.animationName
                    // is not the same as the passed in animationName arg
                    if (ev.animationName !== animationName) {
                        return;
                    }
                } else if (ev.target !== el) {
                    // do not resolve if the event's target element is not
                    // the same as the element the listener was added to
                    return;
                }
                ev.stopPropagation();
                eventNames.split(' ').forEach(function (eventName) {
                    el.removeEventListener(eventName, onEvent);
                });
                resolve(ev);
            }
        });
    }

    function ready(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    document.removeEventListener('DOMContentLoaded', completed, false);
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function windowLoad(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function pointerCoord(ev) {
        // get coordinates for either a mouse click
        // or a touch depending on the given event
        var c = { x: 0, y: 0 };
        if (ev) {
            var touches = ev.touches && ev.touches.length ? ev.touches : [ev];
            var e = ev.changedTouches && ev.changedTouches[0] || touches[0];
            if (e) {
                c.x = e.clientX || e.pageX || 0;
                c.y = e.clientY || e.pageY || 0;
            }
        }
        return c;
    }

    function hasPointerMoved(threshold, startCoord, endCoord) {
        return startCoord && endCoord && (Math.abs(startCoord.x - endCoord.x) > threshold || Math.abs(startCoord.y - endCoord.y) > threshold);
    }

    function hasFocus(ele) {
        return !!(ele && (document.activeElement === ele.nativeElement || document.activeElement === ele));
    }

    function isTextInput(ele) {
        return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || ele.tagName == 'INPUT' && !/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i.test(ele.type));
    }

    function hasFocusedTextInput() {
        var ele = document.activeElement;
        if (isTextInput(ele)) {
            return ele.parentElement.querySelector(':focus') === ele;
        }
        return false;
    }

    function closest(ele, selector) {
        var matchesFn;
        // find vendor prefix
        ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function (fn) {
            if (typeof document.body[fn] == 'function') {
                matchesFn = fn;
                return true;
            }
            return false;
        });
        // traverse parents
        while (ele !== null) {
            parent = ele.parentElement;
            if (parent !== null && parent[matchesFn](selector)) {
                return parent;
            }
            ele = parent;
        }
        return null;
    }

    function removeElement(ele) {
        ele && ele.parentNode && ele.parentNode.removeChild(ele);
    }

    function getDimensions(ion) {
        if (!ion._dimId) {
            ion._dimId = ++dimensionIds;
            if (ion._dimId % 100 === 0) {
                // periodically flush dimensions
                flushDimensionCache();
            }
        }
        var dimensions = dimensionCache[ion._dimId];
        if (!dimensions) {
            var ele = ion.getNativeElement();
            dimensions = dimensionCache[ion._dimId] = {
                w: ele.offsetWidth,
                h: ele.offsetHeight
            };
        }
        return dimensions;
    }

    function windowDimensions() {
        if (!dimensionCache.win) {
            dimensionCache.win = {
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        return dimensionCache.win;
    }

    function flushDimensionCache() {
        dimensionCache = {};
    }

    return {
        setters: [],
        execute: function () {
            nativeRaf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
            nativeCancelRaf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;

            raf = nativeRaf || function (callback) {
                var timeCurrent = new Date().getTime(),
                    timeDelta = undefined;
                /* Dynamically set delay on a per-tick basis to match 60fps. */
                /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
                timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
                timeLast = timeCurrent + timeDelta;
                return setTimeout(function () {
                    callback(timeCurrent + timeDelta);
                }, timeDelta);
            };

            _export('raf', raf);

            rafCancel = nativeRaf ? nativeCancelRaf : function (id) {
                return window.cancelTimeout(id);
            };

            _export('rafCancel', rafCancel);

            CSS = {};

            _export('CSS', CSS);

            (function () {
                // transform
                var i,
                    keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transform = keys[i];
                        break;
                    }
                }
                // transition
                keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transition = keys[i];
                        break;
                    }
                }
                // The only prefix we care about is webkit for transitions.
                var isWebkit = CSS.transition.indexOf('webkit') > -1;
                CSS.prefix = isWebkit ? '-webkit-' : '';
                // transition duration
                CSS.transitionDuration = (isWebkit ? '-webkit-' : '') + 'transition-duration';
                // To be sure transitionend works everywhere, include *both* the webkit and non-webkit events
                CSS.transitionEnd = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
            })();
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS.animation = 'WebkitAnimation';
                CSS.animationStart = 'webkitAnimationStart animationstart';
                CSS.animationEnd = 'webkitAnimationEnd animationend';
            } else {
                CSS.animation = 'animation';
                CSS.animationStart = 'animationstart';
                CSS.animationEnd = 'animationend';
            }
            dimensionCache = {};
            dimensionIds = 0;
        }
    };
});
System.register("ionic/util/events", ["angular2/angular2"], function (_export) {
    /**
     * Events is a pub/sub style event system for sending and responding to application-level
     * events across your app.
     */
    "use strict";

    var Injectable, __decorate, __metadata, Events;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Injectable = _angular2Angular2.Injectable;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Events = (function () {
                function Events() {
                    _classCallCheck(this, Events);

                    this.channels = [];
                }

                /**
                 * Subscribe to an event topic. Events that get posted to that topic
                 * will trigger the provided handler.
                 *
                 * @param topic the topic to subscribe to
                 * @param handler the event handler
                 */

                _createClass(Events, [{
                    key: "subscribe",
                    value: function subscribe(topic) {
                        var _this = this;

                        if (!this.channels[topic]) {
                            this.channels[topic] = [];
                        }

                        for (var _len = arguments.length, handlers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            handlers[_key - 1] = arguments[_key];
                        }

                        handlers.forEach(function (handler) {
                            _this.channels[topic].push(handler);
                        });
                    }

                    /**
                     * Unsubscribe from the given topic. Your handler will
                     * no longer receive events published to this topic.
                     *
                     * @param topic the topic to unsubscribe from
                     * @param handler the event handler
                     *
                     * @return true if a handler was removed
                     */
                }, {
                    key: "unsubscribe",
                    value: function unsubscribe(topic, handler) {
                        var t = this.channels[topic];
                        if (!t) {
                            // Wasn't found, wasn't removed
                            return false;
                        }
                        if (!handler) {
                            // Remove all handlers for this topic
                            delete this.channels[topic];
                            return true;
                        }
                        // We need to find and remove a specific handler
                        var i = t.indexOf(handler);
                        if (i < 0) {
                            // Wasn't found, wasn't removed
                            return false;
                        }
                        t.splice(i, 1);
                        // If the channel is empty now, remove it from the channel map
                        if (!t.length) {
                            delete this.channels[topic];
                        }
                        return true;
                    }

                    /**
                     * Publish an event to the given topic.
                     *
                     * @param topic the topic to publish to
                     * @param eventData the data to send as the event
                     */
                }, {
                    key: "publish",
                    value: function publish(topic) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                            args[_key2 - 1] = arguments[_key2];
                        }

                        var t = this.channels[topic];
                        if (!t) {
                            return null;
                        }
                        var responses = [];
                        t.forEach(function (handler) {
                            responses.push(handler(args));
                        });
                        return responses;
                    }
                }]);

                return Events;
            })();

            _export("Events", Events);

            _export("Events", Events = __decorate([Injectable(), __metadata('design:paramtypes', [])], Events));
        }
    };
});
System.register('ionic/util/focus', ['./dom'], function (_export) {
    /* Focus Outline
     * --------------------------------------------------
     * When a keydown event happens, from a tab key, then the
     * 'key-input' class is added to the body element so focusable
     * elements have an outline. On a mousedown or touchstart
     * event then the 'key-input' class is removed.
     */
    'use strict';

    var raf, ready, isKeyInputEnabled;

    function keyDown(ev) {
        if (!isKeyInputEnabled && ev.keyCode == 9) {
            isKeyInputEnabled = true;
            raf(enableKeyInput);
        }
    }
    function enableKeyInput() {
        document.body.classList[isKeyInputEnabled ? 'add' : 'remove']('key-input');
        if (isKeyInputEnabled) {
            document.addEventListener('mousedown', pointerDown);
            document.addEventListener('touchstart', pointerDown);
        } else {
            document.removeEventListener('mousedown', pointerDown);
            document.removeEventListener('touchstart', pointerDown);
        }
    }
    function pointerDown() {
        isKeyInputEnabled = false;
        raf(enableKeyInput);
    }
    return {
        setters: [function (_dom) {
            raf = _dom.raf;
            ready = _dom.ready;
        }],
        execute: function () {
            isKeyInputEnabled = false;
            ready().then(function () {
                document.addEventListener('keydown', keyDown);
            });
        }
    };
});
System.register('ionic/util/util', [], function (_export) {
    // Simple noop function
    'use strict';

    var isBoolean, isString, isNumber, isFunction, isDefined, isUndefined, isBlank, isObject, isArray, isTrueProperty, uid, Log, array;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export('noop', noop);

    /**
     * Extend the destination with an arbitrary number of other objects.
     * @param dst the destination
     * @param ... the param objects
     */

    _export('clamp', clamp);

    /**
     * Do a deep extend (merge).
     * @param dst the destination
     * @param ... the param objects
     */

    _export('extend', extend);

    _export('merge', merge);

    /**
     * Apply default arguments if they don't exist in
     * the first object.
     * @param the destination to apply defaults to.
     */

    _export('debounce', debounce);

    _export('defaults', defaults);

    _export('pascalCaseToDashCase', pascalCaseToDashCase);

    /**
     * A simple logger class.
     */

    _export('nextUid', nextUid);

    _export('getQuerystring', getQuerystring);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function noop() {}

    /**
     * Given a min and max, restrict the given number
     * to the range.
     * @param min the minimum
     * @param n the value
     * @param max the maximum
     */

    function clamp(min, n, max) {
        return Math.max(min, Math.min(n, max));
    }

    function extend(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), false);
    }

    function merge(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), true);
    }

    function _baseExtend(dst, objs, deep) {
        for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!obj || !isObject(obj) && !isFunction(obj)) continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j];
                var src = obj[key];
                if (deep && isObject(src)) {
                    if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                    _baseExtend(dst[key], [src], true);
                } else {
                    dst[key] = src;
                }
            }
        }
        return dst;
    }

    function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        return function () {
            context = this;
            args = arguments;
            timestamp = new Date();
            var later = function later() {
                var last = new Date() - timestamp;
                if (last < wait) {
                    timeout = setTimeout(later, wait - last);
                } else {
                    timeout = null;
                    if (!immediate) result = func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) result = func.apply(context, args);
            return result;
        };
    }

    function defaults(dest) {
        for (var i = arguments.length - 1; i >= 1; i--) {
            var source = arguments[i] || {};
            for (var key in source) {
                if (source.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {
                    dest[key] = source[key];
                }
            }
        }
        return dest;
    }

    /**
     * Convert a string in the format thisIsAString to a slug format this-is-a-string
     */

    function pascalCaseToDashCase() {
        var str = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

        return str.charAt(0).toLowerCase() + str.substring(1).replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
        });
    }

    function nextUid() {
        return ++uid;
    }

    /**
     * Grab the query string param value for the given key.
     * @param key the key to look for
     */

    function getQuerystring(url, key) {
        var queryParams = {};
        if (url) {
            var startIndex = url.indexOf('?');
            if (startIndex !== -1) {
                var queries = url.slice(startIndex + 1).split('&');
                if (queries.length) {
                    queries.forEach(function (param) {
                        var split = param.split('=');
                        queryParams[split[0]] = split[1].split('#')[0];
                    });
                }
            }
            if (key) {
                return queryParams[key] || '';
            }
        }
        return queryParams;
    }

    return {
        setters: [],
        execute: function () {
            ;
            isBoolean = function isBoolean(val) {
                return typeof val === 'boolean';
            };

            _export('isBoolean', isBoolean);

            isString = function isString(val) {
                return typeof val === 'string';
            };

            _export('isString', isString);

            isNumber = function isNumber(val) {
                return typeof val === 'number';
            };

            _export('isNumber', isNumber);

            isFunction = function isFunction(val) {
                return typeof val === 'function';
            };

            _export('isFunction', isFunction);

            isDefined = function isDefined(val) {
                return typeof val !== 'undefined';
            };

            _export('isDefined', isDefined);

            isUndefined = function isUndefined(val) {
                return typeof val === 'undefined';
            };

            _export('isUndefined', isUndefined);

            isBlank = function isBlank(val) {
                return val === undefined || val === null;
            };

            _export('isBlank', isBlank);

            isObject = function isObject(val) {
                return typeof val === 'object';
            };

            _export('isObject', isObject);

            isArray = Array.isArray;

            _export('isArray', isArray);

            isTrueProperty = function isTrueProperty(val) {
                return typeof val !== 'undefined' && val !== "false";
            };

            _export('isTrueProperty', isTrueProperty);

            uid = 0;

            Log = (function () {
                function Log() {
                    _classCallCheck(this, Log);
                }

                _createClass(Log, null, [{
                    key: 'log',
                    value: function log() {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        console.log.apply(console, args);
                    }
                }, {
                    key: 'info',
                    value: function info() {
                        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }

                        console.info.apply(console, args);
                    }
                }, {
                    key: 'warn',
                    value: function warn() {
                        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                            args[_key3] = arguments[_key3];
                        }

                        console.warn.apply(console, args);
                    }
                }, {
                    key: 'error',
                    value: function error() {
                        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                            args[_key4] = arguments[_key4];
                        }

                        console.error.apply(console, args);
                    }
                }]);

                return Log;
            })();

            _export('Log', Log);

            array = {
                find: function find(arr, cb) {
                    for (var i = 0, ii = arr.length; i < ii; i++) {
                        if (cb(arr[i], i)) return arr[i];
                    }
                },
                remove: function remove(arr, itemOrIndex) {
                    var index = -1;
                    if (isNumber(itemOrIndex)) {
                        index = itemOrIndex;
                    } else {
                        index = arr.indexOf(itemOrIndex);
                    }
                    if (index < 0) {
                        return false;
                    }
                    arr.splice(index, 1);
                    return true;
                }
            };

            _export('array', array);
        }
    };
});
System.register('ionic/storage/local-storage', ['./storage'], function (_export) {
    /**
     * The LocalStorage storage engine uses the browser's local storage system for
     * storing key/value pairs.
     *
     * Note: LocalStorage should ONLY be used for temporary data that you can afford to lose.
     * Given disk space constraints on a mobile device, local storage might be "cleaned up"
     * by the operating system (iOS).
     *
     * For guaranteed, long-term storage, use the SqlStorage engine which stores data in a file.
     */
    'use strict';

    var StorageEngine, LocalStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }],
        execute: function () {
            LocalStorage = (function (_StorageEngine) {
                _inherits(LocalStorage, _StorageEngine);

                function LocalStorage() {
                    _classCallCheck(this, LocalStorage);

                    _get(Object.getPrototypeOf(LocalStorage.prototype), 'constructor', this).call(this);
                }

                _createClass(LocalStorage, [{
                    key: 'get',
                    value: function get(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                var value = window.localStorage.getItem(key);
                                resolve(value);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.setItem(key, value);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.removeItem(key);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return LocalStorage;
            })(StorageEngine);

            _export('LocalStorage', LocalStorage);
        }
    };
});
System.register('ionic/storage/sql', ['./storage', 'ionic/util'], function (_export) {
    'use strict';

    var StorageEngine, util, DB_NAME, SqlStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            DB_NAME = '__ionicstorage';

            /**
             * SqlStorage uses SQLite or WebSQL (development only!) to store data in a
             * persistent SQL store on the filesystem.
             *
             * This is the preferred storage engine, as data will be stored in appropriate
             * app storage, unlike Local Storage which is treated differently by the OS.
             */

            SqlStorage = (function (_StorageEngine) {
                _inherits(SqlStorage, _StorageEngine);

                function SqlStorage(options) {
                    _classCallCheck(this, SqlStorage);

                    _get(Object.getPrototypeOf(SqlStorage.prototype), 'constructor', this).call(this);
                    var dbOptions = util.defaults({
                        name: DB_NAME,
                        backupFlag: SqlStorage.BACKUP_NONE,
                        existingDatabase: false
                    }, options);
                    if (window.sqlitePlugin) {
                        var _location = this._getBackupLocation(dbOptions);
                        this._db = window.sqlitePlugin.openDatabase(util.extend({
                            name: dbOptions.name,
                            location: _location,
                            createFromLocation: dbOptions.existingDatabase ? 1 : 0
                        }, dbOptions));
                    } else {
                        console.warn('Storage: SQLite plugin not installed, falling back to WebSQL. Make sure to install cordova-sqlite-storage in production!');
                        this._db = window.openDatabase(dbOptions.name, '1.0', 'database', 5 * 1024 * 1024);
                    }
                    this._tryInit();
                }

                _createClass(SqlStorage, [{
                    key: '_getBackupLocation',
                    value: function _getBackupLocation(dbFlag) {
                        switch (dbFlag) {
                            case SqlStorage.BACKUP_LOCAL:
                                return 2;
                            case SqlStorage.BACKUP_LIBRARY:
                                return 1;
                            case SqlStorage.BACKUP_DOCUMENTS:
                                return 0;
                            default:
                                throw Error('Invalid backup flag: ' + dbFlag);
                        }
                    }

                    // Initialize the DB with our required tables
                }, {
                    key: '_tryInit',
                    value: function _tryInit() {
                        this._db.transaction(function (tx) {
                            tx.executeSql('CREATE TABLE IF NOT EXISTS kv (key text primary key, value text)', [], function (tx, res) {}, function (tx, err) {
                                console.error('Storage: Unable to create initial storage tables', tx, err);
                            });
                        });
                    }

                    /**
                     * Perform an arbitrary SQL operation on the database. Use this method
                     * to have full control over the underlying database through SQL operations
                     * like SELECT, INSERT, and UPDATE.
                     *
                     * @param {string} query the query to run
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'query',
                    value: function query(_query) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            _this._db.transaction(function (tx) {
                                ts.executeSql(_query, [], function (tx, res) {
                                    resolve({
                                        tx: tx,
                                        res: res
                                    });
                                }, function (tx, err) {
                                    reject({
                                        tx: tx,
                                        err: err
                                    });
                                });
                            });
                        });
                    }

                    /**
                     * Get the value in the database identified by the given key.
                     * @param {string} key the key
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'get',
                    value: function get(key) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this2._db.transaction(function (tx) {
                                    tx.executeSql("select key, value from kv where key = ? limit 1", [key], function (tx, res) {
                                        if (res.rows.length > 0) {
                                            var item = res.rows.item(0);
                                            resolve(item.value);
                                        }
                                        resolve(null);
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Set the value in the database for the given key. Existing values will be overwritten.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        var _this3 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this3._db.transaction(function (tx) {
                                    tx.executeSql('insert or replace into kv(key, value) values (?, ?)', [key, value], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Remove the value in the database for the given key.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        var _this4 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this4._db.transaction(function (tx) {
                                    tx.executeSql('delete from kv where key = ?', [key], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return SqlStorage;
            })(StorageEngine);

            _export('SqlStorage', SqlStorage);

            SqlStorage.BACKUP_LOCAL = 2;
            SqlStorage.BACKUP_LIBRARY = 1;
            SqlStorage.BACKUP_DOCUMENTS = 0;
        }
    };
});
System.register('ionic/storage/storage', [], function (_export) {
    /**
     * Storage is an easy way to store key/value pairs and other complicated
     * data in a way that uses a variety of storage engines underneath.
     *
     * For most cases, we recommend the SqlStorage system as it will store
     * data in a file in the app's sandbox. LocalStorage should ONLY be used
     * for temporary data as it may be "cleaned up" by the operation system
     * during low disk space situations.
     */
    'use strict';

    var Storage, StorageEngine;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            Storage = (function () {
                function Storage(strategyCls) {
                    _classCallCheck(this, Storage);

                    this._strategy = new strategyCls();
                }

                _createClass(Storage, [{
                    key: 'get',
                    value: function get(key) {
                        return this._strategy.get(key);
                    }
                }, {
                    key: 'getJson',
                    value: function getJson(key) {
                        try {
                            return JSON.parse(this._strategy.get(key));
                        } catch (e) {
                            console.warn('Storage getJson(): unable to parse value for key', key, ' as JSON');
                            return null;
                        }
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return this._strategy.set(key, value);
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return this._strategy.remove(key);
                    }
                }, {
                    key: 'query',
                    value: function query(_query) {
                        return this._strategy.query(key);
                    }
                }]);

                return Storage;
            })();

            _export('Storage', Storage);

            StorageEngine = (function () {
                function StorageEngine() {
                    _classCallCheck(this, StorageEngine);
                }

                _createClass(StorageEngine, [{
                    key: 'get',
                    value: function get(key, value) {
                        throw Error("get() not implemented for this storage engine");
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        throw Error("set() not implemented for this storage engine");
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        throw Error("remove() not implemented for this storage engine");
                    }
                }, {
                    key: 'query',
                    value: function query(_query2) {
                        throw Error("query() not implemented for this storage engine");
                    }
                }]);

                return StorageEngine;
            })();

            _export('StorageEngine', StorageEngine);
        }
    };
});
System.register('ionic/plugins/plugin', [], function (_export) {
    'use strict';

    var NativePluginDecorator;

    _export('NativePlugin', NativePlugin);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function NativePlugin(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new NativePluginDecorator(cls, config));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    return {
        setters: [],
        execute: function () {
            NativePluginDecorator = function NativePluginDecorator(cls, config) {
                var _this = this;

                _classCallCheck(this, NativePluginDecorator);

                this.cls = cls;
                this.config = config;
                cls.ifPlugin = function (cb) {
                    var returnType = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

                    // Convert to boolean the plugin param
                    var exists = !!check;
                    if (typeof _this.config.pluginCheck === 'function') {
                        exists = _this.config.pluginCheck();
                    }
                    if (exists) {
                        return cb();
                    }
                    // We don't have the plugin, so print a warning message
                    cls.pluginWarn();
                    // If the user supplied a default return value, return it here.
                    if (returnType) {
                        return typeof returnType === 'function' ? returnType() : returnType;
                    }
                    return false;
                };
                cls.pluginWarn = function () {
                    if (cls._pluginWarned) {
                        // Only warn once
                        return;
                    }
                    var platformString = [];
                    for (var k in _this.config.engines) {
                        platformString.push('\t' + k + ': ' + _this.config.engines[k]);
                    }
                    console.warn('Plugin for ' + _this.config.name + ' not installed. For native functionality, please install the correct plugin for your platform:\n' + platformString.join('\n'));
                    // Set a flag so we don't warn again
                    cls._pluginWarned = true;
                };
            };

            _export('NativePluginDecorator', NativePluginDecorator);
        }
    };
});
System.register('ionic/plugins/plugins', ['./plugin', './applinks/applinks', './barcode/barcode', './battery/battery', './camera/camera', './contacts/contacts', './dialogs/dialogs', './device/device', './device-motion/device-motion', './device-orientation/device-orientation', './geolocation/geolocation', './keyboard/keyboard', './statusbar/statusbar', './vibration/vibration'], function (_export) {
  'use strict';

  return {
    setters: [function (_plugin) {
      for (var _key in _plugin) {
        if (_key !== 'default') _export(_key, _plugin[_key]);
      }
    }, function (_applinksApplinks) {
      for (var _key2 in _applinksApplinks) {
        if (_key2 !== 'default') _export(_key2, _applinksApplinks[_key2]);
      }
    }, function (_barcodeBarcode) {
      for (var _key3 in _barcodeBarcode) {
        if (_key3 !== 'default') _export(_key3, _barcodeBarcode[_key3]);
      }
    }, function (_batteryBattery) {
      for (var _key4 in _batteryBattery) {
        if (_key4 !== 'default') _export(_key4, _batteryBattery[_key4]);
      }
    }, function (_cameraCamera) {
      for (var _key5 in _cameraCamera) {
        if (_key5 !== 'default') _export(_key5, _cameraCamera[_key5]);
      }
    }, function (_contactsContacts) {
      for (var _key6 in _contactsContacts) {
        if (_key6 !== 'default') _export(_key6, _contactsContacts[_key6]);
      }
    }, function (_dialogsDialogs) {
      for (var _key7 in _dialogsDialogs) {
        if (_key7 !== 'default') _export(_key7, _dialogsDialogs[_key7]);
      }
    }, function (_deviceDevice) {
      for (var _key8 in _deviceDevice) {
        if (_key8 !== 'default') _export(_key8, _deviceDevice[_key8]);
      }
    }, function (_deviceMotionDeviceMotion) {
      for (var _key9 in _deviceMotionDeviceMotion) {
        if (_key9 !== 'default') _export(_key9, _deviceMotionDeviceMotion[_key9]);
      }
    }, function (_deviceOrientationDeviceOrientation) {
      for (var _key10 in _deviceOrientationDeviceOrientation) {
        if (_key10 !== 'default') _export(_key10, _deviceOrientationDeviceOrientation[_key10]);
      }
    }, function (_geolocationGeolocation) {
      for (var _key11 in _geolocationGeolocation) {
        if (_key11 !== 'default') _export(_key11, _geolocationGeolocation[_key11]);
      }
    }, function (_keyboardKeyboard) {
      for (var _key12 in _keyboardKeyboard) {
        if (_key12 !== 'default') _export(_key12, _keyboardKeyboard[_key12]);
      }
    }, function (_statusbarStatusbar) {
      for (var _key13 in _statusbarStatusbar) {
        if (_key13 !== 'default') _export(_key13, _statusbarStatusbar[_key13]);
      }
    }, function (_vibrationVibration) {
      for (var _key14 in _vibrationVibration) {
        if (_key14 !== 'default') _export(_key14, _vibrationVibration[_key14]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/components/action-sheet/action-sheet", ["angular2/angular2", "../icon/icon", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
    * @ngdoc service
    * @name ActionSheet
    * @module ionic
    * @description
    * The ActionSheet is a modal menu with options to select based on an action.
    */

    /**
     * @name ActionSheet
     * @description
     * The Action Sheet is a slide-up pane that lets the user choose from a set of options. Dangerous options are made obvious.
     *
     * There are easy ways to cancel out of the action sheet, such as tapping the backdrop or even hitting escape on the keyboard for desktop testing.
     *
     * @usage
     * ```ts
     * openMenu() {
     *
     *   this.actionSheet.open({
     *     buttons: [
     *       { text: 'Share This' },
     *       { text: 'Move' }
     *     ],
     *     destructiveText: 'Delete',
     *     titleText: 'Modify your album',
     *     cancelText: 'Cancel',
     *     cancel: function() {
     *       console.log('Canceled');
     *     },
     *     destructiveButtonClicked: () => {
     *       console.log('Destructive clicked');
     *     },
     *     buttonClicked: function(index) {
     *       console.log('Button clicked', index);
     *       if(index == 1) { return false; }
     *       return true;
     *     }
     *
     *   }).then(actionSheetRef => {
     *     this.actionSheetRef = actionSheetRef;
     *   });
     *
     * }
     * ```
     */
    "use strict";

    var View, Injectable, NgFor, NgIf, Icon, Overlay, Animation, util, __decorate, __metadata, ActionSheetDirective, ActionSheet, OVERLAY_TYPE, ActionSheetAnimation, ActionSheetSlideIn, ActionSheetSlideOut, ActionSheetMdSlideIn, ActionSheetMdSlideOut;

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            NgFor = _angular2Angular2.NgFor;
            NgIf = _angular2Angular2.NgIf;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ActionSheetDirective = (function () {
                function ActionSheetDirective() {
                    _classCallCheck(this, ActionSheetDirective);
                }

                _createClass(ActionSheetDirective, [{
                    key: "_cancel",
                    value: function _cancel() {
                        this.cancel && this.cancel();
                        return this.overlayRef.close();
                    }
                }, {
                    key: "_destructive",
                    value: function _destructive() {
                        var shouldClose = this.destructiveButtonClicked();
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_buttonClicked",
                    value: function _buttonClicked(index) {
                        var shouldClose = this.buttonClicked(index);
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return ActionSheetDirective;
            })();

            ActionSheetDirective = __decorate([View({
                template: '<backdrop (click)="_cancel()" tappable></backdrop>' + '<action-sheet-wrapper>' + '<div class="action-sheet-container">' + '<div class="action-sheet-group action-sheet-options">' + '<div class="action-sheet-title" *ng-if="titleText">{{titleText}}</div>' + '<button (click)="_buttonClicked(index)" *ng-for="#b of buttons; #index = index" class="action-sheet-option">' + '<icon [name]="b.icon" *ng-if="b.icon"></icon> ' + '{{b.text}}' + '</button>' + '<button *ng-if="destructiveText" (click)="_destructive()" class="destructive action-sheet-destructive">' + '<icon [name]="destructiveIcon" *ng-if="destructiveIcon"></icon> ' + '{{destructiveText}}</button>' + '</div>' + '<div class="action-sheet-group action-sheet-cancel" *ng-if="cancelText">' + '<button (click)="_cancel()">' + '<icon [name]="cancelIcon"></icon> ' + '{{cancelText}}</button>' + '</div>' + '</div>' + '</action-sheet-wrapper>',
                directives: [NgFor, NgIf, Icon]
            }), __metadata('design:paramtypes', [])], ActionSheetDirective);

            ActionSheet = (function (_Overlay) {
                _inherits(ActionSheet, _Overlay);

                function ActionSheet() {
                    _classCallCheck(this, ActionSheet);

                    _get(Object.getPrototypeOf(ActionSheet.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(ActionSheet, [{
                    key: "open",

                    /**
                     * Create and open a new Action Sheet. This is the
                     * public API, and most often you will only use ActionSheet.open()
                     *
                     * @param {Object} [opts={}]  TODO
                     * @return {Promise} Promise that resolves when the action sheet is open.
                     */
                    value: function open() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        var config = this.config;
                        var defaults = {
                            enterAnimation: config.setting('actionSheetEnter'),
                            leaveAnimation: config.setting('actionSheetLeave'),
                            cancelIcon: config.setting('actionSheetCancelIcon'),
                            destructiveIcon: config.setting('actionSheetDestructiveIcon')
                        };
                        var context = util.extend(defaults, opts);
                        return this.create(OVERLAY_TYPE, ActionSheetDirective, context, context);
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "get",
                    value: function get() {
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return ActionSheet;
            })(Overlay);

            _export("ActionSheet", ActionSheet);

            _export("ActionSheet", ActionSheet = __decorate([Injectable(), __metadata('design:paramtypes', [])], ActionSheet));
            OVERLAY_TYPE = 'action-sheet';

            /**
             * Animations for action sheet
             */

            ActionSheetAnimation = (function (_Animation) {
                _inherits(ActionSheetAnimation, _Animation);

                function ActionSheetAnimation(element) {
                    _classCallCheck(this, ActionSheetAnimation);

                    _get(Object.getPrototypeOf(ActionSheetAnimation.prototype), "constructor", this).call(this, element);
                    this.easing('cubic-bezier(.36, .66, .04, 1)').duration(450);
                    this.backdrop = new Animation(element.querySelector('backdrop'));
                    this.wrapper = new Animation(element.querySelector('action-sheet-wrapper'));
                    this.add(this.backdrop, this.wrapper);
                }

                return ActionSheetAnimation;
            })(Animation);

            ActionSheetSlideIn = (function (_ActionSheetAnimation) {
                _inherits(ActionSheetSlideIn, _ActionSheetAnimation);

                function ActionSheetSlideIn(element) {
                    _classCallCheck(this, ActionSheetSlideIn);

                    _get(Object.getPrototypeOf(ActionSheetSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.01, 0.4);
                    this.wrapper.fromTo('translateY', '100%', '0%');
                }

                return ActionSheetSlideIn;
            })(ActionSheetAnimation);

            Animation.register('action-sheet-slide-in', ActionSheetSlideIn);

            ActionSheetSlideOut = (function (_ActionSheetAnimation2) {
                _inherits(ActionSheetSlideOut, _ActionSheetAnimation2);

                function ActionSheetSlideOut(element) {
                    _classCallCheck(this, ActionSheetSlideOut);

                    _get(Object.getPrototypeOf(ActionSheetSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.4, 0.01);
                    this.wrapper.fromTo('translateY', '0%', '100%');
                }

                return ActionSheetSlideOut;
            })(ActionSheetAnimation);

            Animation.register('action-sheet-slide-out', ActionSheetSlideOut);

            ActionSheetMdSlideIn = (function (_ActionSheetSlideIn) {
                _inherits(ActionSheetMdSlideIn, _ActionSheetSlideIn);

                function ActionSheetMdSlideIn(element) {
                    _classCallCheck(this, ActionSheetMdSlideIn);

                    _get(Object.getPrototypeOf(ActionSheetMdSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.01, 0.26);
                }

                return ActionSheetMdSlideIn;
            })(ActionSheetSlideIn);

            Animation.register('action-sheet-md-slide-in', ActionSheetMdSlideIn);

            ActionSheetMdSlideOut = (function (_ActionSheetSlideOut) {
                _inherits(ActionSheetMdSlideOut, _ActionSheetSlideOut);

                function ActionSheetMdSlideOut(element) {
                    _classCallCheck(this, ActionSheetMdSlideOut);

                    _get(Object.getPrototypeOf(ActionSheetMdSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.26, 0.01);
                }

                return ActionSheetMdSlideOut;
            })(ActionSheetSlideOut);

            Animation.register('action-sheet-md-slide-out', ActionSheetMdSlideOut);
        }
    };
});
System.register('ionic/components/app/activator', ['../../util/dom'], function (_export) {
    'use strict';

    var raf, pointerCoord, hasPointerMoved, Activator;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            raf = _utilDom.raf;
            pointerCoord = _utilDom.pointerCoord;
            hasPointerMoved = _utilDom.hasPointerMoved;
        }],
        execute: function () {
            Activator = (function () {
                function Activator(app, config, window, document) {
                    _classCallCheck(this, Activator);

                    var self = this;
                    self.app = app;
                    self.config = config;
                    self.win = window;
                    self.doc = document;
                    self.id = 0;
                    self.queue = {};
                    self.active = {};
                    self.activatedClass = 'activated';
                    self.deactivateTimeout = 180;
                    self.deactivateAttempt = 0;
                    self.pointerTolerance = 4;
                    self.isTouch = false;
                    self.disableClick = 0;
                    self.disableClickLimit = 2500;
                    self.tapPolyfill = config.setting('tapPolyfill');
                    function bindDom(type, listener, useCapture) {
                        document.addEventListener(type, listener, useCapture);
                    }
                    bindDom('click', function (ev) {
                        self.click(ev);
                    }, true);
                    bindDom('touchstart', function (ev) {
                        self.isTouch = true;
                        self.pointerStart(ev);
                    });
                    bindDom('touchend', function (ev) {
                        self.isTouch = true;
                        self.touchEnd(ev);
                    });
                    bindDom('touchcancel', function (ev) {
                        self.isTouch = true;
                        self.pointerCancel(ev);
                    });
                    bindDom('mousedown', function (ev) {
                        self.mouseDown(ev);
                    }, true);
                    bindDom('mouseup', function (ev) {
                        self.mouseUp(ev);
                    }, true);
                    self.pointerMove = function (ev) {
                        var moveCoord = pointerCoord(ev);
                        if (hasPointerMoved(10, self.start, moveCoord)) {
                            self.pointerCancel();
                        }
                    };
                    self.moveListeners = function (shouldAdd) {
                        document.removeEventListener('touchmove', self.pointerMove);
                        document.removeEventListener('mousemove', self.pointerMove);
                        if (shouldAdd) {
                            bindDom('touchmove', self.pointerMove);
                            bindDom('mousemove', self.pointerMove);
                        }
                    };
                }

                /**
                 * TODO
                 * @param {TODO} ev  TODO
                 */

                _createClass(Activator, [{
                    key: 'touchEnd',
                    value: function touchEnd(ev) {
                        var self = this;
                        if (self.tapPolyfill && self.start && !self.app.isTransitioning()) {
                            var endCoord = pointerCoord(ev);
                            if (!hasPointerMoved(self.pointerTolerance, self.start, endCoord)) {
                                console.debug('create click');
                                self.disableClick = Date.now();
                                var clickEvent = self.doc.createEvent('MouseEvents');
                                clickEvent.initMouseEvent('click', true, true, self.win, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
                                clickEvent.isIonicTap = true;
                                ev.target.dispatchEvent(clickEvent);
                            }
                        }
                        self.pointerEnd(ev);
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseDown',
                    value: function mouseDown(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseDown prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else if (!self.isTouch) {
                            this.pointerStart(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseUp',
                    value: function mouseUp(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseUp prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        if (!self.isTouch) {
                            this.pointerEnd(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'pointerStart',
                    value: function pointerStart(ev) {
                        var targetEle = this.getActivatableTarget(ev.target);
                        if (targetEle && !this.app.isTransitioning()) {
                            this.start = pointerCoord(ev);
                            this.queueActivate(targetEle);
                            this.moveListeners(true);
                        } else {
                            this.start = null;
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerEnd',
                    value: function pointerEnd(ev) {
                        this.queueDeactivate();
                        this.moveListeners(false);
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerCancel',
                    value: function pointerCancel() {
                        console.debug('pointerCancel');
                        this.deactivate();
                        this.moveListeners(false);
                        this.disableClick = Date.now();
                    }
                }, {
                    key: 'isDisabledClick',
                    value: function isDisabledClick() {
                        return this.disableClick + this.disableClickLimit > Date.now();
                    }

                    /**
                     * Whether the supplied click event should be allowed or not.
                     * @param {MouseEvent} ev  The click event.
                     * @return {boolean} True if click event should be allowed, otherwise false.
                     */
                }, {
                    key: 'allowClick',
                    value: function allowClick(ev) {
                        if (this.app.isTransitioning()) {
                            return false;
                        }
                        if (!ev.isIonicTap) {
                            if (this.isDisabledClick()) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * TODO
                     * @param {MouseEvent} ev  TODO
                     */
                }, {
                    key: 'click',
                    value: function click(ev) {
                        if (!this.allowClick(ev)) {
                            console.debug('click prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        this.isTouch = false;
                    }
                }, {
                    key: 'getActivatableTarget',
                    value: function getActivatableTarget(ele) {
                        var targetEle = ele;
                        for (var x = 0; x < 4; x++) {
                            if (!targetEle) break;
                            if (this.isActivatable(targetEle)) return targetEle;
                            targetEle = targetEle.parentElement;
                        }
                        return null;
                    }
                }, {
                    key: 'isActivatable',
                    value: function isActivatable(ele) {
                        if (/^(A|BUTTON)$/.test(ele.tagName)) {
                            return true;
                        }
                        var attributes = ele.attributes;
                        for (var i = 0, l = attributes.length; i < l; i++) {
                            if (/click|tappable/.test(attributes[i].name)) {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'queueActivate',
                    value: function queueActivate(ele) {
                        var self = this;
                        self.queue[++self.id] = ele;
                        if (self.id > 19) self.id = 0;
                        raf(function () {
                            // activate all elements in the queue
                            for (var key in self.queue) {
                                if (self.queue[key]) {
                                    self.queue[key].classList.add(self.activatedClass);
                                    self.active[key] = self.queue[key];
                                }
                            }
                            self.queue = {};
                        });
                    }
                }, {
                    key: 'queueDeactivate',
                    value: function queueDeactivate() {
                        var self = this;
                        setTimeout(function () {
                            self.deactivate();
                        }, self.deactivateTimeout);
                    }
                }, {
                    key: 'deactivate',
                    value: function deactivate() {
                        var self = this;
                        if (self.app.isTransitioning() && self.deactivateAttempt < 30) {
                            // the app is actively transitioning, don't bother deactivating
                            // anything this makes it easier on the GPU so it doesn't
                            // have to redraw any buttons during a transition
                            // retry
                            ++self.deactivateAttempt;
                            self.queueDeactivate();
                        } else {
                            // not actively transitioning, good to deactivate any elements
                            // clear out any elements that are queued to be set to active
                            self.queue = {};
                            // in the next frame, remove the active class from all active elements
                            raf(function () {
                                for (var key in self.active) {
                                    if (self.active[key]) {
                                        self.active[key].classList.remove(self.activatedClass);
                                    }
                                    delete self.active[key];
                                }
                            });
                            self.deactivateAttempt = 0;
                        }
                    }
                }]);

                return Activator;
            })();

            _export('Activator', Activator);
        }
    };
});
System.register("ionic/components/app/app", ["angular2/angular2", "angular2/router", "../../config/config", "../../platform/platform", "../../util/click-block", "../../util/dom", "../tap-click/tap-click", "../action-sheet/action-sheet", "../modal/modal", "../popup/popup", "../form/focus-holder", "../../util/events", "../nav/nav-registry"], function (_export) {
    /**
     * @name IonicApp
     * @description
     * Service exposing the Ionic app level API.
     *
     * @usage
     * ```js
     *  @App({
     *    templateUrl: '/app/app.html',
     *  })
     *  class MyApp {
     *
     *    constructor(app: IonicApp) {
     *      this.app = app;
     *    }
     *  }
     *  ```
     * Note: Ionic sets `ion-app` as the selector for the app. Setting a custom selector will override this and cause CSS problems.
     *
     */
    "use strict";

    var Component, View, bootstrap, ElementRef, NgZone, bind, DynamicComponentLoader, Injector, ROUTER_BINDINGS, HashLocationStrategy, LocationStrategy, IonicConfig, IonicPlatform, ClickBlock, dom, TapClick, ActionSheet, Modal, Popup, FocusHolder, Events, NavRegistry, __decorate, __metadata, IonicApp, RootAnchor, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export("ionicBootstrap", ionicBootstrap);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function initApp(window, document, config, platform) {
        // create the base IonicApp
        var app = new IonicApp();
        app.isRTL(document.dir == 'rtl');
        // load all platform data
        platform.url(window.location.href);
        platform.userAgent(window.navigator.userAgent);
        platform.navigatorPlatform(window.navigator.platform);
        platform.load(config);
        // copy default platform settings into the user config platform settings
        // user config platform settings should override default platform settings
        config.setPlatform(platform);
        // config and platform settings have been figured out
        // apply the correct CSS to the app
        applyBodyCss(document, config, platform);
        // prepare the ready promise to fire....when ready
        platform.prepareReady(config);
        setTimeout(function () {
            // start listening for resizes XXms after the app starts
            window.addEventListener('resize', function () {
                platform.windowResize();
            });
        }, 2500);
        return app;
    }
    /**
     * TODO
     *
     * @param {TODO} rootComponentType  TODO
     * @param {TODO} config  TODO
     * @return {Promise} TODO
     */

    function ionicBootstrap(rootComponentType, views, config) {
        return new Promise(function (resolve) {
            try {
                (function () {
                    // get the user config, or create one if wasn't passed in
                    if (typeof config !== IonicConfig) {
                        config = new IonicConfig(config);
                    }
                    var platform = new IonicPlatform();
                    // create the base IonicApp
                    var app = initApp(window, document, config, platform);
                    // TODO: probs need a better way to inject global injectables
                    var tapClick = new TapClick(app, config, window, document);
                    var actionSheet = new ActionSheet(app, config);
                    var modal = new Modal(app, config);
                    var popup = new Popup(app, config);
                    var events = new Events();
                    var navRegistry = new NavRegistry(views);
                    // add injectables that will be available to all child components
                    var appBindings = Injector.resolve([bind(IonicApp).toValue(app), bind(IonicConfig).toValue(config), bind(IonicPlatform).toValue(platform), bind(TapClick).toValue(tapClick), bind(ActionSheet).toValue(actionSheet), bind(Modal).toValue(modal), bind(Popup).toValue(popup), bind(Events).toValue(events), ROUTER_BINDINGS, bind(LocationStrategy).toClass(HashLocationStrategy), bind(NavRegistry).toValue(navRegistry)]);
                    bootstrap(rootComponentType, appBindings).then(function (appRef) {
                        app.load(appRef);
                        // Adding a anchor to add overlays off of...huh??
                        var elementRefs = appRef._hostComponent.hostView._view.elementRefs;
                        var lastElementRef = elementRefs[1];
                        var injector = lastElementRef.parentView._view.rootElementInjectors[0]._injector;
                        var loader = injector.get(DynamicComponentLoader);
                        loader.loadNextToLocation(RootAnchor, lastElementRef).then(function () {
                            // append the focus holder if its needed
                            if (config.setting('keyboardScrollAssist')) {
                                app.appendComponent(FocusHolder).then(function (ref) {
                                    app.focusHolder(ref.instance);
                                });
                            }
                        })["catch"](function (err) {
                            console.error(err);
                        });
                        resolve(app);
                    })["catch"](function (err) {
                        console.error('ionicBootstrap', err);
                    });
                })();
            } catch (err) {
                console.error(err);
            }
        });
    }

    function applyBodyCss(document, config, platform) {
        var bodyEle = document.body;
        if (!bodyEle) {
            return dom.ready(function () {
                applyBodyCss(document, config, platform);
            });
        }
        var versions = platform.versions();
        platform.platforms().forEach(function (platformName) {
            // platform-ios
            var platformClass = 'platform-' + platformName;
            bodyEle.classList.add(platformClass);
            var platformVersion = versions[platformName];
            if (platformVersion) {
                // platform-ios9
                platformClass += platformVersion.major;
                bodyEle.classList.add(platformClass);
                // platform-ios9_3
                bodyEle.classList.add(platformClass + '_' + platformVersion.minor);
            }
        });
        // set the mode class name
        // ios
        bodyEle.classList.add(config.setting('mode'));
        // touch devices should not use :hover CSS pseudo
        // enable :hover CSS when the "hoverCSS" setting is not false
        if (config.setting('hoverCSS') !== false) {
            bodyEle.classList.add('enable-hover');
        }
        /**
        * Hairline Shim
        * Add the "hairline" CSS class name to the body tag
        * if the browser supports subpixels.
        */
        if (window.devicePixelRatio >= 2) {
            var hairlineEle = document.createElement('div');
            hairlineEle.style.border = '.5px solid transparent';
            bodyEle.appendChild(hairlineEle);
            if (hairlineEle.offsetHeight === 1) {
                bodyEle.classList.add('hairlines');
            }
            bodyEle.removeChild(hairlineEle);
        }
    }
    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            bootstrap = _angular2Angular2.bootstrap;
            ElementRef = _angular2Angular2.ElementRef;
            NgZone = _angular2Angular2.NgZone;
            bind = _angular2Angular2.bind;
            DynamicComponentLoader = _angular2Angular2.DynamicComponentLoader;
            Injector = _angular2Angular2.Injector;
        }, function (_angular2Router) {
            ROUTER_BINDINGS = _angular2Router.ROUTER_BINDINGS;
            HashLocationStrategy = _angular2Router.HashLocationStrategy;
            LocationStrategy = _angular2Router.LocationStrategy;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_platformPlatform) {
            IonicPlatform = _platformPlatform.IonicPlatform;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_utilDom) {
            dom = _utilDom;
        }, function (_tapClickTapClick) {
            TapClick = _tapClickTapClick.TapClick;
        }, function (_actionSheetActionSheet) {
            ActionSheet = _actionSheetActionSheet.ActionSheet;
        }, function (_modalModal) {
            Modal = _modalModal.Modal;
        }, function (_popupPopup) {
            Popup = _popupPopup.Popup;
        }, function (_formFocusHolder) {
            FocusHolder = _formFocusHolder.FocusHolder;
        }, function (_utilEvents) {
            Events = _utilEvents.Events;
        }, function (_navNavRegistry) {
            NavRegistry = _navNavRegistry.NavRegistry;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IonicApp = (function () {
                /**
                 * TODO
                 */

                function IonicApp() {
                    _classCallCheck(this, IonicApp);

                    this.overlays = [];
                    this._disTime = 0;
                    this._trnsTime = 0;
                    // Our component registry map
                    this.components = {};
                }

                /**
                 * TODO
                 * @param {Object} appRef  TODO
                 */

                _createClass(IonicApp, [{
                    key: "load",
                    value: function load(appRef) {
                        this.ref(appRef);
                        this._zone = appRef.injector.get(NgZone);
                    }

                    /**
                     * TODO
                     * @param {TODO=} val  TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "focusHolder",
                    value: function focusHolder(val) {
                        if (arguments.length) {
                            this._fcsHldr = val;
                        }
                        return this._fcsHldr;
                    }

                    /**
                     * Sets the document title.
                     * @param {string} val  Value to set the document title to.
                     */
                }, {
                    key: "title",
                    value: function title(val) {
                        // TODO: User angular service
                        document.title = val;
                    }

                    /**
                     * Sets if the app is currently enabled or not, meaning if it's
                     * available to accept new user commands. For example, this is set to `false`
                     * while views transition, a modal slides up, an action-sheet
                     * slides up, etc. After the transition completes it is set back to `true`.
                     * @param {bool} isEnabled
                     * @param {bool} fallback  When `isEnabled` is set to `false`, this argument
                     * is used to set the maximum number of milliseconds that app will wait until
                     * it will automatically enable the app again. It's basically a fallback incase
                     * something goes wrong during a transition and the app wasn't re-enabled correctly.
                     */
                }, {
                    key: "setEnabled",
                    value: function setEnabled(isEnabled) {
                        var fallback = arguments.length <= 1 || arguments[1] === undefined ? 700 : arguments[1];

                        this._disTime = isEnabled ? 0 : Date.now() + fallback;
                        ClickBlock(!isEnabled, fallback + 100);
                    }

                    /**
                     * Boolean if the app is actively enabled or not.
                     * @return {bool}
                     */
                }, {
                    key: "isEnabled",
                    value: function isEnabled() {
                        return this._disTime < Date.now();
                    }
                }, {
                    key: "setTransitioning",
                    value: function setTransitioning(isTransitioning) {
                        var fallback = arguments.length <= 1 || arguments[1] === undefined ? 700 : arguments[1];

                        this._trnsTime = isTransitioning ? Date.now() + fallback : 0;
                    }

                    /**
                     * Boolean if the app is actively transitioning or not.
                     * @return {bool}
                     */
                }, {
                    key: "isTransitioning",
                    value: function isTransitioning() {
                        return this._trnsTime > Date.now();
                    }

                    /**
                     * TODO
                     * @param {TODO=} val  TODO
                     * @return TODO
                     */
                }, {
                    key: "ref",
                    value: function ref(val) {
                        if (arguments.length) {
                            this._ref = val;
                        }
                        return this._ref;
                    }

                    /**
                     * TODO
                     * @return TODO
                     */
                }, {
                    key: "zoneRun",

                    /**
                     * TODO
                     * @param {Function} fn  TODO
                     */
                    value: function zoneRun(fn) {
                        this._zone.run(fn);
                    }

                    /**
                     * TODO
                     * @param {Function} fn  TODO
                     */
                }, {
                    key: "zoneRunOutside",
                    value: function zoneRunOutside(fn) {
                        this._zone.runOutsideAngular(fn);
                    }

                    /**
                     * Register a known component with a key, for easy lookups later.
                     * @param {TODO} id  The id to use to register the component
                     * @param {TODO} component  The component to register
                     */
                }, {
                    key: "register",
                    value: function register(id, component) {
                        if (this.components[id] && this.components[id] !== component) {
                            console.error('Component id "' + id + '" already registered.');
                        }
                        this.components[id] = component;
                    }

                    /**
                     * Unregister a known component with a key.
                     * @param {TODO} id  The id to use to unregister
                     */
                }, {
                    key: "unregister",
                    value: function unregister(id) {
                        delete this.components[id];
                    }

                    /**
                     * Get a registered component with the given type (returns the first)
                     * @param {Object} cls the type to search for
                     * @return the matching component, or undefined if none was found
                     */
                }, {
                    key: "getRegisteredComponent",
                    value: function getRegisteredComponent(cls) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var component = _step.value;

                                if (component instanceof cls) {
                                    return component;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }

                    /**
                     * Get the component for the given key.
                     * @param {TODO} key  TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "getComponent",
                    value: function getComponent(id) {
                        return this.components[id];
                    }

                    /**
                     * Create and append the given component into the root
                     * element of the app.
                     *
                     * @param {TODO} componentType the component to create and insert
                     * @return {Promise} Promise that resolves with the ContainerRef created
                     */
                }, {
                    key: "appendComponent",
                    value: function appendComponent(componentType) {
                        return this.rootAnchor.append(componentType);
                    }

                    /**
                     * If val is defined, specifies whether app text is RTL.  If val is undefined
                     * returns whether app text is RTL.
                     *
                     * @param {boolean=} val  Boolean specifying whether text is RTL or not.
                     * @returns {boolean} true if app text is RTL, false if otherwise.
                     */
                }, {
                    key: "isRTL",
                    value: function isRTL(val) {
                        if (arguments.length) {
                            this._rtl = val;
                        }
                        return this._rtl;
                    }
                }, {
                    key: "injector",
                    get: function get() {
                        return this._ref.injector;
                    }
                }]);

                return IonicApp;
            })();

            _export("IonicApp", IonicApp);

            RootAnchor = (function () {
                function RootAnchor(app, elementRef, loader) {
                    _classCallCheck(this, RootAnchor);

                    this.elementRef = elementRef;
                    this.loader = loader;
                    app.rootAnchor = this;
                }

                _createClass(RootAnchor, [{
                    key: "append",
                    value: function append(componentType) {
                        return this.loader.loadNextToLocation(componentType, this.elementRef)["catch"](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return RootAnchor;
            })();

            RootAnchor = __decorate([Component({
                selector: 'root-anchor'
            }), View({
                template: ''
            }), __metadata('design:paramtypes', [IonicApp, typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof DynamicComponentLoader !== 'undefined' && DynamicComponentLoader) === 'function' && _b || Object])], RootAnchor);
        }
    };
});
System.register("ionic/components/app/id", ["angular2/angular2", "./app"], function (_export) {
    /**
     * IdRef is an easy way to identify unique components in an app and access them
     * no matter where in the UI heirarchy you are. For example, this makes toggling
     * a global side menu feasible from any place in the application.
     */
    "use strict";

    var AppViewManager, ElementRef, Directive, IonicApp, __decorate, __metadata, IdRef, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            AppViewManager = _angular2Angular2.AppViewManager;
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
        }, function (_app) {
            IonicApp = _app.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IdRef = (function () {
                function IdRef(app, elementRef, appViewManager) {
                    _classCallCheck(this, IdRef);

                    this.app = app;
                    this.elementRef = elementRef;
                    this.appViewManager = appViewManager;
                    // Grab the component this directive is attached to
                    this.component = appViewManager.getComponent(elementRef);
                }

                _createClass(IdRef, [{
                    key: "onInit",
                    value: function onInit() {
                        this.app.register(this.id, this.component);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.app.unregister(this.id);
                    }
                }]);

                return IdRef;
            })();

            _export("IdRef", IdRef);

            _export("IdRef", IdRef = __decorate([Directive({
                selector: '[id]',
                properties: ['id']
            }), __metadata('design:paramtypes', [typeof (_a = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof AppViewManager !== 'undefined' && AppViewManager) === 'function' && _c || Object])], IdRef));
        }
    };
});
System.register("ionic/components/app/register", ["angular2/angular2", "./app"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, Self, IonicApp, __decorate, __metadata, __param, Register, Ref;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Self = _angular2Angular2.Self;
        }, function (_app) {
            IonicApp = _app.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Register = (function () {
                /**
                 * TODO
                 * @param {Object} app  TODO
                 */

                function Register(app) {
                    _classCallCheck(this, Register);

                    this.app = app;
                }

                /**
                 * TODO
                 */

                _createClass(Register, [{
                    key: "onInit",
                    value: function onInit() {
                        if (this.register && this.registerId) {
                            this.app.register(this.registerId, this.register);
                        }
                    }
                }]);

                return Register;
            })();

            _export("Register", Register);

            _export("Register", Register = __decorate([Directive({
                selector: '[register]',
                properties: ['register', 'registerId: register-id'],
                host: {
                    'this.register-id': 'registerId'
                }
            }), __metadata('design:paramtypes', [typeof IonicApp !== 'undefined' && IonicApp || Object])], Register));
            /**
             * TODO
             */

            Ref = (function () {
                /**
                 * TODO
                 * @param {TODO} app  TODO
                 * @param {TODO} component  TODO
                 */

                function Ref(app, component) {
                    _classCallCheck(this, Ref);

                    this.app = app;
                    console.log('Register on any', component);
                }

                /**
                 * TODO
                 */

                _createClass(Ref, [{
                    key: "onInit",
                    value: function onInit() {
                        /*
                        if (this.register && this.registerId) {
                          this.app.register(this.registerId, this.register);
                        }
                        */
                    }
                }]);

                return Ref;
            })();

            _export("Ref", Ref);

            _export("Ref", Ref = __decorate([Directive({
                selector: '[ref]',
                properties: ['ref'],
                host: {
                    'this.ref': 'refId'
                }
            }), __param(1, Self()), __metadata('design:paramtypes', [typeof IonicApp !== 'undefined' && IonicApp || Object, Object])], Ref));
        }
    };
});
System.register("ionic/components/action-menu/action-menu", ["angular2/angular2", "../icon/icon", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
    * @ngdoc service
    * @name ActionMenu
    * @module ionic
    * @description
    * The ActionMenu is a modal menu with options to select based on an action.
    */

    /**
     * @name ActionMenu
     * @description
     * The Action Menu is a slide-up pane that lets the user choose from a set of options. Dangerous options are made obvious.
     *
     * There are easy ways to cancel out of the action sheet, such as tapping the backdrop or even hitting escape on the keyboard for desktop testing.
     *
     * @usage
     * ```ts
     * openMenu() {
     *
     *   this.actionMenu.open({
     *     buttons: [
     *       { text: 'Share This' },
     *       { text: 'Move' }
     *     ],
     *     destructiveText: 'Delete',
     *     titleText: 'Modify your album',
     *     cancelText: 'Cancel',
     *     cancel: function() {
     *       console.log('Canceled');
     *     },
     *     destructiveButtonClicked: () => {
     *       console.log('Destructive clicked');
     *     },
     *     buttonClicked: function(index) {
     *       console.log('Button clicked', index);
     *       if(index == 1) { return false; }
     *       return true;
     *     }
     *
     *   }).then(actionMenuRef => {
     *     this.actionMenuRef = actionMenuRef;
     *   });
     *
     * }
     * ```
     */
    "use strict";

    var View, Injectable, NgFor, NgIf, Icon, Overlay, Animation, util, __decorate, __metadata, ActionMenuDirective, ActionMenu, OVERLAY_TYPE, ActionMenuAnimation, ActionMenuSlideIn, ActionMenuSlideOut, ActionMenuMdSlideIn, ActionMenuMdSlideOut;

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            NgFor = _angular2Angular2.NgFor;
            NgIf = _angular2Angular2.NgIf;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ActionMenuDirective = (function () {
                function ActionMenuDirective() {
                    _classCallCheck(this, ActionMenuDirective);
                }

                _createClass(ActionMenuDirective, [{
                    key: "_cancel",
                    value: function _cancel() {
                        this.cancel && this.cancel();
                        return this.overlayRef.close();
                    }
                }, {
                    key: "_destructive",
                    value: function _destructive() {
                        var shouldClose = this.destructiveButtonClicked();
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_buttonClicked",
                    value: function _buttonClicked(index) {
                        var shouldClose = this.buttonClicked(index);
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return ActionMenuDirective;
            })();

            ActionMenuDirective = __decorate([View({
                template: '<backdrop (click)="_cancel()" tappable></backdrop>' + '<action-menu-wrapper>' + '<div class="action-menu-container">' + '<div class="action-menu-group action-menu-options">' + '<div class="action-menu-title" *ng-if="titleText">{{titleText}}</div>' + '<button (click)="_buttonClicked(index)" *ng-for="#b of buttons; #index = index" class="action-menu-option">' + '<icon [name]="b.icon" *ng-if="b.icon"></icon> ' + '{{b.text}}' + '</button>' + '<button *ng-if="destructiveText" (click)="_destructive()" class="destructive action-menu-destructive">' + '<icon [name]="destructiveIcon" *ng-if="destructiveIcon"></icon> ' + '{{destructiveText}}</button>' + '</div>' + '<div class="action-menu-group action-menu-cancel" *ng-if="cancelText">' + '<button (click)="_cancel()">' + '<icon [name]="cancelIcon"></icon> ' + '{{cancelText}}</button>' + '</div>' + '</div>' + '</action-menu-wrapper>',
                directives: [NgFor, NgIf, Icon]
            }), __metadata('design:paramtypes', [])], ActionMenuDirective);

            ActionMenu = (function (_Overlay) {
                _inherits(ActionMenu, _Overlay);

                function ActionMenu() {
                    _classCallCheck(this, ActionMenu);

                    _get(Object.getPrototypeOf(ActionMenu.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(ActionMenu, [{
                    key: "open",

                    /**
                     * Create and open a new Action Menu. This is the
                     * public API, and most often you will only use ActionMenu.open()
                     *
                     * @param {Object} [opts={}]  TODO
                     * @return {Promise} Promise that resolves when the action menu is open.
                     */
                    value: function open() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        var config = this.config;
                        var defaults = {
                            enterAnimation: config.setting('actionMenuEnter'),
                            leaveAnimation: config.setting('actionMenuLeave'),
                            cancelIcon: config.setting('actionMenuCancelIcon'),
                            destructiveIcon: config.setting('actionMenuDestructiveIcon')
                        };
                        var context = util.extend(defaults, opts);
                        return this.create(OVERLAY_TYPE, ActionMenuDirective, context, context);
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "get",
                    value: function get() {
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return ActionMenu;
            })(Overlay);

            _export("ActionMenu", ActionMenu);

            _export("ActionMenu", ActionMenu = __decorate([Injectable(), __metadata('design:paramtypes', [])], ActionMenu));
            OVERLAY_TYPE = 'action-menu';

            /**
             * Animations for action sheet
             */

            ActionMenuAnimation = (function (_Animation) {
                _inherits(ActionMenuAnimation, _Animation);

                function ActionMenuAnimation(element) {
                    _classCallCheck(this, ActionMenuAnimation);

                    _get(Object.getPrototypeOf(ActionMenuAnimation.prototype), "constructor", this).call(this, element);
                    this.easing('cubic-bezier(.36, .66, .04, 1)').duration(450);
                    this.backdrop = new Animation(element.querySelector('backdrop'));
                    this.wrapper = new Animation(element.querySelector('action-menu-wrapper'));
                    this.add(this.backdrop, this.wrapper);
                }

                return ActionMenuAnimation;
            })(Animation);

            ActionMenuSlideIn = (function (_ActionMenuAnimation) {
                _inherits(ActionMenuSlideIn, _ActionMenuAnimation);

                function ActionMenuSlideIn(element) {
                    _classCallCheck(this, ActionMenuSlideIn);

                    _get(Object.getPrototypeOf(ActionMenuSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.01, 0.4);
                    this.wrapper.fromTo('translateY', '100%', '0%');
                }

                return ActionMenuSlideIn;
            })(ActionMenuAnimation);

            Animation.register('action-menu-slide-in', ActionMenuSlideIn);

            ActionMenuSlideOut = (function (_ActionMenuAnimation2) {
                _inherits(ActionMenuSlideOut, _ActionMenuAnimation2);

                function ActionMenuSlideOut(element) {
                    _classCallCheck(this, ActionMenuSlideOut);

                    _get(Object.getPrototypeOf(ActionMenuSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.4, 0.01);
                    this.wrapper.fromTo('translateY', '0%', '100%');
                }

                return ActionMenuSlideOut;
            })(ActionMenuAnimation);

            Animation.register('action-menu-slide-out', ActionMenuSlideOut);

            ActionMenuMdSlideIn = (function (_ActionMenuSlideIn) {
                _inherits(ActionMenuMdSlideIn, _ActionMenuSlideIn);

                function ActionMenuMdSlideIn(element) {
                    _classCallCheck(this, ActionMenuMdSlideIn);

                    _get(Object.getPrototypeOf(ActionMenuMdSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.01, 0.26);
                }

                return ActionMenuMdSlideIn;
            })(ActionMenuSlideIn);

            Animation.register('action-menu-md-slide-in', ActionMenuMdSlideIn);

            ActionMenuMdSlideOut = (function (_ActionMenuSlideOut) {
                _inherits(ActionMenuMdSlideOut, _ActionMenuSlideOut);

                function ActionMenuMdSlideOut(element) {
                    _classCallCheck(this, ActionMenuMdSlideOut);

                    _get(Object.getPrototypeOf(ActionMenuMdSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.26, 0.01);
                }

                return ActionMenuMdSlideOut;
            })(ActionMenuSlideOut);

            Animation.register('action-menu-md-slide-out', ActionMenuMdSlideOut);
        }
    };
});
System.register("ionic/components/card/card", ["angular2/angular2", "../ion", "../../config/config", "../../config/decorators"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicDirective, __decorate, __metadata, Card, _a, _b;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicDirective = _configDecorators.IonicDirective;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Card = (function (_Ion) {
                _inherits(Card, _Ion);

                /**
                 * TODO
                 * @param {ElementeRef} elementRef  TODO
                 * @param {IonicConfig} ionicConfig  TODO
                 */

                function Card(elementRef, ionicConfig) {
                    _classCallCheck(this, Card);

                    _get(Object.getPrototypeOf(Card.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                }

                return Card;
            })(Ion);

            _export("Card", Card);

            _export("Card", Card = __decorate([IonicDirective({
                selector: 'ion-card'
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object])], Card));
        }
    };
});
System.register("ionic/components/button/button", ["angular2/angular2", "../../config/config"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, ElementRef, IonicConfig, __decorate, __metadata, Button, TEXT, ICON, _a, _b;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Button = function Button(config, elementRef) {
                _classCallCheck(this, Button);

                var element = elementRef.nativeElement;
                if (config.setting('hoverCSS') === false) {
                    element.classList.add('disable-hover');
                }
                if (element.hasAttribute('ion-item')) {
                    // no need to put on these icon classes for an ion-item
                    return;
                }
                // figure out if and where the icon lives in the button
                var childNodes = element.childNodes;
                var childNode = undefined;
                var nodes = [];
                for (var i = 0, l = childNodes.length; i < l; i++) {
                    childNode = childNodes[i];
                    if (childNode.nodeType === 3) {
                        // text node
                        if (childNode.textContent.trim() !== '') {
                            nodes.push(TEXT);
                        }
                    } else if (childNode.nodeType === 1) {
                        if (childNode.nodeName === 'ICON') {
                            // icon element node
                            nodes.push(ICON);
                        } else {
                            // element other than an <icon>
                            nodes.push(TEXT);
                        }
                    }
                }
                if (nodes.length > 1) {
                    if (nodes[0] === ICON && nodes[1] === TEXT) {
                        element.classList.add('icon-left');
                    } else if (nodes[0] === TEXT && nodes[1] === ICON) {
                        element.classList.add('icon-right');
                    }
                } else if (nodes.length === 1 && nodes[0] === ICON) {
                    element.classList.add('icon-only');
                }
            };

            _export("Button", Button);

            _export("Button", Button = __decorate([Directive({
                selector: 'button,[button]'
            }), __metadata('design:paramtypes', [typeof (_a = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object])], Button));
            TEXT = 1;
            ICON = 2;
        }
    };
});
System.register("ionic/components/aside/aside-toggle", ["angular2/angular2", "../app/app"], function (_export) {
    /**
    * TODO
    */
    "use strict";

    var Directive, IonicApp, __decorate, __metadata, AsideToggle;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            AsideToggle = (function () {
                /**
                * TODO
                * @param {IonicApp} app  TODO
                */

                function AsideToggle(app) {
                    _classCallCheck(this, AsideToggle);

                    this.app = app;
                }

                _createClass(AsideToggle, [{
                    key: "onInit",
                    value: function onInit() {
                        var toggleTarget = this.asideToggle;
                        // Get the component with this toggleTarget tag, or use "menu" if none
                        this.aside = this.app.getComponent(toggleTarget || 'menu');
                    }

                    /**
                    * TODO
                    * @param {TODO} event  TODO
                    */
                }, {
                    key: "toggle",
                    value: function toggle(event) {
                        this.aside && this.aside.toggle();
                        console.log('Aside toggle');
                    }
                }]);

                return AsideToggle;
            })();

            _export("AsideToggle", AsideToggle);

            _export("AsideToggle", AsideToggle = __decorate([Directive({
                selector: '[aside-toggle]',
                properties: ['asideToggle'],
                host: {
                    '(^click)': 'toggle($event)'
                }
            }), __metadata('design:paramtypes', [typeof IonicApp !== 'undefined' && IonicApp || Object])], AsideToggle));
        }
    };
});
System.register("ionic/components/aside/aside", ["angular2/angular2", "../ion", "../app/app", "../../config/config", "../../config/annotations", "./extensions/types", "./extensions/gestures", "ionic/util/util", "ionic/util"], function (_export) {
    /**
     * TODO (?) add docs about how to have a root aside and a nested aside, then hide the root one
     */
    "use strict";

    var forwardRef, Component, Host, View, EventEmitter, ElementRef, Ion, IonicApp, IonicConfig, IonicComponent, types, gestures, util, dom, __decorate, __metadata, __param, Aside, AsideBackdrop;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            forwardRef = _angular2Angular2.forwardRef;
            Component = _angular2Angular2.Component;
            Host = _angular2Angular2.Host;
            View = _angular2Angular2.View;
            EventEmitter = _angular2Angular2.EventEmitter;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_extensionsTypes) {
            types = _extensionsTypes;
        }, function (_extensionsGestures) {
            gestures = _extensionsGestures;
        }, function (_ionicUtilUtil) {
            util = _ionicUtilUtil;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Aside = (function (_Ion) {
                _inherits(Aside, _Ion);

                /**
                * TODO
                * @param {IonicApp} app  TODO
                * @param {ElementRef} elementRef  Reference to the element.
                */

                function Aside(app, elementRef, config) {
                    var _this = this;

                    _classCallCheck(this, Aside);

                    _get(Object.getPrototypeOf(Aside.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    this.opening = new EventEmitter('opening');
                    //this.animation = new Animation(element.querySelector('backdrop'));
                    this.contentClickFn = function (e) {
                        if (!_this.isOpen || _this.isChanging) {
                            return;
                        }
                        _this.close();
                    };
                    this.finishChanging = util.debounce(function () {
                        _this.setChanging(false);
                    });
                    // TODO: Use Animation Class
                    this.getNativeElement().addEventListener('transitionend', function (ev) {
                        //this.setChanging(false)
                        clearTimeout(_this.setChangeTimeout);
                        _this.setChangeTimeout = setInterval(_this.finishChanging, 400);
                    });
                }

                /**
                 * TODO
                 */

                _createClass(Aside, [{
                    key: "onDestroy",
                    value: function onDestroy() {
                        app.unregister(this);
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        _get(Object.getPrototypeOf(Aside.prototype), "onInit", this).call(this);
                        this.contentElement = this.content instanceof Node ? this.content : this.content.getNativeElement();
                        if (this.contentElement) {
                            this.contentElement.addEventListener('transitionend', function (ev) {
                                //this.setChanging(false)
                                clearTimeout(_this2.setChangeTimeout);
                                _this2.setChangeTimeout = setInterval(_this2.finishChanging, 400);
                            });
                            this.contentElement.addEventListener('click', this.contentClickFn);
                        } else {
                            console.error('Aside: must have a [content] element to listen for drag events on. Supply one like this:\n\n<ion-aside [content]="content"></ion-aside>\n\n<ion-content #content>');
                        }
                        this.gestureDelegate = this.getDelegate('gesture');
                        this.typeDelegate = this.getDelegate('type');
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.contentElement.removeEventListener('click', this.contentClickFn);
                    }

                    /**
                     * TODO
                     * @return {Element} The Aside's content element.
                     */
                }, {
                    key: "getContentElement",
                    value: function getContentElement() {
                        return this.contentElement;
                    }

                    /**
                     * TODO
                     * @param {TODO} v  TODO
                     */
                }, {
                    key: "setOpenAmt",
                    value: function setOpenAmt(v) {
                        this.opening.next(v);
                    }

                    /**
                     * TODO
                     * @param {boolean} willOpen  TODO
                     */
                }, {
                    key: "setDoneTransforming",
                    value: function setDoneTransforming(willOpen) {
                        this.typeDelegate.setDoneTransforming(willOpen);
                    }

                    /**
                     * TODO
                     * @param {TODO} transform  TODO
                     */
                }, {
                    key: "setTransform",
                    value: function setTransform(transform) {
                        this.typeDelegate.setTransform(transform);
                    }

                    /**
                     * TODO
                     * @param {boolean} isSliding  TODO
                     */
                }, {
                    key: "setSliding",
                    value: function setSliding(isSliding) {
                        if (isSliding !== this.isSliding) {
                            this.typeDelegate.setSliding(isSliding);
                        }
                    }

                    /**
                     * TODO
                     * @param {boolean} isChanging  TODO
                     */
                }, {
                    key: "setChanging",
                    value: function setChanging(isChanging) {
                        // Stop any last changing end operations
                        clearTimeout(this.setChangeTimeout);
                        if (isChanging !== this.isChanging) {
                            this.isChanging = isChanging;
                            this.getNativeElement().classList[isChanging ? 'add' : 'remove']('changing');
                        }
                    }

                    /**
                     * Sets the state of the Aside to open or not.
                     * @param {boolean} isOpen  If the Aside is open or not.
                     * @return {Promise} TODO
                     */
                }, {
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this3 = this;

                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            this.setChanging(true);
                            // Set full or closed amount
                            this.setOpenAmt(isOpen ? 1 : 0);
                            return dom.rafPromise().then(function () {
                                _this3.typeDelegate.setOpen(isOpen);
                            });
                        }
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "open",
                    value: function open() {
                        return this.setOpen(true);
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "close",
                    value: function close() {
                        return this.setOpen(false);
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        return this.setOpen(!this.isOpen);
                    }
                }]);

                return Aside;
            })(Ion);

            _export("Aside", Aside);

            _export("Aside", Aside = __decorate([IonicComponent({
                selector: 'ion-aside',
                properties: ['content', 'dragThreshold'],
                defaultProperties: {
                    'side': 'left',
                    'type': 'reveal'
                },
                delegates: {
                    gesture: [
                    //[instance => instance.side == 'top', gestures.TopAsideGesture],
                    //[instance => instance.side == 'bottom', gestures.BottomAsideGesture],
                    [function (instance) {
                        return instance.side == 'right';
                    }, gestures.RightAsideGesture], [function (instance) {
                        return instance.side == 'left';
                    }, gestures.LeftAsideGesture]],
                    type: [[function (instance) {
                        return instance.type == 'overlay';
                    }, types.AsideTypeOverlay], [function (instance) {
                        return instance.type == 'reveal';
                    }, types.AsideTypeReveal]]
                },
                events: ['opening']
            }), View({
                template: '<ng-content></ng-content><ion-aside-backdrop></ion-aside-backdrop>',
                directives: [forwardRef(function () {
                    return AsideBackdrop;
                })]
            }), __metadata('design:paramtypes', [typeof IonicApp !== 'undefined' && IonicApp || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Aside));
            /**
             * TODO
             */

            AsideBackdrop = (function (_Ion2) {
                _inherits(AsideBackdrop, _Ion2);

                /**
                 * TODO
                 * @param {ElementReg} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {Aside} aside  TODO
                 */

                function AsideBackdrop(elementRef, config, aside) {
                    _classCallCheck(this, AsideBackdrop);

                    _get(Object.getPrototypeOf(AsideBackdrop.prototype), "constructor", this).call(this, elementRef, config);
                    aside.backdrop = this;
                    this.aside = aside;
                    this.backgroundColor = 'rgba(0,0,0,0)';
                }

                /**
                 * TODO
                 */

                _createClass(AsideBackdrop, [{
                    key: "onInit",
                    value: function onInit() {
                        var ww = window.innerWidth;
                        var wh = window.innerHeight;
                        this.width = ww + 'px';
                        this.height = wh + 'px';
                    }

                    /**
                     * TODO
                     * @param {TODO} event  TODO
                     */
                }, {
                    key: "clicked",
                    value: function clicked(event) {
                        this.aside.close();
                    }
                }]);

                return AsideBackdrop;
            })(Ion);

            _export("AsideBackdrop", AsideBackdrop);

            _export("AsideBackdrop", AsideBackdrop = __decorate([Component({
                selector: 'ion-aside-backdrop',
                host: {
                    '[style.width]': 'width',
                    '[style.height]': 'height',
                    '[style.backgroundColor]': 'backgroundColor',
                    '(click)': 'clicked($event)'
                }
            }), View({
                template: ''
            }), __param(2, Host()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, Aside])], AsideBackdrop));
        }
    };
});
System.register("ionic/components/checkbox/checkbox", ["angular2/angular2", "../ion", "../form/input", "../../config/config", "../../config/decorators"], function (_export) {
    /**
     * @name ionCheckbox
     * @description
     * The checkbox is no different than the HTML checkbox input, except it's styled differently
     *
     * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
     *
     * @usage
     * ```html
     * <ion-checkbox checked="true" value="isChecked" ng-control="htmlCtrl">
     *   HTML5
     * </ion-checkbox>
     * ```
     */
    "use strict";

    var ElementRef, Optional, NgControl, Ion, IonInput, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, __param, Checkbox, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_formInput) {
            IonInput = _formInput.IonInput;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
            IonicView = _configDecorators.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Checkbox = (function (_Ion) {
                _inherits(Checkbox, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} ionicConfig  TODO
                 * @param {NgControl=} ngControl  TODO
                 */

                function Checkbox(elementRef, config, ngControl) {
                    _classCallCheck(this, Checkbox);

                    _get(Object.getPrototypeOf(Checkbox.prototype), "constructor", this).call(this, elementRef, config);
                    this.tabIndex = 0;
                    this.id = IonInput.nextId();
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.ngControl = ngControl;
                    if (ngControl) ngControl.valueAccessor = this;
                }

                /**
                 * TODO
                 */

                _createClass(Checkbox, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Checkbox.prototype), "onInit", this).call(this);
                        this.labelId = 'label-' + this.id;
                    }

                    /**
                     * Toggle the checked state of the checkbox. Calls onChange to pass the
                     * updated checked state to the model (Control).
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.checked = !this.checked;
                        this.onChange(this.checked);
                    }

                    /**
                     * Click event handler to toggle the checkbox checked state.
                     * @param {MouseEvent} ev  The click event.
                     */
                }, {
                    key: "click",
                    value: function click(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.toggle();
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the model (Control) on change to update
                     * the checked value.
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L34
                     */
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.checked = value;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the view (NgControl) to register the
                     * onChange event handler that updates the model (Control).
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L27
                     * @param {Function} fn  the onChange event handler.
                     */
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the the view (NgControl) to register
                     * the onTouched event handler that marks model (Control) as touched.
                     * @param {Function} fn  onTouched event handler.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return Checkbox;
            })(Ion);

            _export("Checkbox", Checkbox);

            _export("Checkbox", Checkbox = __decorate([IonicComponent({
                selector: 'ion-checkbox',
                properties: ['value', 'checked', 'disabled', 'id'],
                host: {
                    'class': 'item no-activated',
                    'role': 'checkbox',
                    'tappable': 'true',
                    '[attr.tab-index]': 'tabIndex',
                    '[attr.aria-checked]': 'checked',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'labelId',
                    '(click)': 'click($event)'
                }
            }), IonicView({
                template: '<div item-left class="media-checkbox">' + '<div class="checkbox-icon"></div>' + '</div>' + '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>'
            }), __param(2, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object, typeof (_c = typeof NgControl !== 'undefined' && NgControl) === 'function' && _c || Object])], Checkbox));
        }
    };
});
System.register("ionic/components/content/content", ["angular2/angular2", "../ion", "../../config/config", "../../platform/platform", "../../animations/scroll-to"], function (_export) {
    /**
     * @name ionContent
     * @description
     * The ionContent component provides an easy to use content area that can be configured to use Ionic's custom Scroll View, or the built in overflow scrolling of the browser.
     *
     * While we recommend using the custom Scroll features in Ionic in most cases, sometimes (for performance reasons) only the browser's native overflow scrolling will suffice, and so we've made it easy to toggle between the Ionic scroll implementation and overflow scrolling.
     *
     * You can implement pull-to-refresh with the ionRefresher component.
     *
     * @usage
     * ```html
     * <ion-content>
     *   Add your content here!
     * </ion-content>
     * ```
     *
     */
    "use strict";

    var Component, View, ElementRef, Ion, IonicConfig, IonicPlatform, ScrollTo, __decorate, __metadata, Content, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_platformPlatform) {
            IonicPlatform = _platformPlatform.IonicPlatform;
        }, function (_animationsScrollTo) {
            ScrollTo = _animationsScrollTo.ScrollTo;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Content = (function (_Ion) {
                _inherits(Content, _Ion);

                /**
                 * @param {ElementRef} elementRef  A reference to the component's DOM element.
                 * @param {IonicConfig} config  The config object to change content's default settings.
                 */

                function Content(elementRef, config, platform) {
                    _classCallCheck(this, Content);

                    _get(Object.getPrototypeOf(Content.prototype), "constructor", this).call(this, elementRef, config);
                    this.scrollPadding = 0;
                    this.platform = platform;
                }

                /**
                 * TODO
                 * @private
                 */

                _createClass(Content, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Content.prototype), "onInit", this).call(this);
                        this.scrollElement = this.getNativeElement().children[0];
                    }

                    /**
                     * Adds the specified scroll handler to the content' scroll element.
                     * @param {Function} handler  The scroll event handler.
                     * @returns {Function} A function that removes the scroll handler.
                     */
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        // ensure we're not creating duplicates
                        this.scrollElement.removeEventListener('scroll', handler);
                        this.scrollElement.addEventListener('scroll', handler);
                        return function () {
                            _this.scrollElement.removeEventListener('scroll', handler);
                        };
                    }

                    /**
                     * Adds the specified touchmove handler to the content's scroll element.
                     * @param {Function} handler  The touchmove handler.
                     * @returns {Function} A function that removes the touchmove handler.
                     */
                }, {
                    key: "addTouchMoveListener",
                    value: function addTouchMoveListener(handler) {
                        var _this2 = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        // ensure we're not creating duplicates
                        this.scrollElement.removeEventListener('touchmove', handler);
                        this.scrollElement.addEventListener('touchmove', handler);
                        return function () {
                            _this2.scrollElement.removeEventListener('touchmove', handler);
                        };
                    }

                    /**
                     * Scroll to the specified position.
                     * @param {TODO} x  The x-value to scroll to.
                     * @param {TODO} y  The y-value to scroll to.
                     * @param {Number} duration  Duration of the scroll animation.
                     * @param {TODO} tolerance  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "scrollTo",
                    value: function scrollTo(x, y, duration, tolerance) {
                        if (this._scrollTo) {
                            this._scrollTo.dispose();
                        }
                        this._scrollTo = new ScrollTo(this.scrollElement);
                        return this._scrollTo.start(x, y, duration, tolerance);
                    }

                    /**
                     * Returns the content and scroll elements' dimensions.
                     * @returns {Object} dimensions  The content and scroll elements' dimensions
                     * {Number} dimensions.contentHeight  content offsetHeight
                     * {Number} dimensions.contentTop  content offsetTop
                     * {Number} dimensions.contentBottom  content offsetTop+offsetHeight
                     * {Number} dimensions.contentWidth  content offsetWidth
                     * {Number} dimensions.contentLeft  content offsetLeft
                     * {Number} dimensions.contentRight  content offsetLeft + offsetWidth
                     * {Number} dimensions.scrollHeight  scroll scrollHeight
                     * {Number} dimensions.scrollTop  scroll scrollTop
                     * {Number} dimensions.scrollBottom  scroll scrollTop + scrollHeight
                     * {Number} dimensions.scrollWidth  scroll scrollWidth
                     * {Number} dimensions.scrollLeft  scroll scrollLeft
                     * {Number} dimensions.scrollRight  scroll scrollLeft + scrollWidth
                     * TODO: figure out how to get this to work
                     */
                }, {
                    key: "getDimensions",
                    value: function getDimensions() {
                        var scrollElement = this.scrollElement;
                        var parentElement = scrollElement.parentElement;
                        return {
                            contentHeight: parentElement.offsetHeight,
                            contentTop: parentElement.offsetTop,
                            contentBottom: parentElement.offsetTop + parentElement.offsetHeight,
                            contentWidth: parentElement.offsetWidth,
                            contentLeft: parentElement.offsetLeft,
                            contentRight: parentElement.offsetLeft + parentElement.offsetWidth,
                            scrollHeight: scrollElement.scrollHeight,
                            scrollTop: scrollElement.scrollTop,
                            scrollBottom: scrollElement.scrollTop + scrollElement.scrollHeight,
                            scrollWidth: scrollElement.scrollWidth,
                            scrollLeft: scrollElement.scrollLeft,
                            scrollRight: scrollElement.scrollLeft + scrollElement.scrollWidth
                        };
                    }

                    /**
                     * @private
                     * Adds padding to the bottom of the scroll element when the keyboard is open
                     * so content below the keyboard can be scrolled into view.
                     */
                }, {
                    key: "addKeyboardPadding",
                    value: function addKeyboardPadding(addPadding) {
                        var _this3 = this;

                        if (addPadding > this.scrollPadding) {
                            this.scrollPadding = addPadding;
                            this.scrollElement.style.paddingBottom = addPadding + 'px';
                            if (!this.keyboardPromise) {
                                this.keyboardPromise = this.platform.onKeyboardClose(function () {
                                    if (_this3) {
                                        _this3.scrollPadding = 0;
                                        if (_this3.scrollElement) _this3.scrollElement.style.paddingBottom = '';
                                        _this3.keyboardPromise = null;
                                    }
                                });
                            }
                        }
                    }
                }]);

                return Content;
            })(Ion);

            _export("Content", Content);

            _export("Content", Content = __decorate([Component({
                selector: 'ion-content',
                properties: ['parallax']
            }), View({
                template: '<scroll-content><ng-content></ng-content></scroll-content>'
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object, typeof (_c = typeof IonicPlatform !== 'undefined' && IonicPlatform) === 'function' && _c || Object])], Content));
        }
    };
});
System.register("ionic/components/form/focus-holder", ["angular2/angular2", "./input"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Component, Directive, View, Host, Attribute, ElementRef, forwardRef, IonInput, __decorate, __metadata, __param, FocusHolder, FocusInput, _a;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            Host = _angular2Angular2.Host;
            Attribute = _angular2Angular2.Attribute;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_input) {
            IonInput = _input.IonInput;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            FocusHolder = (function () {
                /**
                 * TODO
                 */

                function FocusHolder() {
                    _classCallCheck(this, FocusHolder);

                    this.i = [];
                }

                /**
                 * TODO
                 * @param {TODO} inputType  TODO
                 */

                _createClass(FocusHolder, [{
                    key: "setFocusHolder",
                    value: function setFocusHolder(inputType) {
                        this.i[2].type = inputType;
                        this.i[2].setFocus();
                    }

                    /**
                     * TODO
                     * @param {TODO} tabIndex  TODO
                     */
                }, {
                    key: "receivedFocus",
                    value: function receivedFocus(tabIndex) {
                        if (tabIndex === '999') {
                            // focus on the previous input
                            IonInput.focusPrevious();
                        } else if (tabIndex === '1001') {
                            // focus on the next input
                            IonInput.focusNext();
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} input  TODO
                     */
                }, {
                    key: "register",
                    value: function register(input) {
                        this.i.push(input);
                    }
                }]);

                return FocusHolder;
            })();

            _export("FocusHolder", FocusHolder);

            _export("FocusHolder", FocusHolder = __decorate([Component({
                selector: 'focus-holder'
            }), View({
                template: '<input tabindex="999"><input tabindex="1001"><input tabindex="1002">',
                directives: [forwardRef(function () {
                    return FocusInput;
                })]
            }), __metadata('design:paramtypes', [])], FocusHolder));

            FocusInput = (function () {
                function FocusInput(elementRef, holder, tabindex) {
                    _classCallCheck(this, FocusInput);

                    this.elementRef = elementRef;
                    this.holder = holder;
                    this.tabindex = tabindex;
                    this.holder.register(this);
                }

                _createClass(FocusInput, [{
                    key: "setFocus",
                    value: function setFocus() {
                        this.elementRef.nativeElement.focus();
                    }
                }, {
                    key: "keydown",
                    value: function keydown(ev) {
                        // prevent any keyboard typing when a holder has focus
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                }, {
                    key: "type",
                    get: function get() {
                        // default to text type if unknown
                        return this._t || 'text';
                    },
                    set: function set(val) {
                        this._t = val;
                    }
                }]);

                return FocusInput;
            })();

            FocusInput = __decorate([Directive({
                selector: 'input',
                host: {
                    '[type]': 'type',
                    '(focus)': 'holder.receivedFocus(tabindex)',
                    '(keydown)': 'keydown($event)'
                }
            }), __param(1, Host()), __param(2, Attribute('tabindex')), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, FocusHolder, String])], FocusInput);
        }
    };
});
System.register('ionic/components/form/input', ['../ion'], function (_export) {
    'use strict';

    var Ion, inputRegistry, inputItemIds, activeInput, lastInput, IonInput;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ion) {
            Ion = _ion.Ion;
        }],
        execute: function () {
            inputRegistry = [];
            inputItemIds = -1;
            activeInput = null;
            lastInput = null;

            /**
             * @name ionInput
             * @description
             * The ionInput component is used to focus text input elements.
             *
             * The `focusNext()` and  `focusPrevious()` methods make it easy to focus input elements across all devices.
             *
             * @usage
             * ```html
             * <ion-input>
             *   <ion-label>Name</ion-label>
             *   <input value="Name" type="text">
             * </ion-input>
             * ```
             */

            IonInput = (function (_Ion) {
                _inherits(IonInput, _Ion);

                function IonInput() {
                    _classCallCheck(this, IonInput);

                    _get(Object.getPrototypeOf(IonInput.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(IonInput, null, [{
                    key: 'registerInput',

                    /**
                     * @param {TODO} input  TODO
                     */
                    value: function registerInput(input) {
                        inputRegistry.push(input);
                    }

                    /**
                     * TODO
                     * @param {TODO} input  TODO
                     */
                }, {
                    key: 'setAsLastInput',
                    value: function setAsLastInput(input) {
                        lastInput = input;
                    }

                    /**
                     * Focuses the previous input element, if it exists.
                     */
                }, {
                    key: 'focusPrevious',
                    value: function focusPrevious() {
                        this.focusMove(-1);
                    }

                    /**
                     * Focuses the next input element, if it exists.
                     */
                }, {
                    key: 'focusNext',
                    value: function focusNext() {
                        this.focusMove(1);
                    }

                    /**
                     * @param {Number} inc TODO
                     */
                }, {
                    key: 'focusMove',
                    value: function focusMove(inc) {
                        var input = activeInput || lastInput;
                        if (input) {
                            var index = inputRegistry.indexOf(input);
                            if (index > -1 && index + inc < inputRegistry.length) {
                                var siblingInput = inputRegistry[index + inc];
                                siblingInput && siblingInput.initFocus();
                            }
                        }
                    }

                    /**
                     * @returns {Number} The ID of the next input element.
                     */
                }, {
                    key: 'nextId',
                    value: function nextId() {
                        return ++inputItemIds;
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'clearTabIndexes',
                    value: function clearTabIndexes() {
                        for (var i = 0; i < inputRegistry.length; i++) {
                            inputRegistry[i].tabIndex = -1;
                        }
                    }
                }]);

                return IonInput;
            })(Ion);

            _export('IonInput', IonInput);
        }
    };
});
System.register("ionic/components/form/label", ["angular2/angular2", "../../config/config", "../../util/dom"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, IonicConfig, pointerCoord, hasPointerMoved, __decorate, __metadata, Label;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
            hasPointerMoved = _utilDom.hasPointerMoved;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Label = (function () {
                /**
                 * TODO
                 * @param {IonicConfig} config
                 */

                function Label(config) {
                    _classCallCheck(this, Label);

                    this.scrollAssist = config.setting('keyboardScrollAssist');
                }

                /**
                 * TODO
                 * @param {TODO} ev  TODO
                 */

                _createClass(Label, [{
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = pointerCoord(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (this.container) {
                            // get where the touchend/mouseup ended
                            var endCoord = pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            if (!hasPointerMoved(20, this.startCoord, endCoord)) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.container.focus();
                            }
                            this.startCoord = null;
                        }
                    }
                }]);

                return Label;
            })();

            _export("Label", Label);

            _export("Label", Label = __decorate([Directive({
                selector: 'ion-label',
                properties: ['id'],
                host: {
                    '[attr.id]': 'id',
                    'class': 'input-label',
                    '(touchstart)': 'pointerStart($event)',
                    '(touchend)': 'pointerEnd($event)',
                    '(mousedown)': 'pointerStart($event)',
                    '(mouseup)': 'pointerEnd($event)'
                }
            }), __metadata('design:paramtypes', [typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Label));
        }
    };
});
System.register("ionic/components/icon/icon", ["angular2/angular2", "../../config/config"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, ElementRef, Renderer, IonicConfig, __decorate, __metadata, Icon, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            Renderer = _angular2Angular2.Renderer;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Icon = (function () {
                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {Renderer} renderer  TODO
                 */

                function Icon(elementRef, config, renderer) {
                    _classCallCheck(this, Icon);

                    this.elementRef = elementRef;
                    this.renderer = renderer;
                    this.eleRef = elementRef;
                    this.config = config;
                    this.mode = config.setting('iconMode');
                }

                /**
                 * TODO
                 */

                _createClass(Icon, [{
                    key: "onInit",
                    value: function onInit() {
                        var ele = this.eleRef.nativeElement;
                        if (this.mode == 'ios' && this.ios) {
                            this.name = this.ios;
                        } else if (this.mode == 'md' && this.md) {
                            this.name = this.md;
                        } else if (!this.name) {
                            // looping through native dom attributes, eww
                            // https://github.com/angular/angular/issues/3961
                            for (var i = 0, l = ele.attributes.length; i < l; i++) {
                                if (ele.attributes[i].value === '' && /_|item-|is-active|large|small|class/.test(ele.attributes[i].name) !== true) {
                                    this.name = ele.attributes[i].name;
                                    break;
                                }
                            }
                        }
                        if (!this.name) return;
                        if (!/^ion-/.test(this.name)) {
                            // not an exact icon being used
                            // add mode specific prefix
                            this.name = 'ion-' + this.mode + '-' + this.name;
                        }
                        this.update();
                    }
                }, {
                    key: "update",
                    value: function update() {
                        if (this.name && this.mode == 'ios') {
                            if (this.isActive) {
                                if (/-outline/.test(this.name)) {
                                    this.name = this.name.replace('-outline', '');
                                }
                            } else if (!/-outline/.test(this.name)) {
                                this.name += '-outline';
                            }
                        }
                        if (this._name !== this.name) {
                            if (this._name) {
                                this.renderer.setElementClass(this.elementRef, this._name, false);
                            }
                            this._name = this.name;
                            this.renderer.setElementClass(this.elementRef, this.name, true);
                            this.label = this.name.replace('ion-', '').replace('ios-', '').replace('md-', '').replace('-', ' ');
                        }
                    }
                }, {
                    key: "isActive",
                    get: function get() {
                        return this._isActive === undefined || this._isActive === true || this._isActive === 'true';
                    },
                    set: function set(val) {
                        this._isActive = val;
                        this.update();
                    }
                }]);

                return Icon;
            })();

            _export("Icon", Icon);

            _export("Icon", Icon = __decorate([Directive({
                selector: 'icon',
                properties: ['name', 'ios', 'md', 'isActive'],
                host: {
                    '[attr.aria-label]': 'label',
                    'role': 'img'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object, typeof (_c = typeof Renderer !== 'undefined' && Renderer) === 'function' && _c || Object])], Icon));
        }
    };
});
System.register("ionic/components/item/item-group", ["angular2/angular2"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, ElementRef, __decorate, __metadata, ItemGroup, ItemGroupTitle, _a, _b;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ItemGroup =
            /**
             * TODO
             * @param {ElementRef} elementRef  TODO
             */
            function ItemGroup(elementRef) {
                _classCallCheck(this, ItemGroup);

                this.ele = elementRef.nativeElement;
            };

            _export("ItemGroup", ItemGroup);

            _export("ItemGroup", ItemGroup = __decorate([Directive({
                selector: 'ion-item-group',
                host: {
                    'class': 'item-group'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object])], ItemGroup));
            /**
             * TODO
             */

            ItemGroupTitle =
            /**
             * TODO
             * @param {ElementRef} elementRef  TODO
             */
            function ItemGroupTitle(elementRef) {
                _classCallCheck(this, ItemGroupTitle);

                this.isSticky = true;
                this.ele = elementRef.nativeElement;
            };

            _export("ItemGroupTitle", ItemGroupTitle);

            _export("ItemGroupTitle", ItemGroupTitle = __decorate([Directive({
                selector: 'ion-item-group-title',
                host: {
                    'class': 'item-group-title',
                    '[class.sticky]': 'isSticky'
                }
            }), __metadata('design:paramtypes', [typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object])], ItemGroupTitle));
        }
    };
});
System.register("ionic/components/item/item-options", [], function (_export) {
    "use strict";

    var __decorate, __metadata, ItemPrimaryOptions, ItemSecondaryOptions;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * TODO
             */

            ItemPrimaryOptions = function ItemPrimaryOptions() {
                _classCallCheck(this, ItemPrimaryOptions);
            };

            _export("ItemPrimaryOptions", ItemPrimaryOptions);

            _export("ItemPrimaryOptions", ItemPrimaryOptions = __decorate([
            /**
             * TODO
             */Decorator({
                selector: 'ion-primary-options'
            }), __metadata('design:paramtypes', [])], ItemPrimaryOptions));
            /**
             * TODO
             */

            ItemSecondaryOptions = function ItemSecondaryOptions() {
                _classCallCheck(this, ItemSecondaryOptions);
            };

            _export("ItemSecondaryOptions", ItemSecondaryOptions);

            _export("ItemSecondaryOptions", ItemSecondaryOptions = __decorate([Decorator({
                selector: 'ion-secondary-options'
            }), __metadata('design:paramtypes', [])], ItemSecondaryOptions));
        }
    };
});
System.register("ionic/components/item/item-swipe-buttons", ["angular2/angular2", "ionic/components/item/item", "ionic/gestures/slide-gesture"], function (_export) {
    /**
     * @name ionPrimarySwipeButtons
     * @description
     * Creates a swipeable button inside a list item, that is visible when the item is swiped to the left by the user. Swiped open buttons can be hidden with `setOpen(false)`.
     *
     * @usage
     * TODO
     */
    "use strict";

    var ElementRef, Host, Directive, Item, SlideGesture, __decorate, __metadata, __param, ItemPrimarySwipeButtons, ItemSecondarySwipeButtons, ItemSlideGesture, _a, _b;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Directive = _angular2Angular2.Directive;
        }, function (_ionicComponentsItemItem) {
            Item = _ionicComponentsItemItem.Item;
        }, function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ItemPrimarySwipeButtons = (function () {
                /**
                 * @param {ElementRef} elementRef  A reference to the component's DOM element.
                 * @param {Item} item  The list item containing the swipeable buttons.
                 */

                function ItemPrimarySwipeButtons(elementRef, item) {
                    _classCallCheck(this, ItemPrimarySwipeButtons);

                    item.primarySwipeButtons = this;
                    this.ele = elementRef.nativeElement;
                    this.item = item;
                    this.gesture = new ItemSlideGesture(this);
                    this.gesture.listen();
                }

                /**
                 * @param {boolean} isOpen  Whether or not the button should be set to open/visible.
                 */

                _createClass(ItemPrimarySwipeButtons, [{
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this = this;

                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            requestAnimationFrame(function () {
                                _this.ele.classList[isOpen ? 'add' : 'remove'](isOpen);
                            });
                        }
                    }
                }]);

                return ItemPrimarySwipeButtons;
            })();

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons);

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons = __decorate([Directive({
                selector: 'ion-primary-swipe-buttons'
            }), __param(1, Host()), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof Item !== 'undefined' && Item) === 'function' && _b || Object])], ItemPrimarySwipeButtons));
            /**
             * TODO
             */

            ItemSecondarySwipeButtons = function ItemSecondarySwipeButtons() {
                _classCallCheck(this, ItemSecondarySwipeButtons);
            };

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons);

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons = __decorate([Directive({
                selector: 'ion-secondary-swipe-buttons'
            }), __metadata('design:paramtypes', [])], ItemSecondarySwipeButtons));

            ItemSlideGesture = (function (_SlideGesture) {
                _inherits(ItemSlideGesture, _SlideGesture);

                function ItemSlideGesture(buttons) {
                    _classCallCheck(this, ItemSlideGesture);

                    _get(Object.getPrototypeOf(ItemSlideGesture.prototype), "constructor", this).call(this, buttons.item.ele);
                    this.buttons = buttons;
                }

                _createClass(ItemSlideGesture, [{
                    key: "getSlideBoundaries",
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.buttons.ele.offsetWidth,
                            max: 0
                        };
                    }
                }, {
                    key: "getElementStartPos",
                    value: function getElementStartPos(slide, ev) {
                        return this.buttons.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: "onSlideBeforeStart",
                    value: function onSlideBeforeStart() {
                        this.buttons.ele.classList.add('changing');
                        this.buttons.ele.classList.add('no-transition');
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: "onSlide",
                    value: function onSlide(slide, ev) {
                        this.buttons.ele.style.transform = 'translate3d(' + slide.distance + 'px,0,0)';
                    }
                }, {
                    key: "onSlideEnd",
                    value: function onSlideEnd(slide, ev) {
                        this.buttons.ele.style.transform = '';
                        this.buttons.ele.classList.remove('no-transition');
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.buttons.setOpen(!this.buttons.isOpen);
                        }
                    }
                }]);

                return ItemSlideGesture;
            })(SlideGesture);
        }
    };
});
System.register("ionic/components/item/item", ["angular2/angular2", "ionic/util"], function (_export) {
    /**
     * @name ionItem
     * @description
     * Creates a list-item that can easily be swiped,
     * deleted, reordered, edited, and more.
     *
     * @usage
     * ```html
     * <ion-list>
     *   <ion-item *ng-for="#item of items" (click)="itemTapped($event, item)">
     *     {{item.title}}
     *     <div class="item-note" item-right>
     *       {{item.note}}
     *     </div>
     *   </ion-item>
     * </ion-list>
     *  ```
     */
    "use strict";

    var Component, View, ElementRef, NgIf, dom, __decorate, __metadata, Item, Slideable, ItemSlideGesture, _a;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            NgIf = _angular2Angular2.NgIf;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Item =
            /**
             * TODO
             * @param {ElementRef} elementRef  A reference to the component's DOM element.
             */
            function Item(elementRef) {
                _classCallCheck(this, Item);

                this._isOpen = false;
                this._isSlideActive = false;
                this._isTransitioning = false;
                this._transform = '';
                this.ele = elementRef.nativeElement;
                this.swipeButtons = {};
                this.optionButtons = {};
            };

            _export("Item", Item);

            _export("Item", Item = __decorate([Component({
                selector: 'ion-item,[ion-item]',
                host: {
                    'class': 'item'
                }
            }), View({
                template: '<ng-content select="[item-left]"></ng-content>' + '<ion-item-content>' + '<ng-content></ng-content>' + '</ion-item-content>' + '<ng-content select="[item-right]"></ng-content>',
                directives: [NgIf]
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object])], Item));

            Slideable = (function () {
                function Slideable(slideElement) {
                    _classCallCheck(this, Slideable);
                }

                // override

                _createClass(Slideable, [{
                    key: "onTransform",
                    value: function onTransform(str) {}

                    // override
                }, {
                    key: "onTransitionActive",
                    value: function onTransitionActive(active) {}

                    //override
                }, {
                    key: "onSlideActive",
                    value: function onSlideActive(active) {}
                }, {
                    key: "transform",
                    value: function transform(str) {
                        if (arguments.length && str !== this._transform) {
                            this.onTransform();
                        }
                    }
                }, {
                    key: "isTransitionActive",
                    value: function isTransitionActive(active) {
                        if (arguments.length && active !== this._isTransitionActive) {
                            this._isTransitionActive = active;
                            this.onSetTransitionActive(active);
                        }
                        return this._isTransitioning;
                    }
                }, {
                    key: "isSlideActive",
                    value: function isSlideActive(active) {
                        if (arguments.length && active !== this._isSlideActive) {
                            this._isSlideActive = active;
                            this.onSetDragActive(active);
                        }
                        return this._isSlideActive;
                    }
                }, {
                    key: "isOpen",
                    value: (function (_isOpen) {
                        function isOpen(_x) {
                            return _isOpen.apply(this, arguments);
                        }

                        isOpen.toString = function () {
                            return _isOpen.toString();
                        };

                        return isOpen;
                    })(function (open) {
                        var _this = this;

                        if (arguments.length && open !== this._isOpen) {
                            this.isTransitionActive(true);
                            dom.raf(function () {
                                _this.isOpen = isOpen;
                                _this.onSetIsOpen(open);
                            });
                        }
                    })
                }]);

                return Slideable;
            })();

            ItemSlideGesture = function ItemSlideGesture() {
                _classCallCheck(this, ItemSlideGesture);
            };
        }
    };
});
System.register("ionic/components/list/list", ["angular2/angular2", "../ion", "../../config/config", "../../config/decorators", "./virtual", "ionic/util"], function (_export) {
    /**
     * @name ionList
     * @description
     * The List is a widely used interface element in almost any mobile app, and can include
     * content ranging from basic text all the way to buttons, toggles, icons, and thumbnails.
     *
     * Both the list, which contains items, and the list items themselves can be any HTML
     * element.
     *
     * Using the ionList and ionItem components make it easy to support various
     * interaction modes such as swipe to edit, drag to reorder, and removing items.
     *
     */
    "use strict";

    var Directive, ElementRef, Ion, IonicConfig, IonicDirective, ListVirtualScroll, util, __decorate, __metadata, List, ListHeader, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicDirective = _configDecorators.IonicDirective;
        }, function (_virtual) {
            ListVirtualScroll = _virtual.ListVirtualScroll;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            List = (function (_Ion) {
                _inherits(List, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function List(elementRef, config) {
                    _classCallCheck(this, List);

                    _get(Object.getPrototypeOf(List.prototype), "constructor", this).call(this, elementRef, config);
                    this.ele = elementRef.nativeElement;
                }

                /**
                 * TODO
                 */

                _createClass(List, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(List.prototype), "onInit", this).call(this);
                        if (util.isDefined(this.virtual)) {
                            console.log('Content', this.content);
                            console.log('Virtual?', this.virtual);
                            console.log('Items?', this.items.length, 'of \'em');
                            this._initVirtualScrolling();
                        }
                    }

                    /**
                     * @private
                     * TODO
                     */
                }, {
                    key: "_initVirtualScrolling",
                    value: function _initVirtualScrolling() {
                        if (!this.content) {
                            return;
                        }
                        this._virtualScrollingManager = new ListVirtualScroll(this);
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     */
                }, {
                    key: "setItemTemplate",
                    value: function setItemTemplate(item) {
                        this.itemTemplate = item;
                    }
                }]);

                return List;
            })(Ion);

            _export("List", List);

            _export("List", List = __decorate([IonicDirective({
                selector: 'ion-list',
                properties: ['items', 'virtual', 'content']
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object])], List));
            /**
             * TODO
             */

            ListHeader = function ListHeader() {
                _classCallCheck(this, ListHeader);
            };

            _export("ListHeader", ListHeader);

            _export("ListHeader", ListHeader = __decorate([Directive({
                selector: 'ion-header',
                properties: ['id'],
                host: {
                    '[attr.id]': 'id'
                }
            }), __metadata('design:paramtypes', [])], ListHeader));
        }
    };
});
System.register('ionic/components/list/virtual', [], function (_export) {
    'use strict';

    var ListVirtualScroll, VirtualItemRef;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            ListVirtualScroll = (function () {
                function ListVirtualScroll(list) {
                    var _this = this;

                    _classCallCheck(this, ListVirtualScroll);

                    this.list = list;
                    this.content = this.list.content;
                    this.viewportHeight = this.content.height();
                    this.viewContainer = this.list.itemTemplate.viewContainer;
                    this.itemHeight = 60;
                    this.shownItems = {};
                    this.enteringItems = [];
                    this.leavingItems = [];
                    // Compute the initial sizes
                    setTimeout(function () {
                        _this.resize();
                        // Simulate the first event to start layout
                        _this._handleVirtualScroll({
                            target: _this.content.scrollElement
                        });
                    });
                    this.content.addScrollEventListener(function (event) {
                        _this._handleVirtualScroll(event);
                    });
                }

                _createClass(ListVirtualScroll, [{
                    key: 'resize',
                    value: function resize() {
                        this.viewportHeight = this.content.height();
                        this.viewportScrollHeight = this.content.scrollElement.scrollHeight;
                        this.virtualHeight = this.list.items.length * this.itemHeight;
                        this.itemsPerScreen = this.viewportHeight / this.itemHeight;
                        console.log('VIRTUAL: resize(viewportHeight:', this.viewportHeight, 'viewportScrollHeight:', this.viewportScrollHeight, 'virtualHeight:', this.virtualHeight, ', itemsPerScreen:', this.itemsPerScreen, ')');
                    }
                }, {
                    key: '_handleVirtualScroll',
                    value: function _handleVirtualScroll(event) {
                        var item = undefined;
                        var shownItemRef = undefined;
                        var st = event.target.scrollTop;
                        var sh = event.target.scrollHeight;
                        var topIndex = Math.floor(st / this.itemHeight);
                        var bottomIndex = Math.floor(st / this.itemHeight + this.itemsPerScreen);
                        var items = this.list.items;
                        // Key iterate the shown items map
                        // and compare the index to our index range,
                        // pushing the items to remove to our leaving
                        // list if they're ouside this range.
                        for (var i in this.shownItems) {
                            if (i < topIndex || i > bottomIndex) {
                                this.leavingItems.push(this.shownItems[i]);
                                delete this.shownItems[i];
                            }
                        }
                        var realIndex = 0;
                        // Iterate the set of items that will be rendered, using the
                        // index from the actual items list as the map for the
                        // virtual items we draw
                        for (var i = topIndex, _realIndex = 0; i < bottomIndex && i < items.length; i++, _realIndex++) {
                            item = items[i];
                            console.log('Drawing item', i, item.title);
                            shownItemRef = this.shownItems[i];
                            // Is this a new item?
                            if (!shownItemRef) {
                                var itemView = this.viewContainer.create(this.list.itemTemplate.protoViewRef, _realIndex);
                                itemView.setLocal('\$implicit', item);
                                itemView.setLocal('\$item', item);
                                shownItemRef = new VirtualItemRef(item, i, _realIndex, itemView);
                                this.shownItems[i] = shownItemRef;
                                this.enteringItems.push(shownItemRef);
                            }
                        }
                        while (this.leavingItems.length) {
                            var itemRef = this.leavingItems.pop();
                            console.log('Removing item', itemRef.item, itemRef.realIndex);
                            this.viewContainer.remove(itemRef.realIndex);
                        }
                        console.log('VIRTUAL SCROLL: scroll(scrollTop:', st, 'topIndex:', topIndex, 'bottomIndex:', bottomIndex, ')');
                        console.log('Container has', this.list.getNativeElement().children.length, 'children');
                    }
                }, {
                    key: 'cellAtIndex',
                    value: function cellAtIndex(index) {}
                }]);

                return ListVirtualScroll;
            })();

            _export('ListVirtualScroll', ListVirtualScroll);

            VirtualItemRef = function VirtualItemRef(item, index, realIndex, view) {
                _classCallCheck(this, VirtualItemRef);

                this.item = item;
                this.index = index;
                this.realIndex = realIndex;
                this.view = view;
            };
        }
    };
});
System.register('ionic/components/menu/menu-gestures', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, MenuContentGesture, LeftMenuGesture, RightMenuGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            MenuContentGesture = (function (_SlideEdgeGesture) {
                _inherits(MenuContentGesture, _SlideEdgeGesture);

                function MenuContentGesture(menu) {
                    _classCallCheck(this, MenuContentGesture);

                    _get(Object.getPrototypeOf(MenuContentGesture.prototype), 'constructor', this).call(this, menu.getContentElement(), {
                        direction: menu.side === 'left' || menu.side === 'right' ? 'x' : 'y',
                        edge: menu.side,
                        threshold: 75
                    });
                    this.menu = menu;
                    this.listen();
                }

                _createClass(MenuContentGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        return this.menu.isOpen ? true : _get(Object.getPrototypeOf(MenuContentGesture.prototype), 'canStart', this).call(this, ev);
                    }

                    // Set CSS, then wait one frame for it to apply before sliding starts
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart(slide, ev) {
                        this.menu.setProgressStart();
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.menu.setProgess(slide.distance / slide.max);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        var shouldComplete = Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5;
                        this.menu.setProgressEnd(shouldComplete);
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.menu.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.menu.width()
                        };
                    }
                }]);

                return MenuContentGesture;
            })(SlideEdgeGesture);

            LeftMenuGesture = (function (_MenuContentGesture) {
                _inherits(LeftMenuGesture, _MenuContentGesture);

                function LeftMenuGesture(menu) {
                    _classCallCheck(this, LeftMenuGesture);

                    _get(Object.getPrototypeOf(LeftMenuGesture.prototype), 'constructor', this).call(this, menu);
                }

                return LeftMenuGesture;
            })(MenuContentGesture);

            _export('LeftMenuGesture', LeftMenuGesture);

            RightMenuGesture = (function (_MenuContentGesture2) {
                _inherits(RightMenuGesture, _MenuContentGesture2);

                function RightMenuGesture(menu) {
                    _classCallCheck(this, RightMenuGesture);

                    _get(Object.getPrototypeOf(RightMenuGesture.prototype), 'constructor', this).call(this, menu);
                }

                _createClass(RightMenuGesture, [{
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.menu.setProgess(slide.distance / slide.min);
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.menu.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.menu.width(),
                            max: 0
                        };
                    }
                }]);

                return RightMenuGesture;
            })(MenuContentGesture);

            _export('RightMenuGesture', RightMenuGesture);
        }
    };
});
System.register("ionic/components/menu/menu-toggle", ["angular2/angular2", "../ion", "../app/app", "../nav/view-controller", "../nav-bar/nav-bar"], function (_export) {
    /**
    * TODO
    */
    "use strict";

    var Directive, ElementRef, Optional, Ion, IonicApp, ViewController, Navbar, __decorate, __metadata, __param, MenuToggle, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_navBarNavBar) {
            Navbar = _navBarNavBar.Navbar;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            MenuToggle = (function (_Ion) {
                _inherits(MenuToggle, _Ion);

                function MenuToggle(app, elementRef, viewCtrl, navbar) {
                    _classCallCheck(this, MenuToggle);

                    _get(Object.getPrototypeOf(MenuToggle.prototype), "constructor", this).call(this, elementRef, null);
                    this.app = app;
                    this.viewCtrl = viewCtrl;
                    this.withinNavbar = !!navbar;
                }

                /**
                * TODO
                * @param {TODO} event  TODO
                */

                _createClass(MenuToggle, [{
                    key: "toggle",
                    value: function toggle(ev) {
                        var menu = this.app.getComponent(this.menuToggle || 'menu');
                        menu && menu.toggle();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                }, {
                    key: "isHidden",
                    get: function get() {
                        if (this.withinNavbar && this.viewCtrl) {
                            return !this.viewCtrl.isRoot();
                        }
                        return false;
                    }
                }]);

                return MenuToggle;
            })(Ion);

            _export("MenuToggle", MenuToggle);

            _export("MenuToggle", MenuToggle = __decorate([Directive({
                selector: '[menu-toggle]',
                properties: ['menuToggle'],
                host: {
                    '(click)': 'toggle($event)',
                    '[hidden]': 'isHidden'
                }
            }), __param(2, Optional()), __param(3, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof ViewController !== 'undefined' && ViewController) === 'function' && _c || Object, typeof (_d = typeof Navbar !== 'undefined' && Navbar) === 'function' && _d || Object])], MenuToggle));
        }
    };
});
System.register('ionic/components/menu/menu-types', ['./menu', 'ionic/animations/animation'], function (_export) {
    /**
     * Menu Type
     * Base class which is extended by the various types. Each
     * type will provide their own animations for open and close
     * and registers itself with Menu.
     */
    'use strict';

    var Menu, Animation, MenuType, MenuRevealType, MenuOverlayType, OPACITY, TRANSLATE_X;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_menu) {
            Menu = _menu.Menu;
        }, function (_ionicAnimationsAnimation) {
            Animation = _ionicAnimationsAnimation.Animation;
        }],
        execute: function () {
            MenuType = (function () {
                function MenuType() {
                    _classCallCheck(this, MenuType);

                    this.open = new Animation();
                    this.close = new Animation();
                }

                /**
                 * Menu Reveal Type
                 * The content slides over to reveal the menu underneath.
                 * The menu itself, which is under the content, does not move.
                 */

                _createClass(MenuType, [{
                    key: 'setOpen',
                    value: function setOpen(shouldOpen) {
                        var _this = this;

                        return new Promise(function (resolve) {
                            if (shouldOpen) {
                                _this.open.playbackRate(1).onFinish(resolve, true).play();
                            } else {
                                _this.close.playbackRate(1).onFinish(resolve, true).play();
                            }
                        });
                    }
                }, {
                    key: 'setProgressStart',
                    value: function setProgressStart(isOpen) {
                        this.isOpening = !isOpen;
                        this.seek && this.seek.dispose();
                        // clone the correct animation depending on open/close
                        if (this.isOpening) {
                            this.seek = this.open.clone();
                        } else {
                            this.seek = this.close.clone();
                        }
                        // the cloned animation should not use an easing curve during seek
                        this.seek.easing('linear').progressStart();
                    }
                }, {
                    key: 'setProgess',
                    value: function setProgess(value) {
                        // adjust progress value depending if it opening or closing
                        if (!this.isOpening) {
                            value = 1 - value;
                        }
                        this.seek.progress(value);
                    }
                }, {
                    key: 'setProgressEnd',
                    value: function setProgressEnd(shouldComplete) {
                        var _this2 = this;

                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        var isOpen = this.isOpening && shouldComplete;
                        if (!this.isOpening && !shouldComplete) {
                            isOpen = true;
                        }
                        this.seek.progressEnd(shouldComplete).then(function () {
                            _this2.isOpening = false;
                            resolve(isOpen);
                        });
                        return promise;
                    }
                }, {
                    key: 'onDestory',
                    value: function onDestory() {
                        this.open && this.open.dispose();
                        this.close && this.close.dispose();
                        this.seek && this.seek.dispose();
                    }
                }]);

                return MenuType;
            })();

            _export('MenuType', MenuType);

            MenuRevealType = (function (_MenuType) {
                _inherits(MenuRevealType, _MenuType);

                function MenuRevealType(menu) {
                    _classCallCheck(this, MenuRevealType);

                    _get(Object.getPrototypeOf(MenuRevealType.prototype), 'constructor', this).call(this);
                    var easing = 'ease';
                    var duration = 250;
                    var openedX = menu.width() * (menu.side == 'right' ? -1 : 1) + 'px';
                    var closedX = '0px';
                    this.open.easing(easing).duration(duration);
                    this.close.easing(easing).duration(duration);
                    var contentOpen = new Animation(menu.getContentElement());
                    contentOpen.fromTo(TRANSLATE_X, closedX, openedX);
                    this.open.add(contentOpen);
                    var contentClose = new Animation(menu.getContentElement());
                    contentClose.fromTo(TRANSLATE_X, openedX, closedX);
                    this.close.add(contentClose);
                }

                return MenuRevealType;
            })(MenuType);

            Menu.register('reveal', MenuRevealType);
            /**
             * Menu Overlay Type
             * The menu slides over the content. The content
             * itself, which is under the menu, does not move.
             */

            MenuOverlayType = (function (_MenuType2) {
                _inherits(MenuOverlayType, _MenuType2);

                function MenuOverlayType(menu) {
                    _classCallCheck(this, MenuOverlayType);

                    _get(Object.getPrototypeOf(MenuOverlayType.prototype), 'constructor', this).call(this);
                    var easing = 'ease';
                    var duration = 250;
                    var backdropOpacity = 0.5;
                    var closedX = undefined,
                        openedX = undefined;
                    if (menu.side == 'right') {
                        // right side
                        closedX = menu.platform.width() + 'px';
                        openedX = menu.platform.width() - menu.width() - 8 + 'px';
                    } else {
                        // left side
                        closedX = -menu.width() + 'px';
                        openedX = '8px';
                    }
                    this.open.easing(easing).duration(duration);
                    this.close.easing(easing).duration(duration);
                    var menuOpen = new Animation(menu.getMenuElement());
                    menuOpen.fromTo(TRANSLATE_X, closedX, openedX);
                    this.open.add(menuOpen);
                    var backdropOpen = new Animation(menu.getBackdropElement());
                    backdropOpen.fromTo(OPACITY, 0.01, backdropOpacity);
                    this.open.add(backdropOpen);
                    var menuClose = new Animation(menu.getMenuElement());
                    menuClose.fromTo(TRANSLATE_X, openedX, closedX);
                    this.close.add(menuClose);
                    var backdropClose = new Animation(menu.getBackdropElement());
                    backdropClose.fromTo(OPACITY, backdropOpacity, 0.01);
                    this.close.add(backdropClose);
                }

                return MenuOverlayType;
            })(MenuType);

            Menu.register('overlay', MenuOverlayType);
            OPACITY = 'opacity';
            TRANSLATE_X = 'translateX';
        }
    };
});
System.register("ionic/components/menu/menu", ["angular2/angular2", "../ion", "../app/app", "../../config/config", "../../config/decorators", "../../platform/platform", "./menu-gestures"], function (_export) {
    /**
     * Menu is a side-menu navigation that can be dragged out or toggled to show.
     * Menu supports two display styles currently: overlay, and reveal. Overlay
     * is the tradtional Android drawer style, and Reveal is the traditional iOS
     * style. By default, Menu will adjust to the correct style for the platform.
     */
    "use strict";

    var forwardRef, Directive, Host, View, EventEmitter, ElementRef, Ion, IonicApp, IonicConfig, IonicComponent, IonicPlatform, gestures, __decorate, __metadata, __param, Menu, menuTypes, FALLBACK_MENU_TYPE, MenuBackdrop, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            forwardRef = _angular2Angular2.forwardRef;
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            View = _angular2Angular2.View;
            EventEmitter = _angular2Angular2.EventEmitter;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
        }, function (_platformPlatform) {
            IonicPlatform = _platformPlatform.IonicPlatform;
        }, function (_menuGestures) {
            gestures = _menuGestures;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Menu = (function (_Ion) {
                _inherits(Menu, _Ion);

                function Menu(app, elementRef, config, platform) {
                    _classCallCheck(this, Menu);

                    _get(Object.getPrototypeOf(Menu.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    this.platform = platform;
                    this.opening = new EventEmitter('opening');
                    this.isOpen = false;
                    this._disableTime = 0;
                }

                _createClass(Menu, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Menu.prototype), "onInit", this).call(this);
                        this._cntEle = this.content instanceof Node ? this.content : this.content.getNativeElement();
                        if (!this._cntEle) {
                            return console.error('Menu: must have a [content] element to listen for drag events on. Example:\n\n<ion-menu [content]="content"></ion-menu>\n\n<ion-content #content></ion-content>');
                        }
                        if (!this.id) {
                            // Auto register
                            this.id = 'menu';
                            this.app.register(this.id, this);
                        }
                        this._initGesture();
                        this._initType(this.type);
                        this._cntEle.classList.add('menu-content');
                        this._cntEle.classList.add('menu-content-' + this.type);
                        var self = this;
                        this.onContentClick = function (ev) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            self.close();
                        };
                    }
                }, {
                    key: "_initGesture",
                    value: function _initGesture() {
                        switch (this.side) {
                            case 'right':
                                this._gesture = new gestures.RightMenuGesture(this);
                                break;
                            case 'left':
                                this._gesture = new gestures.LeftMenuGesture(this);
                                break;
                        }
                    }
                }, {
                    key: "_initType",
                    value: function _initType(type) {
                        type = type && type.trim().toLowerCase() || FALLBACK_MENU_TYPE;
                        var menuTypeCls = menuTypes[type];
                        if (!menuTypeCls) {
                            type = FALLBACK_MENU_TYPE;
                            menuTypeCls = menuTypes[type];
                        }
                        this._type = new menuTypeCls(this);
                        this.type = type;
                    }

                    /**
                     * Sets the state of the Menu to open or not.
                     * @param {boolean} isOpen  If the Menu is open or not.
                     * @return {Promise} TODO
                     */
                }, {
                    key: "setOpen",
                    value: function setOpen(shouldOpen) {
                        var _this = this;

                        // _isDisabled is used to prevent unwanted opening/closing after swiping open/close
                        // or swiping open the menu while pressing down on the menu-toggle button
                        if (shouldOpen === this.isOpen || this._isDisabled()) {
                            return Promise.resolve();
                        }
                        this._before();
                        return this._type.setOpen(shouldOpen).then(function () {
                            _this._after(shouldOpen);
                        });
                    }
                }, {
                    key: "setProgressStart",
                    value: function setProgressStart() {
                        // user started swiping the menu open/close
                        if (this._isDisabled()) return;
                        this._before();
                        this._type.setProgressStart(this.isOpen);
                    }
                }, {
                    key: "setProgess",
                    value: function setProgess(value) {
                        // user actively dragging the menu
                        this._disable();
                        this.app.setTransitioning(true);
                        this._type.setProgess(value);
                    }
                }, {
                    key: "setProgressEnd",
                    value: function setProgressEnd(shouldComplete) {
                        var _this2 = this;

                        // user has finished dragging the menu
                        this._disable();
                        this.app.setTransitioning(true);
                        this._type.setProgressEnd(shouldComplete).then(function (isOpen) {
                            _this2._after(isOpen);
                        });
                    }
                }, {
                    key: "_before",
                    value: function _before() {
                        // this places the menu into the correct location before it animates in
                        // this css class doesn't actually kick off any animations
                        this.getNativeElement().classList.add('show-menu');
                        this.getBackdropElement().classList.add('show-backdrop');
                        this._disable();
                        this.app.setTransitioning(true);
                    }
                }, {
                    key: "_after",
                    value: function _after(isOpen) {
                        // keep opening/closing the menu disabled for a touch more yet
                        this._disable();
                        this.app.setTransitioning(false);
                        this.isOpen = isOpen;
                        this._cntEle.classList[isOpen ? 'add' : 'remove']('menu-content-open');
                        this._cntEle.removeEventListener('click', this.onContentClick);
                        if (isOpen) {
                            this._cntEle.addEventListener('click', this.onContentClick);
                        } else {
                            this.getNativeElement().classList.remove('show-menu');
                            this.getBackdropElement().classList.remove('show-backdrop');
                        }
                    }
                }, {
                    key: "_disable",
                    value: function _disable() {
                        // used to prevent unwanted opening/closing after swiping open/close
                        // or swiping open the menu while pressing down on the menu-toggle
                        this._disableTime = Date.now() + 20;
                    }
                }, {
                    key: "_isDisabled",
                    value: function _isDisabled() {
                        return this._disableTime > Date.now();
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "open",
                    value: function open() {
                        return this.setOpen(true);
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "close",
                    value: function close() {
                        return this.setOpen(false);
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        return this.setOpen(!this.isOpen);
                    }

                    /**
                     * TODO
                     * @return {Element} The Menu element.
                     */
                }, {
                    key: "getMenuElement",
                    value: function getMenuElement() {
                        return this.getNativeElement();
                    }

                    /**
                     * TODO
                     * @return {Element} The Menu's associated content element.
                     */
                }, {
                    key: "getContentElement",
                    value: function getContentElement() {
                        return this._cntEle;
                    }

                    /**
                     * TODO
                     * @return {Element} The Menu's backdrop element.
                     */
                }, {
                    key: "getBackdropElement",
                    value: function getBackdropElement() {
                        return this.backdrop.elementRef.nativeElement;
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.app.unregister(this.id);
                        this._gesture && this._gesture.destroy();
                        this._type && this._type.onDestroy();
                        this._cntEle = null;
                    }
                }], [{
                    key: "register",
                    value: function register(name, cls) {
                        menuTypes[name] = cls;
                    }
                }]);

                return Menu;
            })(Ion);

            _export("Menu", Menu);

            _export("Menu", Menu = __decorate([IonicComponent({
                selector: 'ion-menu',
                properties: ['content', 'dragThreshold', 'id'],
                defaultProperties: {
                    'side': 'left',
                    'type': 'reveal'
                },
                host: {
                    'role': 'navigation'
                },
                events: ['opening']
            }), View({
                template: '<ng-content></ng-content><backdrop tappable></backdrop>',
                directives: [forwardRef(function () {
                    return MenuBackdrop;
                })]
            }), __metadata('design:paramtypes', [typeof (_a = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _c || Object, typeof (_d = typeof IonicPlatform !== 'undefined' && IonicPlatform) === 'function' && _d || Object])], Menu));
            menuTypes = {};
            FALLBACK_MENU_TYPE = 'reveal';

            /**
             * TODO
             */

            MenuBackdrop = (function () {
                /**
                 * TODO
                 * @param {Menu} menu  TODO
                 */

                function MenuBackdrop(menu, elementRef) {
                    _classCallCheck(this, MenuBackdrop);

                    this.menu = menu;
                    this.elementRef = elementRef;
                    menu.backdrop = this;
                }

                /**
                 * TODO
                 * @param {TODO} event  TODO
                 */

                _createClass(MenuBackdrop, [{
                    key: "clicked",
                    value: function clicked(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.menu.close();
                    }
                }]);

                return MenuBackdrop;
            })();

            MenuBackdrop = __decorate([Directive({
                selector: 'backdrop',
                host: {
                    '(click)': 'clicked($event)'
                }
            }), __param(0, Host()), __metadata('design:paramtypes', [Menu, typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object])], MenuBackdrop);
        }
    };
});
System.register("ionic/components/modal/modal", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
     * @name ionModal
     * @description
     * The Modal is a content pane that can go over the user's main view temporarily. Usually used for making a choice or editing an item.
     *
     * @usage
     * ```ts
     * class MyApp {
     *
     *  constructor(modal: Modal, app: IonicApp, ionicConfig: IonicConfig) {
     *    this.modal = modal;
     *  }
     *
     *  openModal() {
     *    this.modal.open(ContactModal, {
     *      enterAnimation: 'my-fade-in',
     *      leaveAnimation: 'my-fade-out',
     *      handle: 'my-modal'
     *    });
     *  }
     * }
     * ```
     */
    "use strict";

    var Injectable, Overlay, Animation, util, __decorate, __metadata, Modal, OVERLAY_TYPE, ModalSlideIn, ModalSlideOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Injectable = _angular2Angular2.Injectable;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Modal = (function (_Overlay) {
                _inherits(Modal, _Overlay);

                function Modal() {
                    _classCallCheck(this, Modal);

                    _get(Object.getPrototypeOf(Modal.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(Modal, [{
                    key: "open",

                    /**
                     * TODO
                     * @param {Type} ComponentType  TODO
                     * @param {Object} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                    value: function open(ComponentType) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var defaults = {
                            enterAnimation: 'modal-slide-in',
                            leaveAnimation: 'modal-slide-out'
                        };
                        return this.create(OVERLAY_TYPE, ComponentType, util.extend(defaults, opts));
                    }

                    /**
                     * TODO
                     * @param {TODO} handle  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return Modal;
            })(Overlay);

            _export("Modal", Modal);

            _export("Modal", Modal = __decorate([Injectable(), __metadata('design:paramtypes', [])], Modal));
            OVERLAY_TYPE = 'modal';

            /**
             * Animations for modals
             */

            ModalSlideIn = (function (_Animation) {
                _inherits(ModalSlideIn, _Animation);

                function ModalSlideIn(element) {
                    _classCallCheck(this, ModalSlideIn);

                    _get(Object.getPrototypeOf(ModalSlideIn.prototype), "constructor", this).call(this, element);
                    this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).fromTo('translateY', '100%', '0%');
                }

                return ModalSlideIn;
            })(Animation);

            Animation.register('modal-slide-in', ModalSlideIn);

            ModalSlideOut = (function (_Animation2) {
                _inherits(ModalSlideOut, _Animation2);

                function ModalSlideOut(element) {
                    _classCallCheck(this, ModalSlideOut);

                    _get(Object.getPrototypeOf(ModalSlideOut.prototype), "constructor", this).call(this, element);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                return ModalSlideOut;
            })(Animation);

            Animation.register('modal-slide-out', ModalSlideOut);
        }
    };
});
System.register("ionic/components/material/button", ["angular2/angular2", "../../config/config"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Directive, IonicConfig, __decorate, __metadata, MaterialButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            MaterialButton = (function () {
                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function MaterialButton(elementRef, config) {
                    _classCallCheck(this, MaterialButton);

                    this.elementRef = elementRef;
                    this.config = config;
                }

                _createClass(MaterialButton, [{
                    key: "onInit",
                    value: function onInit() {
                        if (this.config.setting('mdRipple')) {}
                    }
                }]);

                return MaterialButton;
            })();

            _export("MaterialButton", MaterialButton);

            _export("MaterialButton", MaterialButton = __decorate([Directive({
                selector: 'button,[button]'
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], MaterialButton));
        }
    };
});
System.register('ionic/components/material/ripple', [], function (_export) {
    /**
     * Lovingly Adapted from Material Design Lite
     * Copyright Google, 2015, Licensed under the Apache 2 license.
     * https://github.com/google/material-design-lite
     */
    /**
     * TODO
     */
    'use strict';

    var MaterialRippleEffect;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            MaterialRippleEffect = (function () {
                /**
                 * TODO
                 * @param {MaterialButton} button  TODO
                 */

                function MaterialRippleEffect(button) {
                    _classCallCheck(this, MaterialRippleEffect);

                    this.elementRef = button.elementRef;
                    this.element = this.elementRef.nativeElement;
                    var rippleContainer = document.createElement('span');
                    rippleContainer.classList.add('md-ripple-container');
                    rippleContainer.setAttribute('aria-hidden', 'true');
                    this.rippleElement = document.createElement('span');
                    this.rippleElement.classList.add('md-ripple');
                    rippleContainer.appendChild(this.rippleElement);
                    this.recentering = false; //this.element.classList.contains(this.CssClasses_.RIPPLE_CENTER);
                    this.INITIAL_SCALE = 'scale(0.0001, 0.0001)';
                    this.INITIAL_SIZE = '1px';
                    this.INITIAL_OPACITY = '0.4';
                    this.FINAL_OPACITY = '0';
                    this.FINAL_SCALE = '';
                    //this.boundRippleBlurHandler = this.blurHandler.bind(this);
                    //this.rippleElement_.addEventListener('mouseup', this.boundRippleBlurHandler);
                    this.elementRef.nativeElement.appendChild(rippleContainer);
                    this._initRipple();
                }

                /**
                 * @private
                 * TODO
                 */

                _createClass(MaterialRippleEffect, [{
                    key: '_initRipple',
                    value: function _initRipple() {
                        this.frameCount = 0;
                        this.rippleSize = 0;
                        this.x = 0;
                        this.y = 0;
                        // Touch start produces a compat mouse down event, which would cause a
                        // second ripples. To avoid that, we use this property to ignore the first
                        // mouse down after a touch start.
                        this.ignoringMouseDown = false;
                        this.boundDownHandler = this.downHandler.bind(this);
                        this.element.addEventListener('mousedown', this.boundDownHandler);
                        this.element.addEventListener('touchstart', this.boundDownHandler);
                        this.boundUpHandler = this.upHandler.bind(this);
                        this.element.addEventListener('mouseup', this.boundUpHandler);
                        this.element.addEventListener('mouseleave', this.boundUpHandler);
                        this.element.addEventListener('touchend', this.boundUpHandler);
                        this.element.addEventListener('blur', this.boundUpHandler);
                    }

                    /**
                     * Handle mouse / finger down on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                }, {
                    key: 'downHandler',
                    value: function downHandler(event) {
                        'use strict';
                        if (!this.rippleElement.style.width && !this.rippleElement.style.height) {
                            var rect = this.element.getBoundingClientRect();
                            this.boundHeight = rect.height;
                            this.boundWidth = rect.width;
                            this.rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
                            this.rippleElement.style.width = this.rippleSize + 'px';
                            this.rippleElement.style.height = this.rippleSize + 'px';
                        }
                        this.rippleElement.classList.add('is-visible');
                        if (event.type === 'mousedown' && this.ignoringMouseDown) {
                            this.ignoringMouseDown = false;
                        } else {
                            if (event.type === 'touchstart') {
                                this.ignoringMouseDown = true;
                            }
                            var frameCount = this.getFrameCount();
                            if (frameCount > 0) {
                                return;
                            }
                            this.setFrameCount(1);
                            var bound = event.currentTarget.getBoundingClientRect();
                            var x;
                            var y;
                            // Check if we are handling a keyboard click.
                            if (event.clientX === 0 && event.clientY === 0) {
                                x = Math.round(bound.width / 2);
                                y = Math.round(bound.height / 2);
                            } else {
                                var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
                                var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
                                x = Math.round(clientX - bound.left);
                                y = Math.round(clientY - bound.top);
                            }
                            this.setRippleXY(x, y);
                            this.setRippleStyles(true);
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        }
                    }

                    /**
                     * Handle mouse / finger up on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                }, {
                    key: 'upHandler',
                    value: function upHandler(event) {
                        'use strict';
                        // Don't fire for the artificial "mouseup" generated by a double-click.
                        if (event && event.detail !== 2) {
                            setTimeout((function () {
                                this.rippleElement.classList.remove('is-visible');
                            }).bind(this), 150);
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getFrameCount',
                    value: function getFrameCount() {
                        return this.frameCount;
                    }

                    /**
                     * TODO
                     * @param {TODO} fC TODO
                     */
                }, {
                    key: 'setFrameCount',
                    value: function setFrameCount(fC) {
                        this.frameCount = fC;
                    }

                    /**
                     * TODO
                     * @return {Element} TODO
                     */
                }, {
                    key: 'getRippleElement',
                    value: function getRippleElement() {
                        return this.rippleElement;
                    }

                    /**
                     * TODO
                     * @param {number} newX  TODO
                     * @param {number} newY  TODO
                     */
                }, {
                    key: 'setRippleXY',
                    value: function setRippleXY(newX, newY) {
                        this.x = newX;
                        this.y = newY;
                    }

                    /**
                     * TODO
                     * @param {TODO} start  TODO
                     */
                }, {
                    key: 'setRippleStyles',
                    value: function setRippleStyles(start) {
                        if (this.rippleElement !== null) {
                            var transformString;
                            var scale;
                            var size;
                            var offset = 'translate(' + this.x + 'px, ' + this.y + 'px)';
                            if (start) {
                                scale = this.INITIAL_SCALE;
                                size = this.INITIAL_SIZE;
                            } else {
                                scale = this.FINAL_SCALE;
                                size = this.rippleSize + 'px';
                                if (this.recentering) {
                                    offset = 'translate(' + this.boundWidth / 2 + 'px, ' + this.boundHeight / 2 + 'px)';
                                }
                            }
                            transformString = 'translate(-50%, -50%) ' + offset + scale;
                            this.rippleElement.style.webkitTransform = transformString;
                            this.rippleElement.style.msTransform = transformString;
                            this.rippleElement.style.transform = transformString;
                            if (start) {
                                this.rippleElement.classList.remove('md-ripple-animating');
                            } else {
                                this.rippleElement.classList.add('md-ripple-animating');
                            }
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'animFrameHandler',
                    value: function animFrameHandler() {
                        if (this.frameCount-- > 0) {
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        } else {
                            this.setRippleStyles(false);
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'elementClicked',
                    value: function elementClicked(event) {}
                }]);

                return MaterialRippleEffect;
            })();

            _export('MaterialRippleEffect', MaterialRippleEffect);
        }
    };
});
System.register("ionic/components/nav/anchors", ["angular2/angular2", "angular2/src/core/compiler/view_container_ref", "./pane", "./nav-controller"], function (_export) {
    "use strict";

    var Component, View, Directive, Host, ElementRef, forwardRef, Inject, ViewContainerRef, Pane, NavController, __decorate, __metadata, __param, PaneAnchor, PaneContentAnchor, NavBarAnchor, NavBarContainer, _a, _b, _c, _d, _e, _f;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Inject = _angular2Angular2.Inject;
        }, function (_angular2SrcCoreCompilerView_container_ref) {
            ViewContainerRef = _angular2SrcCoreCompilerView_container_ref.ViewContainerRef;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_navController) {
            NavController = _navController.NavController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneAnchor = function PaneAnchor(pane, elementRef) {
                _classCallCheck(this, PaneAnchor);

                pane.sectionAnchorElementRef = elementRef;
            };

            _export("PaneAnchor", PaneAnchor);

            _export("PaneAnchor", PaneAnchor = __decorate([Directive({ selector: 'template[pane-anchor]' }), __param(0, Host()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata('design:paramtypes', [typeof (_a = typeof Pane !== 'undefined' && Pane) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object])], PaneAnchor));

            PaneContentAnchor = function PaneContentAnchor(pane, viewContainerRef) {
                _classCallCheck(this, PaneContentAnchor);

                pane.contentContainerRef = viewContainerRef;
            };

            _export("PaneContentAnchor", PaneContentAnchor);

            _export("PaneContentAnchor", PaneContentAnchor = __decorate([Directive({ selector: 'template[content-anchor]' }), __param(0, Host()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata('design:paramtypes', [typeof (_c = typeof Pane !== 'undefined' && Pane) === 'function' && _c || Object, typeof (_d = typeof ViewContainerRef !== 'undefined' && ViewContainerRef) === 'function' && _d || Object])], PaneContentAnchor));

            NavBarAnchor = function NavBarAnchor(navCtrl, viewContainerRef) {
                _classCallCheck(this, NavBarAnchor);

                navCtrl.navbarViewContainer(viewContainerRef);
            };

            NavBarAnchor = __decorate([Directive({
                selector: 'template[navbar-anchor]'
            }), __param(0, Inject(forwardRef(function () {
                return NavController;
            }))), __metadata('design:paramtypes', [typeof (_e = typeof NavController !== 'undefined' && NavController) === 'function' && _e || Object, typeof (_f = typeof ViewContainerRef !== 'undefined' && ViewContainerRef) === 'function' && _f || Object])], NavBarAnchor);

            NavBarContainer = function NavBarContainer() {
                _classCallCheck(this, NavBarContainer);
            };

            _export("NavBarContainer", NavBarContainer);

            _export("NavBarContainer", NavBarContainer = __decorate([Component({
                selector: 'section',
                host: {
                    'class': 'navbar-container'
                }
            }), View({
                template: '<template navbar-anchor></template>',
                directives: [NavBarAnchor]
            }), __metadata('design:paramtypes', [])], NavBarContainer));
        }
    };
});
System.register('ionic/components/nav/nav-controller', ['angular2/angular2', 'angular2/src/core/compiler/dynamic_component_loader', 'angular2/src/core/compiler/view_manager', '../ion', '../../config/config', '../app/app', './view-controller', './pane', '../../transitions/transition', './swipe-back', 'ionic/util'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var Compiler, Injector, bind, DynamicComponentLoader, AppViewManager, Ion, IonicConfig, IonicApp, ViewController, PaneController, Transition, SwipeBackGesture, util, NavController, ACTIVE_STATE, CACHED_STATE, STAGED_ENTERING_STATE, STAGED_LEAVING_STATE, ctrlIds, NavParams;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Compiler = _angular2Angular2.Compiler;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_angular2SrcCoreCompilerDynamic_component_loader) {
            DynamicComponentLoader = _angular2SrcCoreCompilerDynamic_component_loader.DynamicComponentLoader;
        }, function (_angular2SrcCoreCompilerView_manager) {
            AppViewManager = _angular2SrcCoreCompilerView_manager.AppViewManager;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_viewController) {
            ViewController = _viewController.ViewController;
        }, function (_pane) {
            PaneController = _pane.PaneController;
        }, function (_transitionsTransition) {
            Transition = _transitionsTransition.Transition;
        }, function (_swipeBack) {
            SwipeBackGesture = _swipeBack.SwipeBackGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            NavController = (function (_Ion) {
                _inherits(NavController, _Ion);

                function NavController(parentnavCtrl, injector, elementRef, zone) {
                    _classCallCheck(this, NavController);

                    var config = injector.get(IonicConfig);
                    _get(Object.getPrototypeOf(NavController.prototype), 'constructor', this).call(this, elementRef, config);
                    this.parent = parentnavCtrl;
                    this.compiler = injector.get(Compiler);
                    this.loader = injector.get(DynamicComponentLoader);
                    this.viewMngr = injector.get(AppViewManager);
                    this.app = injector.get(IonicApp);
                    this.config = config;
                    this.zone = zone;
                    this.views = [];
                    this.panes = new PaneController(this);
                    this._sbTrans = null;
                    this._sbEnabled = config.setting('swipeBackEnabled') || false;
                    this._sbThreshold = config.setting('swipeBackThreshold') || 40;
                    this.id = ++ctrlIds;
                    this._ids = -1;
                    this.zIndexes = -1;
                    // build a new injector for child ViewControllers to use
                    this.bindings = Injector.resolve([bind(NavController).toValue(this)]);
                }

                /**
                 * TODO
                 * @param {TODO} componentType  TODO
                 * @param {TODO} [params={}]  TODO
                 * @param {TODO} [opts={}]  TODO
                 * @returns {Promise} TODO
                 */

                _createClass(NavController, [{
                    key: 'push',
                    value: function push(componentType) {
                        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        if (!componentType) {
                            return Promise.reject();
                        }
                        if (typeof componentType !== 'function') {
                            throw 'Loading component must be a component class, not "' + componentType.toString() + '"';
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // do not animate if this is the first in the stack
                        if (!this.views.length) {
                            opts.animation = 'none';
                        }
                        // default the direction to "forward"
                        opts.direction = opts.direction || 'forward';
                        // the active view is going to be the leaving one (if one exists)
                        var leavingView = this.getActive() || new ViewController();
                        leavingView.shouldCache = util.isBoolean(opts.cacheleavingView) ? opts.cacheleavingView : true;
                        leavingView.shouldDestroy = !leavingView.shouldCache;
                        if (leavingView.shouldDestroy) {
                            leavingView.willUnload();
                        }
                        // create a new ViewController
                        var enteringView = new ViewController(this, componentType, params);
                        // add the view to the stack
                        this.add(enteringView);
                        if (this.router) {
                            // notify router of the state change
                            this.router.stateChange('push', enteringView, params);
                        }
                        // start the transition
                        this.transition(enteringView, leavingView, opts, function () {
                            resolve();
                        });
                        return promise;
                    }

                    /**
                     * TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'pop',
                    value: function pop() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        if (!this.canGoBack()) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // default the direction to "back"
                        opts.direction = opts.direction || 'back';
                        // get the active view and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingView = this.getActive() || new ViewController();
                        leavingView.shouldCache = util.isBoolean(opts.cacheleavingView) ? opts.cacheleavingView : false;
                        leavingView.shouldDestroy = !leavingView.shouldCache;
                        if (leavingView.shouldDestroy) {
                            leavingView.willUnload();
                        }
                        // the entering view is now the new last view
                        // Note: we might not have an entering view if this is the
                        // only view on the history stack.
                        var enteringView = this.getPrevious(leavingView);
                        if (enteringView) {
                            if (this.router) {
                                // notify router of the state change
                                this.router.stateChange('pop', enteringView);
                            }
                            // start the transition
                            this.transition(enteringView, leavingView, opts, function () {
                                // transition completed, destroy the leaving view
                                resolve();
                            });
                        } else {
                            this._transComplete();
                            resolve();
                        }
                        return promise;
                    }

                    /**
                     * Inserts a view into the nav stack at the specified index.
                     * @param {TODO} componentType  TODO
                     * @param {TODO} index TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'insert',
                    value: function insert(componentType, index) {
                        if (!componentType || index < 0) {
                            return Promise.reject();
                        }
                        // push it onto the end
                        if (index >= this.views.length) {
                            return this.push(componentType);
                        }
                        // create new ViewController, but don't render yet
                        var viewCtrl = new ViewController(this, componentType);
                        viewCtrl.state = CACHED_STATE;
                        viewCtrl.shouldDestroy = false;
                        viewCtrl.shouldCache = false;
                        this._incrementId(viewCtrl);
                        this.views.splice(index, 0, viewCtrl);
                    }

                    /**
                     * Set the view stack to reflect the given component classes.
                     * @param {TODO} components  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'setViews',
                    value: function setViews(components) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (!components || !components.length) {
                            return Promise.resolve();
                        }
                        // if animate has not been set then default to false
                        opts.animate = opts.animate || false;
                        // ensure leaving views are not cached, and should be destroyed
                        opts.cacheleavingView = false;
                        // get the views to auto remove without having to do a transiton for each
                        // the last view (the currently active one) will do a normal transition out
                        if (this.views.length > 1) {
                            var autoRemoveItems = this.views.slice(0, this.views.length - 1);
                            for (var i = 0; i < autoRemoveItems.length; i++) {
                                autoRemoveItems[i].shouldDestroy = true;
                                autoRemoveItems[i].shouldCache = false;
                                autoRemoveItems[i].willUnload();
                            }
                        }
                        var componentObj = null;
                        var componentType = null;
                        var viewCtrl = null;
                        // create the ViewControllers that go before the new active ViewController in the stack
                        // but the previous views won't should render yet
                        if (components.length > 1) {
                            var newBeforeItems = components.slice(0, components.length - 1);
                            for (var j = 0; j < newBeforeItems.length; j++) {
                                componentObj = newBeforeItems[j];
                                if (componentObj) {
                                    // could be an object with a componentType property, or it is a componentType
                                    componentType = componentObj.componentType || componentObj;
                                    viewCtrl = new ViewController(this, componentType, componentObj.params);
                                    viewCtrl.state = CACHED_STATE;
                                    viewCtrl.shouldDestroy = false;
                                    viewCtrl.shouldCache = false;
                                    // add the item to the stack
                                    this.add(viewCtrl);
                                }
                            }
                        }
                        // get the component that will become the active item
                        // it'll be the last one in the given components array
                        componentObj = components[components.length - 1];
                        componentType = componentObj.componentType || componentObj;
                        // transition the leaving and entering
                        return this.push(componentType, componentObj.params, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} componentType  TODO
                     * @param {TODO} [params={}]  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'setRoot',
                    value: function setRoot(componentType) {
                        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return this.setViews([{
                            componentType: componentType,
                            params: params
                        }], opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} enteringView  TODO
                     * @param {TODO} leavingView  TODO
                     * @param {TODO} opts  TODO
                     * @param {Function} callback  TODO
                     * @returns {any} TODO
                     */
                }, {
                    key: 'transition',
                    value: function transition(enteringView, leavingView, opts, callback) {
                        var _this = this;

                        if (!enteringView || enteringView === leavingView) {
                            return callback();
                        }
                        if (opts.animate === false) {
                            opts.animation = 'none';
                        } else if (!opts.animation) {
                            opts.animation = this.config.setting('viewTransition');
                        }
                        opts.animate = opts.animation !== 'none';
                        // wait for the new view to complete setup
                        enteringView.stage(function () {
                            _this.zone.runOutsideAngular(function () {
                                enteringView.shouldDestroy = false;
                                enteringView.shouldCache = false;
                                enteringView.willEnter();
                                leavingView.willLeave();
                                // set that the new view pushed on the stack is staged to be entering/leaving
                                // staged state is important for the transition to find the correct view
                                enteringView.state = STAGED_ENTERING_STATE;
                                leavingView.state = STAGED_LEAVING_STATE;
                                // init the transition animation
                                var transAnimation = Transition.create(_this, opts);
                                if (!opts.animate) {
                                    // force it to not animate the elements, just apply the "to" styles
                                    transAnimation.duration(0);
                                }
                                var duration = transAnimation.duration();
                                if (duration > 64) {
                                    // block any clicks during the transition and provide a
                                    // fallback to remove the clickblock if something goes wrong
                                    _this.app.setEnabled(false, duration);
                                    _this.app.setTransitioning(true, duration);
                                }
                                // start the transition
                                transAnimation.play().then(function () {
                                    // transition has completed, update each view's state
                                    enteringView.state = ACTIVE_STATE;
                                    leavingView.state = CACHED_STATE;
                                    // dispose any views that shouldn't stay around
                                    transAnimation.dispose();
                                    enteringView.didEnter();
                                    leavingView.didLeave();
                                    // all done!
                                    _this.zone.run(function () {
                                        _this._transComplete();
                                        callback();
                                    });
                                });
                            });
                        });
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'swipeBackStart',
                    value: function swipeBackStart() {
                        var _this2 = this;

                        if (!this.app.isEnabled() || !this.canSwipeBack()) {
                            return;
                        }
                        // disables the app during the transition
                        this.app.setEnabled(false);
                        this.app.setTransitioning(true);
                        // default the direction to "back"
                        var opts = {
                            direction: 'back'
                        };
                        // get the active view and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingView = this.getActive() || new ViewController();
                        leavingView.shouldDestroy = true;
                        leavingView.shouldCache = false;
                        leavingView.willLeave();
                        leavingView.willUnload();
                        // the entering view is now the new last view
                        var enteringView = this.getPrevious(leavingView);
                        enteringView.shouldDestroy = false;
                        enteringView.shouldCache = false;
                        enteringView.willEnter();
                        // wait for the new view to complete setup
                        enteringView.stage(function () {
                            _this2.zone.runOutsideAngular(function () {
                                // set that the new view pushed on the stack is staged to be entering/leaving
                                // staged state is important for the transition to find the correct view
                                enteringView.state = STAGED_ENTERING_STATE;
                                leavingView.state = STAGED_LEAVING_STATE;
                                // init the swipe back transition animation
                                _this2._sbTrans = Transition.create(_this2, opts);
                                _this2._sbTrans.easing('linear').progressStart();
                            });
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} progress  TODO
                     */
                }, {
                    key: 'swipeBackProgress',
                    value: function swipeBackProgress(value) {
                        if (this._sbTrans) {
                            // continue to disable the app while actively dragging
                            this.app.setEnabled(false, 4000);
                            this.app.setTransitioning(true, 4000);
                            // set the transition animation's progress
                            this._sbTrans.progress(value);
                        }
                    }

                    /**
                     * @private
                     * @param {TODO} completeSwipeBack  Should the swipe back complete or not.
                     * @param {number} rate  How fast it closes
                     */
                }, {
                    key: 'swipeBackEnd',
                    value: function swipeBackEnd(completeSwipeBack, rate) {
                        var _this3 = this;

                        if (!this._sbTrans) return;
                        // disables the app during the transition
                        this.app.setEnabled(false);
                        this.app.setTransitioning(true);
                        this._sbTrans.progressEnd(completeSwipeBack, rate).then(function () {
                            _this3.zone.run(function () {
                                // find the views that were entering and leaving
                                var enteringView = _this3.getStagedEnteringView();
                                var leavingView = _this3.getStagedLeavingView();
                                if (enteringView && leavingView) {
                                    // finish up the animation
                                    if (completeSwipeBack) {
                                        // swipe back has completed navigating back
                                        // update each view's state
                                        enteringView.state = ACTIVE_STATE;
                                        leavingView.state = CACHED_STATE;
                                        enteringView.didEnter();
                                        leavingView.didLeave();
                                        if (_this3.router) {
                                            // notify router of the pop state change
                                            _this3.router.stateChange('pop', enteringView);
                                        }
                                    } else {
                                        // cancelled the swipe back, they didn't end up going back
                                        // return views to their original state
                                        leavingView.state = ACTIVE_STATE;
                                        enteringView.state = CACHED_STATE;
                                        leavingView.willEnter();
                                        leavingView.didEnter();
                                        enteringView.didLeave();
                                        leavingView.shouldDestroy = false;
                                        enteringView.shouldDestroy = false;
                                    }
                                }
                                // empty out and dispose the swipe back transition animation
                                _this3._sbTrans && _this3._sbTrans.dispose();
                                _this3._sbTrans = null;
                                // all done!
                                _this3._transComplete();
                            });
                        });
                    }
                }, {
                    key: '_runSwipeBack',
                    value: function _runSwipeBack() {
                        if (this.canSwipeBack()) {
                            // it is possible to swipe back
                            if (this.sbGesture) {
                                // this is already an active gesture, don't create another one
                                return;
                            }
                            var opts = {
                                edge: 'left',
                                threshold: this._sbThreshold
                            };
                            this.sbGesture = new SwipeBackGesture(this.getNativeElement(), opts, this);
                            console.debug('SwipeBackGesture listen');
                            this.sbGesture.listen();
                        } else if (this.sbGesture) {
                            // it is not possible to swipe back and there is an
                            // active sbGesture, so unlisten it
                            console.debug('SwipeBackGesture unlisten');
                            this.sbGesture.unlisten();
                            this.sbGesture = null;
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isSwipeBackEnabled',
                    value: function isSwipeBackEnabled(val) {
                        if (arguments.length) {
                            this._sbEnabled = !!val;
                        }
                        return this._sbEnabled;
                    }

                    /**
                     * If it's possible to use swipe back or not. If it's not possible
                     * to go back, or swipe back is not enable then this will return false.
                     * If it is possible to go back, and swipe back is enabled, then this
                     * will return true.
                     * @returns {boolean}
                     */
                }, {
                    key: 'canSwipeBack',
                    value: function canSwipeBack() {
                        return this._sbEnabled && this.canGoBack();
                    }

                    /**
                     * Returns `true` if there's a valid previous view that we can pop back to.
                     * Otherwise returns false.
                     * @returns {boolean}
                     */
                }, {
                    key: 'canGoBack',
                    value: function canGoBack() {
                        var activeView = this.getActive();
                        if (activeView) {
                            return activeView.enableBack();
                        }
                        return false;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_transComplete',
                    value: function _transComplete() {
                        var _this4 = this;

                        var destroys = [];
                        this.views.forEach(function (view) {
                            if (view) {
                                if (view.shouldDestroy) {
                                    destroys.push(view);
                                } else if (view.state === CACHED_STATE && view.shouldCache) {
                                    view.shouldCache = false;
                                }
                            }
                        });
                        destroys.forEach(function (view) {
                            _this4.remove(view);
                            view.destroy();
                        });
                        // allow clicks again, but still set an enable time
                        // meaning nothing with this view controller can happen for XXms
                        this.app.setEnabled(true);
                        this.app.setTransitioning(false);
                        if (this.views.length === 1) {
                            this.elementRef.nativeElement.classList.add('has-views');
                        }
                        this._runSwipeBack();
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getActive',
                    value: function getActive() {
                        for (var i = 0, ii = this.views.length; i < ii; i++) {
                            if (this.views[i].state === ACTIVE_STATE) {
                                return this.views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} instance  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getByInstance',
                    value: function getByInstance(instance) {
                        if (instance) {
                            for (var i = 0, ii = this.views.length; i < ii; i++) {
                                if (this.views[i].instance === instance) {
                                    return this.views[i];
                                }
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} index  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getByIndex',
                    value: function getByIndex(index) {
                        if (index < this.views.length && index > -1) {
                            return this.views[index];
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} view  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getPrevious',
                    value: function getPrevious(view) {
                        if (view) {
                            return this.views[this.views.indexOf(view) - 1];
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getStagedEnteringView',
                    value: function getStagedEnteringView() {
                        for (var i = 0, ii = this.views.length; i < ii; i++) {
                            if (this.views[i].state === STAGED_ENTERING_STATE) {
                                return this.views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getStagedLeavingView',
                    value: function getStagedLeavingView() {
                        for (var i = 0, ii = this.views.length; i < ii; i++) {
                            if (this.views[i].state === STAGED_LEAVING_STATE) {
                                return this.views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} nbContainer  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarViewContainer',
                    value: function navbarViewContainer(nbContainer) {
                        if (nbContainer) {
                            this._nbContainer = nbContainer;
                        }
                        if (this._nbContainer) {
                            return this._nbContainer;
                        }
                        if (this.parent) {
                            return this.parent.navbarViewContainer();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'anchorElementRef',
                    value: function anchorElementRef() {
                        if (arguments.length) {
                            this._anchorER = arguments[0];
                        }
                        return this._anchorER;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'anchorViewContainerRef',
                    value: function anchorViewContainerRef() {
                        if (arguments.length) {
                            this._anchorVC = arguments[0];
                        }
                        return this._anchorVC;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'childNavbar',
                    value: function childNavbar() {
                        if (arguments.length) {
                            this._childNavbar = arguments[0];
                        }
                        return this._childNavbar;
                    }

                    /**
                     * TODO
                     * @param {TODO} view  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'add',
                    value: function add(view) {
                        this._incrementId(view);
                        this.views.push(view);
                    }
                }, {
                    key: '_incrementId',
                    value: function _incrementId(view) {
                        view.id = this.id + '-' + ++this._ids;
                    }

                    /**
                     * TODO
                     * @param {TODO} viewOrIndex  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'remove',
                    value: function remove(viewOrIndex) {
                        util.array.remove(this.views, viewOrIndex);
                    }

                    /**
                     * First view in this nav controller's stack. This would
                     * not return an view which is about to be destroyed.
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'first',
                    value: function first() {
                        for (var i = 0, l = this.views.length; i < l; i++) {
                            if (!this.views[i].shouldDestroy) {
                                return this.views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * Last view in this nav controller's stack. This would
                     * not return an view which is about to be destroyed.
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'last',
                    value: function last() {
                        for (var i = this.views.length - 1; i >= 0; i--) {
                            if (!this.views[i].shouldDestroy) {
                                return this.views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} view  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'indexOf',
                    value: function indexOf(view) {
                        return this.views.indexOf(view);
                    }

                    /**
                     * Number of sibling views in the nav controller. This does
                     * not include views which are about to be destroyed.
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'length',
                    value: function length() {
                        var len = 0;
                        for (var i = 0, l = this.views.length; i < l; i++) {
                            if (!this.views[i].shouldDestroy) {
                                len++;
                            }
                        }
                        return len;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'instances',
                    value: function instances() {
                        var instances = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.views[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var view = _step.value;

                                if (view.instance) {
                                    instances.push(view.instance);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return instances;
                    }

                    /**
                     * TODO
                     * @param {TODO} view  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isActive',
                    value: function isActive(view) {
                        return view && view.state === ACTIVE_STATE;
                    }

                    /**
                     * TODO
                     * @param {TODO} view  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isStagedEntering',
                    value: function isStagedEntering(view) {
                        return view && view.state === STAGED_ENTERING_STATE;
                    }

                    /**
                     * TODO
                     * @param {TODO} router  TODO
                     */
                }, {
                    key: 'registerRouter',
                    value: function registerRouter(router) {
                        this.router = router;
                    }
                }]);

                return NavController;
            })(Ion);

            _export('NavController', NavController);

            ACTIVE_STATE = 1;
            CACHED_STATE = 2;
            STAGED_ENTERING_STATE = 3;
            STAGED_LEAVING_STATE = 4;
            ctrlIds = -1;

            /**
             * TODO
             */

            NavParams = (function () {
                /**
                 * TODO
                 * @param {TODO} data  TODO
                 */

                function NavParams(data) {
                    _classCallCheck(this, NavParams);

                    this.data = data || {};
                }

                /**
                 * TODO
                 * @param {TODO} param  TODO
                 */

                _createClass(NavParams, [{
                    key: 'get',
                    value: function get(param) {
                        return this.data[param];
                    }
                }]);

                return NavParams;
            })();

            _export('NavParams', NavParams);
        }
    };
});
System.register("ionic/components/nav/nav-push", ["angular2/angular2", "./nav-controller", "./nav-registry"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, NavController, NavRegistry, __decorate, __metadata, NavPush, NavPop, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_navController) {
            NavController = _navController.NavController;
        }, function (_navRegistry) {
            NavRegistry = _navRegistry.NavRegistry;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            NavPush = (function () {
                /**
                 * TODO
                 * @param {NavController} nav  TODO
                 */

                function NavPush(nav, registry) {
                    _classCallCheck(this, NavPush);

                    this.nav = nav;
                    this.registry = registry;
                }

                _createClass(NavPush, [{
                    key: "onClick",
                    value: function onClick(event) {
                        var destination = undefined,
                            params = undefined;
                        if (this.instruction instanceof Array) {
                            if (this.instruction.length > 2) {
                                throw 'Too many [nav-push] arguments, expects [View, { params }]';
                            }
                            destination = this.instruction[0];
                            params = this.instruction[1] || this.params;
                        } else {
                            destination = this.instruction;
                            params = this.params;
                        }
                        if (typeof destination === "string") {
                            destination = this.registry.get(destination);
                        }
                        this.nav.push(destination, params);
                    }
                }]);

                return NavPush;
            })();

            _export("NavPush", NavPush);

            _export("NavPush", NavPush = __decorate([Directive({
                selector: '[nav-push]',
                properties: ['instruction: navPush', 'params: navParams'],
                host: {
                    '(click)': 'onClick($event)',
                    'role': 'link'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof NavRegistry !== 'undefined' && NavRegistry) === 'function' && _b || Object])], NavPush));
            /**
             * TODO
             */

            NavPop = (function () {
                /**
                 * TODO
                 * @param {NavController} nav  TODO
                 */

                function NavPop(nav) {
                    _classCallCheck(this, NavPop);

                    this.nav = nav;
                }

                _createClass(NavPop, [{
                    key: "onClick",
                    value: function onClick(event) {
                        this.nav.pop();
                    }
                }]);

                return NavPop;
            })();

            _export("NavPop", NavPop);

            _export("NavPop", NavPop = __decorate([Directive({
                selector: '[nav-pop]',
                host: {
                    '(click)': 'onClick($event)',
                    'role': 'link'
                }
            }), __metadata('design:paramtypes', [typeof (_c = typeof NavController !== 'undefined' && NavController) === 'function' && _c || Object])], NavPop));
        }
    };
});
System.register("ionic/components/nav/nav-registry", [], function (_export) {
    /**
     * Map of possible views that can be navigated to using an Ionic NavController
     */
    "use strict";

    var NavRegistry;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [],
        execute: function () {
            NavRegistry = (function () {
                function NavRegistry() {
                    var views = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

                    _classCallCheck(this, NavRegistry);

                    this._views = new Map(views.map(function (view) {
                        return [view.name, view];
                    }));
                }

                _createClass(NavRegistry, [{
                    key: "get",
                    value: function get(viewName) {
                        return this._views.get(viewName);
                    }
                }, {
                    key: "set",
                    value: function set(view) {
                        this._views.set(view.name, view);
                    }
                }]);

                return NavRegistry;
            })();

            _export("NavRegistry", NavRegistry);
        }
    };
});
System.register("ionic/components/nav/nav-router", ["angular2/angular2", "angular2/router", "./nav"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, ElementRef, DynamicComponentLoader, Attribute, RouterOutlet, Router, Instruction, Nav, __decorate, __metadata, __param, NavRouter, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            DynamicComponentLoader = _angular2Angular2.DynamicComponentLoader;
            Attribute = _angular2Angular2.Attribute;
        }, function (_angular2Router) {
            RouterOutlet = _angular2Router.RouterOutlet;
            Router = _angular2Router.Router;
            Instruction = _angular2Router.Instruction;
        }, function (_nav) {
            Nav = _nav.Nav;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            NavRouter = (function (_RouterOutlet) {
                _inherits(NavRouter, _RouterOutlet);

                /**
                 * TODO
                 * @param {ElementRef} _elementRef  TODO
                 * @param {DynamicComponentLoader} _loader  TODO
                 * @param {Router} _parentRouter  TODO
                 * @param {string} nameAttr  Value of the element's 'name' attribute
                 * @param {Nav} nav  TODO
                 */

                function NavRouter(_elementRef, _loader, _parentRouter, nameAttr, nav) {
                    _classCallCheck(this, NavRouter);

                    _get(Object.getPrototypeOf(NavRouter.prototype), "constructor", this).call(this, _elementRef, _loader, _parentRouter, nameAttr);
                    // Nav is Ionic's NavController, which we injected into this class
                    this.nav = nav;
                    // register this router with Ionic's NavController
                    // Ionic's NavController will call this NavRouter's "stateChange"
                    // method when the NavController has...changed its state
                    nav.registerRouter(this);
                }

                /**
                 * @private
                 * TODO
                 * @param {ComponentInstruction} instruction  TODO
                 */

                _createClass(NavRouter, [{
                    key: "activate",
                    value: function activate(nextInstruction) {
                        var previousInstruction = this._currentInstruction;
                        this._currentInstruction = nextInstruction;
                        var componentType = nextInstruction.componentType;
                        var childRouter = this._parentRouter.childRouter(componentType);
                        // prevent double navigations to the same view
                        var lastView = this.nav.last();
                        if (lastView && lastView.componentType === componentType && lastView.params.data === nextInstruction.params) {
                            return Promise.resolve();
                        }
                        // tell the NavController which componentType, and it's params, to navigate to
                        return this.nav.push(componentType, nextInstruction.params);
                    }
                }, {
                    key: "reuse",
                    value: function reuse(nextInstruction) {
                        return Promise.resolve();
                    }

                    /**
                     * TODO
                     * @param {TODO} type  TODO
                     * @param {TODO} viewCtrl  TODO
                     */
                }, {
                    key: "stateChange",
                    value: function stateChange(type, viewCtrl) {
                        // stateChange is called by Ionic's NavController
                        // type could be "push" or "pop"
                        // viewCtrl is Ionic's ViewController class, which has the properties "componentType" and "params"
                        // only do an update if there's an actual view change
                        if (!viewCtrl || this._activeViewId === viewCtrl.id) return;
                        this._activeViewId = viewCtrl.id;
                        // get the best PathRecognizer for this view's componentType
                        var pathRecognizer = this.getPathRecognizerByComponent(viewCtrl.componentType);
                        if (pathRecognizer) {
                            // generate a componentInstruction from the view's PathRecognizer and params
                            var componentInstruction = pathRecognizer.generate(viewCtrl.params.data);
                            // create an Instruction from the componentInstruction
                            var instruction = new Instruction(componentInstruction, null);
                            // update the browser's URL
                            this._parentRouter.navigateInstruction(instruction);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} componentType  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "getPathRecognizerByComponent",
                    value: function getPathRecognizerByComponent(componentType) {
                        // given a componentType, figure out the best PathRecognizer to use
                        var rules = this._parentRouter.registry._rules;
                        var pathRecognizer = null;
                        rules.forEach(function (rule) {
                            pathRecognizer = rule.matchers.find(function (matcherPathRecognizer) {
                                return matcherPathRecognizer.handler.componentType === componentType;
                            });
                        });
                        return pathRecognizer;
                    }
                }]);

                return NavRouter;
            })(RouterOutlet);

            _export("NavRouter", NavRouter);

            _export("NavRouter", NavRouter = __decorate([Directive({
                selector: 'ion-nav'
            }), __param(3, Attribute('name')), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof DynamicComponentLoader !== 'undefined' && DynamicComponentLoader) === 'function' && _b || Object, typeof (_c = typeof Router !== 'undefined' && Router) === 'function' && _c || Object, String, typeof (_d = typeof Nav !== 'undefined' && Nav) === 'function' && _d || Object])], NavRouter));
        }
    };
});
System.register("ionic/components/nav/nav", ["angular2/angular2", "../../config/decorators", "./nav-controller"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, View, ElementRef, Host, Optional, forwardRef, Injector, NgZone, IonicComponent, NavController, __decorate, __metadata, __param, Nav, NavPaneAnchor, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            NgZone = _angular2Angular2.NgZone;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
        }, function (_navController) {
            NavController = _navController.NavController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Nav = (function (_NavController) {
                _inherits(Nav, _NavController);

                /**
                 * TODO
                 * @param {NavController} hostnavCtrl  TODO
                 * @param {Injector} injector  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {NgZone} zone  TODO
                 */

                function Nav(hostnavCtrl, injector, elementRef, zone) {
                    _classCallCheck(this, Nav);

                    _get(Object.getPrototypeOf(Nav.prototype), "constructor", this).call(this, hostnavCtrl, injector, elementRef, zone);
                }

                /**
                 * TODO
                 */

                _createClass(Nav, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Nav.prototype), "onInit", this).call(this);
                        if (this.root) {
                            if (typeof this.root !== 'function') {
                                throw 'The [root] property in <ion-nav> must be given a reference to a component class from within the constructor.';
                            }
                            this.push(this.root);
                        }
                        // default the swipe back to be enabled
                        var isSwipeBackEnabled = (this.swipeBackEnabled || '').toString() !== 'false';
                        this.isSwipeBackEnabled(isSwipeBackEnabled);
                    }
                }]);

                return Nav;
            })(NavController);

            _export("Nav", Nav);

            _export("Nav", Nav = __decorate([IonicComponent({
                selector: 'ion-nav',
                properties: ['root'],
                defaultProperties: {
                    'swipeBackEnabled': true
                }
            }), View({
                template: '<template pane-anchor></template>',
                directives: [forwardRef(function () {
                    return NavPaneAnchor;
                })]
            }), __param(0, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof Injector !== 'undefined' && Injector) === 'function' && _b || Object, typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, typeof (_d = typeof NgZone !== 'undefined' && NgZone) === 'function' && _d || Object])], Nav));

            NavPaneAnchor = function NavPaneAnchor(nav, elementRef) {
                _classCallCheck(this, NavPaneAnchor);

                nav.anchorElementRef(elementRef);
            };

            NavPaneAnchor = __decorate([Directive({ selector: 'template[pane-anchor]' }), __param(0, Host()), __metadata('design:paramtypes', [Nav, typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object])], NavPaneAnchor);
        }
    };
});
System.register("ionic/components/nav/pane", ["angular2/angular2", "../ion", "../../config/config", "./nav-controller", "../../config/decorators", "./anchors"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var View, ElementRef, Inject, forwardRef, Injector, bind, Ion, IonicConfig, NavController, IonicComponent, PaneAnchor, PaneContentAnchor, NavBarContainer, __decorate, __metadata, __param, PaneController, Pane, _a, _b, _c;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_navController) {
            NavController = _navController.NavController;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
        }, function (_anchors) {
            PaneAnchor = _anchors.PaneAnchor;
            PaneContentAnchor = _anchors.PaneContentAnchor;
            NavBarContainer = _anchors.NavBarContainer;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneController = (function () {
                /**
                 * TODO
                 * @param {NavController} navCtrl  TODO
                 */

                function PaneController(navCtrl) {
                    _classCallCheck(this, PaneController);

                    this.panes = [];
                    this.navCtrl = navCtrl;
                    this.bindings = Injector.resolve([bind(NavController).toValue(navCtrl)]);
                }

                /**
                 * TODO
                 * @param {TODO} nav  TODO
                 * @param {Function} nav  TODO
                 */

                _createClass(PaneController, [{
                    key: "get",
                    value: function get(itemStructure, callback) {
                        var _this = this;

                        // this gets or creates the Pane which similar nav items live in
                        // Nav items with just a navbar/content would all use the same Pane
                        // Tabs and view's without a navbar would get a different Panes
                        var key = itemStructure.key;
                        var navCtrl = this.navCtrl;
                        var pane = this.panes[this.panes.length - 1];
                        if (pane && pane.key === key) {
                            // the last pane's structure is the same as the one the item needs to go in
                            callback(pane);
                        } else {
                            // create a new nav pane
                            navCtrl.loader.loadNextToLocation(Pane, navCtrl.anchorElementRef(), this.bindings).then(function (componentRef) {
                                // get the pane reference
                                pane = _this.newPane;
                                _this.newPane = null;
                                var sectionAnchorElementRef = pane && pane.sectionAnchorElementRef;
                                if (!sectionAnchorElementRef) {
                                    return callback();
                                }
                                pane.key = key;
                                pane.dispose = function () {
                                    componentRef.dispose();
                                    _this.panes.splice(_this.panes.indexOf(pane), 1);
                                };
                                _this.panes.push(pane);
                                var promises = [];
                                var sectionsToAdd = [];
                                // decide which sections should be added to this Pane, ie: nav bars, footers, etc.
                                // add only the sections it needs
                                if (itemStructure.navbar) {
                                    sectionsToAdd.push(NavBarContainer);
                                }
                                // add the sections which this type of Pane requires
                                sectionsToAdd.forEach(function (SectionClass) {
                                    // as each section is compiled and added to the Pane
                                    // the section will add a reference to itself in the Pane's sections object
                                    promises.push(navCtrl.loader.loadNextToLocation(SectionClass, sectionAnchorElementRef));
                                });
                                // wait for all of the sections to resolve
                                Promise.all(promises).then(function () {
                                    callback(pane);
                                }, function (err) {
                                    console.error(err);
                                });
                            }, function (loaderErr) {
                                console.error(loaderErr);
                            })["catch"](function (err) {
                                console.error(err);
                            });
                        }
                    }
                }, {
                    key: "add",
                    value: function add(pane) {
                        this.newPane = pane;
                    }
                }]);

                return PaneController;
            })();

            _export("PaneController", PaneController);

            Pane = (function (_Ion) {
                _inherits(Pane, _Ion);

                function Pane(navCtrl, elementRef, ionicConfig) {
                    _classCallCheck(this, Pane);

                    _get(Object.getPrototypeOf(Pane.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    navCtrl.panes.add(this);
                    this.totalItems = 0;
                    this.zIndex = ++navCtrl.zIndexes;
                }

                return Pane;
            })(Ion);

            _export("Pane", Pane);

            _export("Pane", Pane = __decorate([IonicComponent({
                selector: 'ion-pane',
                classId: 'nav',
                host: {
                    '[style.z-index]': 'zIndex'
                }
            }), View({
                template: "\n    <template pane-anchor></template>\n    <section class=\"content-container\">\n      <template content-anchor></template>\n    </section>\n  ",
                directives: [PaneAnchor, PaneContentAnchor]
            }), __param(0, Inject(forwardRef(function () {
                return NavController;
            }))), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _c || Object])], Pane));
        }
    };
});
System.register('ionic/components/nav/swipe-back', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, SwipeBackGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            SwipeBackGesture = (function (_SlideEdgeGesture) {
                _inherits(SwipeBackGesture, _SlideEdgeGesture);

                function SwipeBackGesture(element, opts, navCtrl) {
                    if (opts === undefined) opts = {};

                    _classCallCheck(this, SwipeBackGesture);

                    _get(Object.getPrototypeOf(SwipeBackGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                    this.navCtrl = navCtrl;
                }

                _createClass(SwipeBackGesture, [{
                    key: 'onSlideStart',
                    value: function onSlideStart() {
                        this.navCtrl.swipeBackStart();
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.navCtrl.swipeBackProgress(slide.distance / slide.max);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        var shouldComplete = Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5;
                        // TODO: calculate a better playback rate depending on velocity and distance
                        this.navCtrl.swipeBackEnd(shouldComplete, 1);
                    }
                }]);

                return SwipeBackGesture;
            })(SlideEdgeGesture);

            _export('SwipeBackGesture', SwipeBackGesture);
        }
    };
});
System.register("ionic/components/nav/swipe-handle", ["angular2/angular2", "../view/view-controller", "./pane", "ionic/gestures/gesture"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Directive, Host, Optional, Inject, forwardRef, NgZone, ViewController, Pane, Gesture, __decorate, __metadata, __param, SwipeHandle;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            NgZone = _angular2Angular2.NgZone;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            SwipeHandle = (function () {
                /**
                 * TODO
                 * @param {ViewController=} viewCtrl  TODO
                 * @param {Pane} pane  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {NgZone} ngZone  TODO
                 */

                function SwipeHandle(viewCtrl, pane, elementRef, ngZone) {
                    _classCallCheck(this, SwipeHandle);

                    if (!viewCtrl || !viewCtrl.isSwipeBackEnabled() || !pane) return;
                    var self = this;
                    self.pane = pane;
                    self.viewCtrl = viewCtrl;
                    self.zone = ngZone;
                    this.zone.runOutsideAngular(function () {
                        var gesture = self.gesture = new Gesture(elementRef.nativeElement);
                        gesture.listen();
                        function dragHorizontal(ev) {
                            self.onDragHorizontal(ev);
                        }
                        gesture.on('panend', function (gesture) {
                            self.onDragEnd(gesture);
                        });
                        gesture.on('panleft', dragHorizontal);
                        gesture.on('panright', dragHorizontal);
                    });
                    self.startX = null;
                    self.width = null;
                }

                _createClass(SwipeHandle, [{
                    key: "onDragEnd",
                    value: function onDragEnd(gesture) {
                        var _this = this;

                        gesture.srcEvent.preventDefault();
                        gesture.srcEvent.stopPropagation();
                        // TODO: POLISH THESE NUMBERS WITH GOOD MATHIFICATION
                        var progress = (gesture.center.x - this.startX) / this.width;
                        var completeSwipeBack = progress > 0.5;
                        var playbackRate = 4;
                        if (completeSwipeBack) {
                            // complete swipe back
                            if (progress > 0.9) {
                                playbackRate = 1;
                            } else if (progress > 0.8) {
                                playbackRate = 2;
                            } else if (progress > 0.7) {
                                playbackRate = 3;
                            }
                        } else {
                            // cancel swipe back
                            if (progress < 0.1) {
                                playbackRate = 1;
                            } else if (progress < 0.2) {
                                playbackRate = 2;
                            } else if (progress < 0.3) {
                                playbackRate = 3;
                            }
                        }
                        this.zone.run(function () {
                            _this.viewCtrl.swipeBackFinish(completeSwipeBack, playbackRate);
                        });
                        this.startX = null;
                    }
                }, {
                    key: "onDragHorizontal",
                    value: function onDragHorizontal(gesture) {
                        var _this2 = this;

                        this.zone.run(function () {
                            if (_this2.startX === null) {
                                // starting drag
                                gesture.srcEvent.preventDefault();
                                gesture.srcEvent.stopPropagation();
                                _this2.startX = gesture.center.x;
                                _this2.width = _this2.pane.width() - _this2.startX;
                                _this2.viewCtrl.swipeBackStart();
                            }
                            _this2.viewCtrl.swipeBackProgress((gesture.center.x - _this2.startX) / _this2.width);
                        });
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.gesture && this.gesture.destroy();
                    }
                }, {
                    key: "showHandle",
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.canSwipeBack() : false;
                    }
                }]);

                return SwipeHandle;
            })();

            _export("SwipeHandle", SwipeHandle);

            _export("SwipeHandle", SwipeHandle = __decorate([Directive({
                selector: '.swipe-handle',
                host: {
                    '[class.show-handle]': 'showHandle'
                }
            }), __param(0, Optional()), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __param(1, Host()), __param(1, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata('design:paramtypes', [typeof ViewController !== 'undefined' && ViewController || Object, typeof Pane !== 'undefined' && Pane || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof NgZone !== 'undefined' && NgZone || Object])], SwipeHandle));
        }
    };
});
System.register('ionic/components/nav/view-controller', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', './nav-controller'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var Component, bind, Injector, ComponentRef, DirectiveBinding, NavParams, ViewController;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function isComponent(elementBinder, id) {
        return elementBinder && elementBinder.componentDirective && elementBinder.componentDirective.metadata.id == id;
    }
    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            bind = _angular2Angular2.bind;
            Injector = _angular2Angular2.Injector;
            ComponentRef = _angular2Angular2.ComponentRef;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_navController) {
            NavParams = _navController.NavParams;
        }],
        execute: function () {
            ViewController = (function () {
                function ViewController(navCtrl, componentType) {
                    var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                    _classCallCheck(this, ViewController);

                    this.navCtrl = navCtrl;
                    this.componentType = componentType;
                    this.params = new NavParams(params);
                    this.instance = null;
                    this.state = 0;
                    this.disposals = [];
                    this.protos = {};
                    this._nbItms = [];
                    this._promises = [];
                    this.templateRefs = {};
                }

                /**
                 * TODO
                 * @param {TODO} name  TODO
                 * @param {TODO} protoViewRef  TODO
                 */

                _createClass(ViewController, [{
                    key: 'addProtoViewRef',
                    value: function addProtoViewRef(name, protoViewRef) {
                        this.protos[name] = protoViewRef;
                    }

                    /**
                     * TODO
                     * @param {TODO} name  TODO
                     * @param {TODO} templateRef  TODO
                     */
                }, {
                    key: 'addTemplateRef',
                    value: function addTemplateRef(name, templateRef) {
                        this.templateRefs[name] = templateRef;
                    }

                    /**
                     * TODO
                     * @param {Function} callback  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'stage',
                    value: function stage(callback) {
                        var _this = this;

                        var navCtrl = this.navCtrl;
                        if (this.instance || !navCtrl) {
                            // already compiled this view
                            return callback();
                        }
                        var annotation = new Component({
                            selector: 'ion-view',
                            host: {
                                'class': 'nav-item'
                            }
                        });
                        var ionViewComponentType = DirectiveBinding.createFromType(this.componentType, annotation);
                        // create a unique token that works as a cache key
                        ionViewComponentType.token = 'ionView' + this.componentType.name;
                        // compile the Component
                        navCtrl.compiler.compileInHost(ionViewComponentType).then(function (hostProtoViewRef) {
                            // figure out the sturcture of this Component
                            // does it have a navbar? Is it tabs? Should it not have a navbar or any toolbars?
                            var itemStructure = _this.sturcture = _this.inspectStructure(hostProtoViewRef);
                            // get the appropriate Pane which this ViewController will fit into
                            navCtrl.panes.get(itemStructure, function (pane) {
                                _this.pane = pane;
                                var bindings = navCtrl.bindings.concat(Injector.resolve([bind(NavParams).toValue(_this.params), bind(ViewController).toValue(_this)]));
                                // add the content of the view to the content area
                                // it will already have the correct context
                                var contentContainer = pane.contentContainerRef;
                                // the same guts as DynamicComponentLoader.loadNextToLocation
                                var hostViewRef = contentContainer.createHostView(hostProtoViewRef, -1, bindings);
                                var newLocation = navCtrl.viewMngr.getHostElement(hostViewRef);
                                var newComponent = navCtrl.viewMngr.getComponent(newLocation);
                                pane.totalItems++;
                                var dispose = function dispose() {
                                    var index = contentContainer.indexOf(hostViewRef);
                                    if (index !== -1) {
                                        contentContainer.remove(index);
                                        // remove the pane if there are no view items left
                                        pane.totalItems--;
                                        if (pane.totalItems === 0) {
                                            pane.dispose();
                                        }
                                    }
                                };
                                _this.disposals.push(dispose);
                                var viewComponetRef = new ComponentRef(newLocation, newComponent, dispose);
                                // get the component's instance, and set it to the this ViewController
                                _this.setInstance(viewComponetRef.instance);
                                _this.viewElementRef(viewComponetRef.location);
                                // // get the item container's nav bar
                                var navbarViewContainer = navCtrl.navbarViewContainer();
                                // // get the item's navbar protoview
                                var navbarTemplateRef = _this.templateRefs.navbar;
                                // add a navbar view if the pane has a navbar container, and the
                                // item's instance has a navbar protoview to go to inside of it
                                if (navbarViewContainer && navbarTemplateRef) {
                                    (function () {
                                        var navbarView = navbarViewContainer.createEmbeddedView(navbarTemplateRef, -1);
                                        _this.disposals.push(function () {
                                            var index = navbarViewContainer.indexOf(navbarView);
                                            if (index > -1) {
                                                navbarViewContainer.remove(index);
                                            }
                                        });
                                    })();
                                }
                                // this item has finished loading
                                try {
                                    _this.loaded();
                                } catch (e) {
                                    console.error(e);
                                }
                                // fire callback when all child promises have been resolved
                                Promise.all(_this._promises).then(function () {
                                    callback();
                                    _this._promises = [];
                                });
                            }, function (panesErr) {
                                console.error(panesErr);
                            });
                        }, function (compileInHostErr) {
                            console.error(compileInHostErr);
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} childPromise  TODO
                     */
                }, {
                    key: 'addPromise',
                    value: function addPromise(childPromise) {
                        this._promises.push(childPromise);
                    }

                    /**
                     * TODO
                     * @param {TODO} componentProtoViewRef  TODO
                     */
                }, {
                    key: 'inspectStructure',
                    value: function inspectStructure(componentProtoViewRef) {
                        var navbar = false;
                        var key = '_';
                        componentProtoViewRef._protoView.elementBinders.forEach(function (rootElementBinder) {
                            if (!rootElementBinder.componentDirective || !rootElementBinder.nestedProtoView) return;
                            rootElementBinder.nestedProtoView.elementBinders.forEach(function (nestedElementBinder) {
                                if (isComponent(nestedElementBinder, 'Tabs')) {
                                    navbar = true;
                                }
                                if (!nestedElementBinder.componentDirective && nestedElementBinder.nestedProtoView) {
                                    nestedElementBinder.nestedProtoView.elementBinders.forEach(function (templatedElementBinder) {
                                        if (isComponent(templatedElementBinder, 'Navbar')) {
                                            navbar = true;
                                        }
                                    });
                                }
                            });
                        });
                        if (this.navCtrl.childNavbar()) {
                            navbar = false;
                        }
                        if (navbar) key += 'n';
                        return {
                            navbar: navbar,
                            key: key
                        };
                    }

                    /**
                     * TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'enableBack',
                    value: function enableBack() {
                        // update if it's possible to go back from this nav item
                        if (this.navCtrl) {
                            var previousItem = this.navCtrl.getPrevious(this);
                            // the previous view may exist, but if it's about to be destroyed
                            // it shouldn't be able to go back to
                            return !!(previousItem && !previousItem.shouldDestroy);
                        }
                        return false;
                    }

                    /**
                     * TODO
                     * @param {TODO} instance  TODO
                     */
                }, {
                    key: 'setInstance',
                    value: function setInstance(instance) {
                        this.instance = instance;
                    }
                }, {
                    key: 'isRoot',
                    value: function isRoot() {
                        return this.index === 0;
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        for (var i = 0; i < this.disposals.length; i++) {
                            this.disposals[i]();
                        }
                        this.didUnload();
                        // just to help prevent any possible memory leaks
                        for (var _name in this) {
                            if (this.hasOwnProperty(_name)) {
                                this[_name] = null;
                            }
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'viewElementRef',
                    value: function viewElementRef(val) {
                        if (arguments.length) {
                            this._vwEle = val;
                        }
                        return this._vwEle;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarView',
                    value: function navbarView() {
                        if (arguments.length) {
                            this._nbView = arguments[0];
                        }
                        return this._nbView;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarRef',
                    value: function navbarRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getElementRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'titleRef',
                    value: function titleRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getTitleRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarItemRefs',
                    value: function navbarItemRefs() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getItemRefs();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'backBtnRef',
                    value: function backBtnRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getBackButtonRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'backBtnTextRef',
                    value: function backBtnTextRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getBackButtonTextRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarBackgroundRef',
                    value: function navbarBackgroundRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getNativeElement().querySelector('.toolbar-background');
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'postRender',
                    value: function postRender() {}
                    // the elements are in the DOM and the browser
                    // has rendered them in their correct locations

                    /**
                     * The view has loaded. This event only happens once per view being
                     * created. If a view leaves but is cached, then this will not
                     * fire again on a subsequent viewing. This method is a good place
                     * to put your setup code for the view; however, it is not the
                     * recommended method to use when a view becomes active.
                     */

                }, {
                    key: 'loaded',
                    value: function loaded() {
                        this.instance && this.instance.onViewLoaded && this.instance.onViewLoaded();
                    }

                    /**
                     * The view is about to enter and become the active view.
                     */
                }, {
                    key: 'willEnter',
                    value: function willEnter() {
                        this.instance && this.instance.onViewWillEnter && this.instance.onViewWillEnter();
                    }

                    /**
                     * The view has fully entered and is now the active view. This
                     * will fire, whether it was the first load or loaded from the cache.
                     */
                }, {
                    key: 'didEnter',
                    value: function didEnter() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.didEnter();
                        }
                        this.instance && this.instance.onViewDidEnter && this.instance.onViewDidEnter();
                    }

                    /**
                     * The view has is about to leave and no longer be the active view.
                     */
                }, {
                    key: 'willLeave',
                    value: function willLeave() {
                        this.instance && this.instance.onViewWillLeave && this.instance.onViewWillLeave();
                    }

                    /**
                     * The view has finished leaving and is no longer the active view. This
                     * will fire, whether it is cached or unloaded.
                     */
                }, {
                    key: 'didLeave',
                    value: function didLeave() {
                        this.instance && this.instance.onViewDidLeave && this.instance.onViewDidLeave();
                    }

                    /**
                     * The view is about to be destroyed and have its elements removed.
                     */
                }, {
                    key: 'willUnload',
                    value: function willUnload() {
                        this.instance && this.instance.onViewWillUnload && this.instance.onViewWillUnload();
                    }

                    /**
                     * The view has been destroyed and its elements have been removed.
                     */
                }, {
                    key: 'didUnload',
                    value: function didUnload() {
                        this.instance && this.instance.onViewDidUnload && this.instance.onViewDidUnload();
                    }
                }, {
                    key: 'index',
                    get: function get() {
                        return this.navCtrl ? this.navCtrl.indexOf(this) : -1;
                    }
                }]);

                return ViewController;
            })();

            _export('ViewController', ViewController);
        }
    };
});
System.register("ionic/components/nav-bar/nav-bar", ["angular2/angular2", "../ion", "../toolbar/toolbar", "../../config/config", "../../config/decorators", "../app/app", "../nav/view-controller", "../nav/nav-controller"], function (_export) {
    "use strict";

    var Component, Directive, Optional, ElementRef, TemplateRef, forwardRef, Inject, Ion, ToolbarBase, IonicConfig, IonicView, IonicApp, ViewController, NavController, __decorate, __metadata, __param, BackButton, BackButtonText, Navbar, NavbarTemplate, _a, _b, _c, _d, _e, _f, _g, _h, _j;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            TemplateRef = _angular2Angular2.TemplateRef;
            forwardRef = _angular2Angular2.forwardRef;
            Inject = _angular2Angular2.Inject;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_toolbarToolbar) {
            ToolbarBase = _toolbarToolbar.ToolbarBase;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicView = _configDecorators.IonicView;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            BackButton = (function (_Ion) {
                _inherits(BackButton, _Ion);

                function BackButton(navCtrl, elementRef, navbar) {
                    _classCallCheck(this, BackButton);

                    _get(Object.getPrototypeOf(BackButton.prototype), "constructor", this).call(this, elementRef, null);
                    this.navCtrl = navCtrl;
                    navbar && navbar.setBackButtonRef(elementRef);
                }

                _createClass(BackButton, [{
                    key: "goBack",
                    value: function goBack(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.navCtrl && this.navCtrl.pop();
                    }
                }]);

                return BackButton;
            })(Ion);

            BackButton = __decorate([Directive({
                selector: '.back-button',
                host: {
                    '(click)': 'goBack($event)'
                }
            }), __param(0, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, Navbar])], BackButton);

            BackButtonText = (function (_Ion2) {
                _inherits(BackButtonText, _Ion2);

                function BackButtonText(elementRef, navbar) {
                    _classCallCheck(this, BackButtonText);

                    _get(Object.getPrototypeOf(BackButtonText.prototype), "constructor", this).call(this, elementRef, null);
                    navbar && navbar.setBackButtonTextRef(elementRef);
                }

                return BackButtonText;
            })(Ion);

            BackButtonText = __decorate([Directive({
                selector: '.back-button-text'
            }), __param(1, Optional()), __param(1, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, Navbar])], BackButtonText);

            Navbar = (function (_ToolbarBase) {
                _inherits(Navbar, _ToolbarBase);

                function Navbar(app, viewCtrl, elementRef, config) {
                    _classCallCheck(this, Navbar);

                    _get(Object.getPrototypeOf(Navbar.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    viewCtrl && viewCtrl.navbarView(this);
                    this.bbIcon = config.setting('backButtonIcon');
                    this.bbDefault = config.setting('backButtonText');
                }

                _createClass(Navbar, [{
                    key: "getBackButtonRef",
                    value: function getBackButtonRef() {
                        return this.bbRef;
                    }
                }, {
                    key: "setBackButtonRef",
                    value: function setBackButtonRef(backButtonElementRef) {
                        this.bbRef = backButtonElementRef;
                    }
                }, {
                    key: "getBackButtonTextRef",
                    value: function getBackButtonTextRef() {
                        return this.bbtRef;
                    }
                }, {
                    key: "setBackButtonTextRef",
                    value: function setBackButtonTextRef(backButtonTextElementRef) {
                        this.bbtRef = backButtonTextElementRef;
                    }
                }, {
                    key: "didEnter",
                    value: function didEnter() {
                        this.app.title(this.getTitleText());
                    }
                }]);

                return Navbar;
            })(ToolbarBase);

            _export("Navbar", Navbar);

            _export("Navbar", Navbar = __decorate([Component({
                selector: 'ion-navbar',
                host: {
                    'class': 'toolbar'
                }
            }), IonicView({
                template: '<div class="toolbar-inner">' + '<button class="back-button">' + '<icon class="back-button-icon" [name]="bbIcon"></icon>' + '<span class="back-button-text">' + '<span class="back-default">{{bbDefault}}</span>' + '</span>' + '</button>' + '<ng-content select="[menu-toggle]"></ng-content>' + '<ng-content select="ion-title"></ng-content>' + '<ng-content select="ion-nav-items[primary]"></ng-content>' + '<ng-content select="ion-nav-items[secondary]"></ng-content>' + '</div>' + '<div class="toolbar-background"></div>',
                directives: [BackButton, BackButtonText]
            }), __param(1, Optional()), __metadata('design:paramtypes', [typeof (_d = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _d || Object, typeof (_e = typeof ViewController !== 'undefined' && ViewController) === 'function' && _e || Object, typeof (_f = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _f || Object, typeof (_g = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _g || Object])], Navbar));
            /*
              Used to find and register headers in a view, and this directive's
              content will be moved up to the common navbar location, and created
              using the same context as the view's content area.
            */

            NavbarTemplate = function NavbarTemplate(viewCtrl, templateRef) {
                _classCallCheck(this, NavbarTemplate);

                viewCtrl && viewCtrl.addTemplateRef('navbar', templateRef);
            };

            _export("NavbarTemplate", NavbarTemplate);

            _export("NavbarTemplate", NavbarTemplate = __decorate([Directive({
                selector: 'template[navbar]'
            }), __param(0, Optional()), __param(1, Optional()), __metadata('design:paramtypes', [typeof (_h = typeof ViewController !== 'undefined' && ViewController) === 'function' && _h || Object, typeof (_j = typeof TemplateRef !== 'undefined' && TemplateRef) === 'function' && _j || Object])], NavbarTemplate));
        }
    };
});
System.register('ionic/components/overlay/overlay', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../../animations/animation', 'ionic/util'], function (_export) {
    'use strict';

    var Component, DirectiveBinding, Animation, util, Overlay, OverlayRef, ROOT_Z_INDEX;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            Overlay = (function () {
                function Overlay(app, config) {
                    _classCallCheck(this, Overlay);

                    this.app = app;
                    this.config = config;
                    this.mode = config.setting('mode');
                }

                _createClass(Overlay, [{
                    key: 'create',
                    value: function create(overlayType, componentType) {
                        var _this = this;

                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
                        var context = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

                        return new Promise(function (resolve, reject) {
                            var app = _this.app;
                            var annotation = new Component({
                                selector: 'ion-' + overlayType,
                                host: {
                                    '[style.z-index]': 'zIndex',
                                    'mode': _this.mode,
                                    'class': overlayType
                                }
                            });
                            var overlayComponentType = DirectiveBinding.createFromType(componentType, annotation);
                            // create a unique token that works as a cache key
                            overlayComponentType.token = overlayType + componentType.name;
                            app.appendComponent(overlayComponentType).then(function (ref) {
                                var overlayRef = new OverlayRef(app, overlayType, opts, ref, context);
                                overlayRef._open(opts).then(function () {
                                    resolve(overlayRef);
                                });
                            })['catch'](function (err) {
                                console.error('Overlay appendComponent:', err);
                                reject(err);
                            });
                        })['catch'](function (err) {
                            console.error('Overlay create:', err);
                        });
                    }
                }, {
                    key: 'getByType',
                    value: function getByType(overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByHandle',
                    value: function getByHandle(handle, overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (handle === this.app.overlays[i]._handle && overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }]);

                return Overlay;
            })();

            _export('Overlay', Overlay);

            OverlayRef = (function () {
                function OverlayRef(app, overlayType, opts, ref, context) {
                    var _this2 = this;

                    _classCallCheck(this, OverlayRef);

                    this.app = app;
                    var overlayInstance = ref && ref.instance;
                    if (!overlayInstance) return;
                    if (context) {
                        util.extend(ref.instance, context);
                    }
                    this._instance = overlayInstance;
                    overlayInstance.onViewLoaded && overlayInstance.onViewLoaded();
                    this.zIndex = ROOT_Z_INDEX;
                    for (var i = 0; i < app.overlays.length; i++) {
                        if (app.overlays[i].zIndex >= this.zIndex) {
                            this.zIndex = app.overlays[i].zIndex + 1;
                        }
                    }
                    overlayInstance.zIndex = this.zIndex;
                    overlayInstance.overlayRef = this;
                    overlayInstance.close = function (instanceOpts) {
                        _this2.close(instanceOpts);
                    };
                    this._elementRef = ref.location;
                    this._type = overlayType;
                    this._opts = opts;
                    this._handle = opts.handle || this.zIndex;
                    this._dispose = function () {
                        _this2._instance = null;
                        ref.dispose && ref.dispose();
                        util.array.remove(app.overlays, _this2);
                    };
                    app.overlays.push(this);
                }

                _createClass(OverlayRef, [{
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this._elementRef;
                    }
                }, {
                    key: '_open',
                    value: function _open() {
                        var _this3 = this;

                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this3._instance || {};
                            instance.onViewWillEnter && instance.onViewWillEnter();
                            var animationName = opts && opts.animation || _this3._opts.enterAnimation;
                            var animation = Animation.create(_this3._elementRef.nativeElement, animationName);
                            animation.before.addClass('show-overlay');
                            _this3.app.setEnabled(false, animation.duration());
                            _this3.app.setTransitioning(true, animation.duration());
                            _this3.app.zoneRunOutside(function () {
                                animation.play().then(function () {
                                    _this3.app.zoneRun(function () {
                                        _this3.app.setEnabled(true);
                                        _this3.app.setTransitioning(false);
                                        animation.dispose();
                                        instance.onViewDidEnter && instance.onViewDidEnter();
                                        resolve();
                                    });
                                });
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }, {
                    key: 'close',
                    value: function close() {
                        var _this4 = this;

                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this4._instance || {};
                            instance.onViewWillLeave && instance.onViewWillLeave();
                            instance.onViewWillUnload && instance.onViewWillUnload();
                            var animationName = opts && opts.animation || _this4._opts.leaveAnimation;
                            var animation = Animation.create(_this4._elementRef.nativeElement, animationName);
                            animation.after.removeClass('show-overlay');
                            _this4.app.setEnabled(false, animation.duration());
                            _this4.app.setTransitioning(true, animation.duration());
                            animation.play().then(function () {
                                instance.onViewDidLeave && instance.onViewDidLeave();
                                instance.onViewDidUnload && instance.onViewDidUnload();
                                _this4._dispose();
                                _this4.app.setEnabled(true);
                                _this4.app.setTransitioning(false);
                                animation.dispose();
                                resolve();
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return OverlayRef;
            })();

            _export('OverlayRef', OverlayRef);

            ROOT_Z_INDEX = 1000;
        }
    };
});
System.register("ionic/components/popup/popup", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
     * @name ionPopup
     * @description
     * The Ionic Popup service allows programmatically creating and showing popup windows that require the user to respond in order to continue.
     *
     * The popup system has support for more flexible versions of the built in `alert()`, `prompt()`, and `confirm()` functions that users are used to, in addition to allowing popups with completely custom content and look.
     *
     * @usage
     * ```ts
     * class myApp {
     *
     *   constructor(popup: Popup) {
     *     this.popup = popup;
     *   }
     *
     *   doAlert() {
     *     this.popup.alert('Alert').then(() => {
     *       console.log('Alert closed');
     *     });
     *   }
     *
     *   doPrompt() {
     *     this.popup.prompt('What is your name?').then((name) => {
     *       console.log('Name entered:', name);
     *     }, () => {
     *       console.error('Prompt closed');
     *     });
     *   }
     *
     *   doConfirm() {
     *     this.popup.confirm('Are you sure?').then((result, ev) => {
     *       console.log('Confirmed!', result);
     *     }, () => {
     *       console.error('Not confirmed!');
     *     });
     *   }
     * }
     * ```
     */
    "use strict";

    var FORM_DIRECTIVES, Component, View, Injectable, NgClass, NgIf, NgFor, Overlay, Animation, util, __decorate, __metadata, Popup, OVERLAY_TYPE, StandardPopup, PopupAnimation, PopupPopIn, PopupPopOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x8, _x9, _x10) { var _again = true; _function: while (_again) { var object = _x8, property = _x9, receiver = _x10; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x8 = parent; _x9 = property; _x10 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            FORM_DIRECTIVES = _angular2Angular2.FORM_DIRECTIVES;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            NgClass = _angular2Angular2.NgClass;
            NgIf = _angular2Angular2.NgIf;
            NgFor = _angular2Angular2.NgFor;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Popup = (function (_Overlay) {
                _inherits(Popup, _Overlay);

                function Popup() {
                    _classCallCheck(this, Popup);

                    _get(Object.getPrototypeOf(Popup.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(Popup, [{
                    key: "popup",

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                    value: function popup(context) {
                        var _this = this;

                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        return new Promise(function (resolve, reject) {
                            var defaults = {
                                enterAnimation: 'popup-pop-in',
                                leaveAnimation: 'popup-pop-out'
                            };
                            context.promiseResolve = resolve;
                            context.promiseReject = reject;
                            return _this.create(OVERLAY_TYPE, StandardPopup, util.extend(defaults, opts), context);
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "alert",
                    value: function alert() {
                        var context = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === 'string') {
                            context = {
                                title: context
                            };
                        }
                        var button = {
                            text: 'OK',
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                                //resolve();
                            }
                        };
                        context = util.extend({
                            cancel: function cancel() {
                                //reject();
                            },
                            buttons: [button]
                        }, context);
                        return this.popup(context, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "confirm",
                    value: function confirm() {
                        var context = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === 'string') {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: 'OK',
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        var cancelButton = {
                            text: 'Cancel',
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        context = util.extend({
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} [context={}]  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "prompt",
                    value: function prompt() {
                        var context = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === 'string') {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: 'Ok',
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        var cancelButton = {
                            text: 'Cancel',
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        context = util.extend({
                            showPrompt: true,
                            promptPlaceholder: '',
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return Popup;
            })(Overlay);

            _export("Popup", Popup);

            _export("Popup", Popup = __decorate([Injectable(), __metadata('design:paramtypes', [])], Popup));
            OVERLAY_TYPE = 'popup';

            StandardPopup = (function () {
                function StandardPopup(popup) {
                    _classCallCheck(this, StandardPopup);

                    this.popup = popup;
                }

                _createClass(StandardPopup, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        setTimeout(function () {
                            _this2.element = _this2.overlayRef.getElementRef().nativeElement;
                            _this2.promptInput = _this2.element.querySelector('input');
                            if (_this2.promptInput) {
                                _this2.promptInput.value = '';
                            }
                        });
                    }
                }, {
                    key: "buttonTapped",
                    value: function buttonTapped(button, event) {
                        var promptValue = this.promptInput && this.promptInput.value;
                        var retVal = button.onTap && button.onTap(event, this, {
                            promptValue: promptValue
                        });
                        // If the event.preventDefault() wasn't called, close
                        if (!event.defaultPrevented) {
                            // If this is a cancel button, reject the promise
                            if (button.isCancel) {
                                this.promiseReject();
                            } else {
                                // Resolve with the prompt value
                                this.promiseResolve(promptValue);
                            }
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_cancel",
                    value: function _cancel(event) {
                        this.cancel && this.cancel(event);
                        if (!event.defaultPrevented) {
                            this.promiseReject();
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return StandardPopup;
            })();

            StandardPopup = __decorate([Component({
                selector: 'ion-popup-default'
            }), View({
                template: '<backdrop (click)="_cancel($event)" tappable></backdrop>' + '<popup-wrapper>' + '<div class="popup-head">' + '<h3 class="popup-title" [inner-html]="title"></h3>' + '<h5 class="popup-sub-title" [inner-html]="subTitle" *ng-if="subTitle"></h5>' + '</div>' + '<div class="popup-body">' + '<input type="text" *ng-if="showPrompt" placeholder="{{promptPlaceholder}}">' + '</div>' + '<div class="popup-buttons" *ng-if="buttons.length">' + '<button *ng-for="#button of buttons" (click)="buttonTapped(button, $event)" [ng-class]="button.type || \'button-default\'" [inner-html]="button.text"></button>' + '</div>' + '</popup-wrapper>',
                directives: [FORM_DIRECTIVES, NgClass, NgIf, NgFor]
            }), __metadata('design:paramtypes', [Popup])], StandardPopup);

            PopupAnimation = (function (_Animation) {
                _inherits(PopupAnimation, _Animation);

                function PopupAnimation(element) {
                    _classCallCheck(this, PopupAnimation);

                    _get(Object.getPrototypeOf(PopupAnimation.prototype), "constructor", this).call(this, element);
                    this.easing('ease-in-out').duration(200);
                    this.backdrop = new Animation(element.querySelector('backdrop'));
                    this.wrapper = new Animation(element.querySelector('popup-wrapper'));
                    this.add(this.backdrop, this.wrapper);
                }

                /**
                 * Animations for modals
                 */
                return PopupAnimation;
            })(Animation);

            PopupPopIn = (function (_PopupAnimation) {
                _inherits(PopupPopIn, _PopupAnimation);

                function PopupPopIn(element) {
                    _classCallCheck(this, PopupPopIn);

                    _get(Object.getPrototypeOf(PopupPopIn.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo('opacity', '0', '1');
                    this.wrapper.fromTo('scale', '1.1', '1');
                    this.backdrop.fromTo('opacity', '0', '0.3');
                }

                return PopupPopIn;
            })(PopupAnimation);

            Animation.register('popup-pop-in', PopupPopIn);

            PopupPopOut = (function (_PopupAnimation2) {
                _inherits(PopupPopOut, _PopupAnimation2);

                function PopupPopOut(element) {
                    _classCallCheck(this, PopupPopOut);

                    _get(Object.getPrototypeOf(PopupPopOut.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo('opacity', '1', '0');
                    this.wrapper.fromTo('scale', '1', '0.9');
                    this.backdrop.fromTo('opacity', '0.3', '0');
                }

                return PopupPopOut;
            })(PopupAnimation);

            Animation.register('popup-pop-out', PopupPopOut);
        }
    };
});
System.register("ionic/components/radio/radio", ["angular2/angular2", "../../config/decorators", "../../config/config", "../ion", "../list/list"], function (_export) {
    /**
     * @name ionRadioGroup
     * @description
     * A radio group is a group of radio components.
     *
     * Selecting a radio button in the group unselects all others in the group.
     *
     * New radios can be registered dynamically.
     *
     * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
     *
     * @usage
     * ```html
     * <ion-radio-group ng-control="clientside">
     *
     *   <ion-header>
     *     Clientside
     *   </ion-header>
     *
     *   <ion-radio value="ember">
     *     Ember
     *   </ion-radio>
     *
     *   <ion-radio value="angular1">
     *     Angular 1
     *   </ion-radio>
     *
     *   <ion-radio value="angular2" checked="true">
     *     Angular 2
     *   </ion-radio>
     *
     *   <ion-radio value="react">
     *     React
     *   </ion-radio>
     *
     * </ion-radio-group>
     * ```
    */
    "use strict";

    var ElementRef, Host, Optional, NgControl, Query, QueryList, IonicDirective, IonicComponent, IonicView, IonicConfig, Ion, ListHeader, __decorate, __metadata, __param, RadioGroup, RadioButton, radioGroupIds, _a, _b, _c, _d, _e, _f;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
            Query = _angular2Angular2.Query;
            QueryList = _angular2Angular2.QueryList;
        }, function (_configDecorators) {
            IonicDirective = _configDecorators.IonicDirective;
            IonicComponent = _configDecorators.IonicComponent;
            IonicView = _configDecorators.IonicView;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_listList) {
            ListHeader = _listList.ListHeader;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            RadioGroup = (function (_Ion) {
                _inherits(RadioGroup, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {NgControl=} ngControl  TODO
                 * @param {QueryList<ListHeader>} headerQuery  TODO
                 */

                function RadioGroup(elementRef, config, ngControl, headerQuery) {
                    _classCallCheck(this, RadioGroup);

                    _get(Object.getPrototypeOf(RadioGroup.prototype), "constructor", this).call(this, elementRef, config);
                    this.headerQuery = headerQuery;
                    this.radios = [];
                    this.id = ++radioGroupIds;
                    this.radioIds = -1;
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    if (ngControl) ngControl.valueAccessor = this;
                }

                _createClass(RadioGroup, [{
                    key: "onInit",
                    value: function onInit() {
                        var header = this.headerQuery.first;
                        if (header) {
                            if (!header.id) {
                                header.id = 'radio-header-' + this.id;
                            }
                            this.describedById = header.id;
                        }
                    }

                    /**
                     * Register the specified radio button with the radio group.
                     * @param {RadioButton} radio  The radio button to register.
                     */
                }, {
                    key: "registerRadio",
                    value: function registerRadio(radio) {
                        radio.id = radio.id || 'radio-' + this.id + '-' + ++this.radioIds;
                        this.radios.push(radio);
                        if (radio.checked) {
                            this.value = radio.value;
                            this.activeId = radio.id;
                        }
                    }

                    /**
                     * Update which radio button in the group is checked, unchecking all others.
                     * @param {RadioButton} checkedRadio  The radio button to check.
                     */
                }, {
                    key: "update",
                    value: function update(checkedRadio) {
                        this.value = checkedRadio.value;
                        this.activeId = checkedRadio.id;
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.radios[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var radio = _step.value;

                                radio.checked = radio === checkedRadio;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        this.onChange(this.value);
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the model (Control) on change to update
                     * the checked value.
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L34
                     */
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.value = value;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.radios[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var radio = _step2.value;

                                radio.checked = radio.value == value;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the view (NgControl) to register the
                     * onChange event handler that updates the model (Control).
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L27
                     * @param {Function} fn  the onChange event handler.
                     */
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the the view (NgControl) to register
                     * the onTouched event handler that marks the model (Control) as touched.
                     * @param {Function} fn  onTouched event handler.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return RadioGroup;
            })(Ion);

            _export("RadioGroup", RadioGroup);

            _export("RadioGroup", RadioGroup = __decorate([IonicDirective({
                selector: 'ion-radio-group',
                host: {
                    'class': 'list',
                    'role': 'radiogroup',
                    '[attr.aria-activedescendant]': 'activeId',
                    '[attr.aria-describedby]': 'describedById'
                }
            }), __param(2, Optional()), __param(3, Query(ListHeader)), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object, typeof (_c = typeof NgControl !== 'undefined' && NgControl) === 'function' && _c || Object, typeof (_d = typeof QueryList !== 'undefined' && QueryList) === 'function' && _d || Object])], RadioGroup));
            /**
             * @name ionRadio
             * @description
             * A single radio component.
             *
             * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
             *
             * @usage
             * ```html
             * <ion-radio value="isChecked" checked="true">
             *   Radio Label
             * </ion-radio>
             * ```
             *
             */

            RadioButton = (function (_Ion2) {
                _inherits(RadioButton, _Ion2);

                /**
                 * Radio button constructor.
                 * @param {RadioGroup=} group  The parent radio group, if any.
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function RadioButton(group, elementRef, config) {
                    _classCallCheck(this, RadioButton);

                    _get(Object.getPrototypeOf(RadioButton.prototype), "constructor", this).call(this, elementRef, config);
                    this.group = group;
                    this.tabIndex = 0;
                }

                _createClass(RadioButton, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(RadioButton.prototype), "onInit", this).call(this);
                        this.group.registerRadio(this);
                        this.labelId = 'label-' + this.id;
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.check();
                    }

                    /**
                     * Update the checked state of this radio button.
                     * TODO: Call this toggle? Since unchecks as well
                     */
                }, {
                    key: "check",
                    value: function check() {
                        this.checked = !this.checked;
                        this.group.update(this);
                    }
                }]);

                return RadioButton;
            })(Ion);

            _export("RadioButton", RadioButton);

            _export("RadioButton", RadioButton = __decorate([IonicComponent({
                selector: 'ion-radio',
                properties: ['value', 'checked', 'disabled', 'id'],
                host: {
                    'class': 'item',
                    'role': 'radio',
                    'tappable': 'true',
                    '[attr.id]': 'id',
                    '[attr.tab-index]': 'tabIndex',
                    '[attr.aria-checked]': 'checked',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'labelId',
                    '(click)': 'click($event)'
                }
            }), IonicView({
                template: '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>' + '<div item-right class="media-radio">' + '<div class="radio-icon"></div>' + '</div>'
            }), __param(0, Host()), __param(0, Optional()), __metadata('design:paramtypes', [RadioGroup, typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object, typeof (_f = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _f || Object])], RadioButton));
            radioGroupIds = -1;
        }
    };
});
System.register("ionic/components/scroll/pull-to-refresh", ["angular2/angular2", "../content/content", "ionic/util", "ionic/util/dom"], function (_export) {
    /**
     * @name ionRefresher
     * @description
     * Allows you to add pull-to-refresh to an ionContent component.
     *
     * Place it as the first child of your ionContent or ionScroll element.
     *
     * When refreshing is complete, call `refresher.complete()` from your controller.
     *
     *  @usage
     *  ```ts
     *  <ion-refresher (starting)="doStarting()" (refresh)="doRefresh($event, refresher)" (pulling)="doPulling($event, amt)">
     *
     *
     *  doRefresh(refresher) {
     *    console.log('Refreshing!', refresher);
     *
     *    setTimeout(() => {
     *      console.log('Pull to refresh complete!', refresher);
     *      refresher.complete();
     *    })
     *  }
     *
     *  doStarting() {
     *    console.log('Pull started!');
     *  }
     *
     *  doPulling(amt) {
     *    console.log('You have pulled', amt);
     *  }
     *  ```
     */
    "use strict";

    var Component, View, NgIf, NgClass, ElementRef, EventEmitter, Host, Content, util, raf, CSS, __decorate, __metadata, __param, Refresher, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            NgIf = _angular2Angular2.NgIf;
            NgClass = _angular2Angular2.NgClass;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Host = _angular2Angular2.Host;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicUtilDom) {
            raf = _ionicUtilDom.raf;
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Refresher = (function () {
                /**
                 * TODO
                 * @param {Content} content  TODO
                 * @param {ElementRef} elementRef  TODO
                 */

                function Refresher(content, element) {
                    _classCallCheck(this, Refresher);

                    this.ele = element.nativeElement;
                    this.ele.classList.add('content');
                    this.content = content;
                    this.refresh = new EventEmitter('refresh');
                    this.starting = new EventEmitter('starting');
                    this.pulling = new EventEmitter('pulling');
                }

                _createClass(Refresher, [{
                    key: "onInit",
                    value: function onInit() {
                        this.initEvents();
                    }

                    /**
                     * Initialize touch and scroll event listeners.
                     */
                }, {
                    key: "initEvents",
                    value: function initEvents() {
                        var sp = this.content.getNativeElement();
                        var sc = this.content.scrollElement;
                        this.isDragging = false;
                        this.isOverscrolling = false;
                        this.dragOffset = 0;
                        this.lastOverscroll = 0;
                        this.ptrThreshold = 60;
                        this.activated = false;
                        this.scrollTime = 500;
                        this.startY = null;
                        this.deltaY = null;
                        this.canOverscroll = true;
                        this.scrollHost = sp;
                        this.scrollChild = sc;
                        util.defaults(this, {
                            pullingIcon: 'ion-android-arrow-down',
                            refreshingIcon: 'ion-ionic'
                        });
                        this.showSpinner = !util.isDefined(this.refreshingIcon) && this.spinner != 'none';
                        this.showIcon = util.isDefined(this.refreshingIcon);
                        this._touchMoveListener = this._handleTouchMov.bind(this);
                        this._touchEndListener = this._handleTouchEnd.bind(this);
                        this._handleScrollListener = this._handleScroll.bind(this);
                        sc.addEventListener('touchmove', this._touchMoveListener);
                        sc.addEventListener('touchend', this._touchEndListener);
                        sc.addEventListener('scroll', this._handleScrollListener);
                    }
                }, {
                    key: "onDehydrate",
                    value: function onDehydrate() {
                        console.log('DEHYDRATION');
                        var sc = this.content.scrollElement;
                        sc.removeEventListener('touchmove', this._touchMoveListener);
                        sc.removeEventListener('touchend', this._touchEndListener);
                        sc.removeEventListener('scroll', this._handleScrollListener);
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     */
                }, {
                    key: "overscroll",
                    value: function overscroll(val) {
                        this.scrollChild.style[CSS.transform] = 'translateY(' + val + 'px)';
                        this.lastOverscroll = val;
                    }

                    /**
                     * TODO
                     * @param {TODO} target  TODO
                     * @param {TODO} newScrollTop  TODO
                     */
                }, {
                    key: "nativescroll",
                    value: function nativescroll(target, newScrollTop) {
                        // creates a scroll event that bubbles, can be cancelled, and with its view
                        // and detail property initialized to window and 1, respectively
                        target.scrollTop = newScrollTop;
                        var e = document.createEvent("UIEvents");
                        e.initUIEvent("scroll", true, true, window, 1);
                        target.dispatchEvent(e);
                    }

                    /**
                     * TODO
                     * @param {TODO} enabled  TODO
                     */
                }, {
                    key: "setScrollLock",
                    value: function setScrollLock(enabled) {
                        var _this = this;

                        // set the scrollbar to be position:fixed in preparation to overscroll
                        // or remove it so the app can be natively scrolled
                        if (enabled) {
                            raf(function () {
                                _this.scrollChild.classList.add('overscroll');
                                _this.show();
                            });
                        } else {
                            raf(function () {
                                _this.scrollChild.classList.remove('overscroll');
                                _this.hide();
                                _this.deactivate();
                            });
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "activate",
                    value: function activate() {
                        //this.ele.classList.add('active');
                        this.isActive = true;
                        //this.starting.next();
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "deactivate",
                    value: function deactivate() {
                        var _this2 = this;

                        // give tail 150ms to finish
                        setTimeout(function () {
                            _this2.isActive = false;
                            _this2.isRefreshing = false;
                            _this2.isRefreshingTail = false;
                            // deactivateCallback
                            if (_this2.activated) _this2.activated = false;
                        }, 150);
                    }
                }, {
                    key: "start",
                    value: function start() {
                        // startCallback
                        this.isRefreshing = true;
                        this.refresh.next(this);
                        //$scope.$onRefresh();
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "show",
                    value: function show() {
                        // showCallback
                        this.ele.classList.remove('invisible');
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "hide",
                    value: function hide() {
                        // showCallback
                        this.ele.classList.add('invisible');
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "tail",
                    value: function tail() {
                        // tailCallback
                        this.ele.classList.add('refreshing-tail');
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "complete",
                    value: function complete() {
                        var _this3 = this;

                        setTimeout(function () {
                            raf(_this3.tail.bind(_this3));
                            // scroll back to home during tail animation
                            _this3.scrollTo(0, _this3.scrollTime, _this3.deactivate.bind(_this3));
                            // return to native scrolling after tail animation has time to finish
                            setTimeout(function () {
                                if (_this3.isOverscrolling) {
                                    _this3.isOverscrolling = false;
                                    _this3.setScrollLock(false);
                                }
                            }, _this3.scrollTime);
                        }, this.scrollTime);
                    }

                    /**
                     * TODO
                     * @param {TODO} Y  TODO
                     * @param {TODO} duration  TODO
                     * @param {Function} callback  TODO
                     */
                }, {
                    key: "scrollTo",
                    value: function scrollTo(Y, duration, callback) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var start = Date.now(),
                            from = this.lastOverscroll;
                        if (from === Y) {
                            callback();
                            return; /* Prevent scrolling to the Y point if already there */
                        }
                        // decelerating to zero velocity
                        function easeOutCubic(t) {
                            return --t * t * t + 1;
                        }
                        // scroll loop
                        function scroll() {
                            var currentTime = Date.now(),
                                time = Math.min(1, (currentTime - start) / duration),

                            // where .5 would be 50% of time on a linear scale easedT gives a
                            // fraction based on the easing method
                            easedT = easeOutCubic(time);
                            this.overscroll(parseInt(easedT * (Y - from) + from, 10));
                            if (time < 1) {
                                raf(scroll.bind(this));
                            } else {
                                if (Y < 5 && Y > -5) {
                                    this.isOverscrolling = false;
                                    this.setScrollLock(false);
                                }
                                callback && callback();
                            }
                        }
                        // start scroll loop
                        raf(scroll.bind(this));
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleTouchMove",
                    value: function _handleTouchMove(e) {
                        //console.log('TOUCHMOVE', e);
                        // if multitouch or regular scroll event, get out immediately
                        if (!this.canOverscroll || e.touches.length > 1) {
                            return;
                        }
                        //if this is a new drag, keep track of where we start
                        if (this.startY === null) {
                            this.startY = parseInt(e.touches[0].screenY, 10);
                        }
                        // how far have we dragged so far?
                        this.deltaY = parseInt(e.touches[0].screenY, 10) - this.startY;
                        // if we've dragged up and back down in to native scroll territory
                        if (this.deltaY - this.dragOffset <= 0 || this.scrollHost.scrollTop !== 0) {
                            if (this.isOverscrolling) {
                                this.isOverscrolling = false;
                                this.setScrollLock(false);
                            }
                            if (this.isDragging) {
                                this.nativescroll(this.scrollHost, parseInt(this.deltaY - this.dragOffset, 10) * -1);
                            }
                            // if we're not at overscroll 0 yet, 0 out
                            if (this.lastOverscroll !== 0) {
                                this.overscroll(0);
                            }
                            return;
                        } else if (this.deltaY > 0 && this.scrollHost.scrollTop === 0 && !this.isOverscrolling) {
                            // starting overscroll, but drag started below scrollTop 0, so we need to offset the position
                            this.dragOffset = this.deltaY;
                        }
                        // prevent native scroll events while overscrolling
                        e.preventDefault();
                        // if not overscrolling yet, initiate overscrolling
                        if (!this.isOverscrolling) {
                            this.isOverscrolling = true;
                            this.setScrollLock(true);
                        }
                        this.isDragging = true;
                        // overscroll according to the user's drag so far
                        this.overscroll(parseInt((this.deltaY - this.dragOffset) / 3, 10));
                        // Pass an incremental pull amount to the EventEmitter
                        this.pulling.next(this.lastOverscroll);
                        // update the icon accordingly
                        if (!this.activated && this.lastOverscroll > this.ptrThreshold) {
                            this.activated = true;
                            raf(this.activate.bind(this));
                        } else if (this.activated && this.lastOverscroll < this.ptrThreshold) {
                            this.activated = false;
                            raf(this.deactivate.bind(this));
                        }
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleTouchEnd",
                    value: function _handleTouchEnd(e) {
                        console.log('TOUCHEND', e);
                        // if this wasn't an overscroll, get out immediately
                        if (!this.canOverscroll && !this.isDragging) {
                            return;
                        }
                        // reset Y
                        this.startY = null;
                        // the user has overscrolled but went back to native scrolling
                        if (!this.isDragging) {
                            this.dragOffset = 0;
                            this.isOverscrolling = false;
                            this.setScrollLock(false);
                        } else {
                            this.isDragging = false;
                            this.dragOffset = 0;
                            // the user has scroll far enough to trigger a refresh
                            if (this.lastOverscroll > this.ptrThreshold) {
                                this.start();
                                this.scrollTo(this.ptrThreshold, this.scrollTime);
                            } else {
                                this.scrollTo(0, this.scrollTime, this.deactivate.bind(this));
                                this.isOverscrolling = false;
                            }
                        }
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleScroll",
                    value: function _handleScroll(e) {
                        console.log('SCROLL', e.target.scrollTop);
                    }
                }]);

                return Refresher;
            })();

            _export("Refresher", Refresher);

            _export("Refresher", Refresher = __decorate([Component({
                selector: 'ion-refresher',
                events: ['refresh', 'starting', 'pulling'],
                properties: ['pullingIcon', 'pullingText', 'refreshingIcon', 'refreshingText', 'spinner', 'disablePullingRotation'],
                host: {
                    '[class.active]': 'isActive',
                    '[class.refreshing]': 'isRefreshing',
                    '[class.refreshingTail]': 'isRefreshingTail'
                }
            }), View({
                template: "<div class=\"refresher-content\" [class.refresher-with-text]=\"pullingText || refreshingText\">\n      <div class=\"icon-pulling\">\n        <i class=\"icon\" [ng-class]=\"pullingIcon\"></i>\n      </div>\n      <div class=\"text-pulling\" [inner-html]=\"pullingText\" *ng-if=\"pullingText\"></div>\n      <div class=\"icon-refreshing\">\n        <!--<ion-spinner ng-if=\"showSpinner\" icon=\"{{spinner}}\"></ion-spinner>-->\n        <i class=\"icon\" [ng-class]=\"refreshingIcon\"></i>\n      </div>\n      <div class=\"text-refreshing\" [inner-html]=\"refreshingText\" *ng-if=\"refreshingText\"></div>\n    </div>",
                directives: [NgIf, NgClass]
            }), __param(0, Host()), __metadata('design:paramtypes', [typeof (_a = typeof Content !== 'undefined' && Content) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object])], Refresher));
        }
    };
});
System.register("ionic/components/scroll/scroll", ["angular2/angular2", "../ion", "../../config/config", "../../config/decorators"], function (_export) {
    /**
     * ion-scroll is a non-flexboxed scroll area that can
     * scroll horizontally or vertically.
     */
    "use strict";

    var View, ElementRef, Ion, IonicConfig, IonicComponent, __decorate, __metadata, Scroll, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Scroll = (function (_Ion) {
                _inherits(Scroll, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function Scroll(elementRef, ionicConfig) {
                    _classCallCheck(this, Scroll);

                    _get(Object.getPrototypeOf(Scroll.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.maxScale = 3;
                    this.zoomDuration = 250;
                }

                _createClass(Scroll, [{
                    key: "onInit",
                    value: function onInit() {
                        this.scrollElement = this.getNativeElement().children[0];
                    }

                    /**
                     * Add a scroll event handler to the scroll element if it exists.
                     * @param {Function} handler  The scroll handler to add to the scroll element.
                     * @returns {?Function} a function to remove the specified handler, otherwise
                     * undefined if the scroll element doesn't exist.
                     */
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener('scroll', handler);
                        return function () {
                            _this.scrollElement.removeEventListener('scroll', handler);
                        };
                    }
                }]);

                return Scroll;
            })(Ion);

            _export("Scroll", Scroll);

            _export("Scroll", Scroll = __decorate([IonicComponent({
                selector: 'ion-scroll',
                properties: ['scrollX', 'scrollY', 'zoom', 'maxZoom'],
                host: {
                    '[class.scroll-x]': 'scrollX',
                    '[class.scroll-y]': 'scrollY'
                }
            }), View({
                template: '<scroll-content><div class="scroll-zoom-wrapper"><ng-content></ng-content></div></scroll-content>'
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object])], Scroll));
        }
    };
});
System.register("ionic/components/search-bar/search-bar", ["angular2/angular2", "../ion", "../../config/config", "../../config/decorators"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, SearchBar, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
            IonicView = _configDecorators.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            SearchBar = (function (_Ion) {
                _inherits(SearchBar, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function SearchBar(elementRef, config //,
                ) {
                    _classCallCheck(this, SearchBar);

                    _get(Object.getPrototypeOf(SearchBar.prototype), "constructor", this).call(this, elementRef, config);
                    // this.controlDirective = cd;
                    // cd.valueAccessor = this; //ControlDirective should inject CheckboxControlDirective
                    this.query = '';
                }

                /**
                 * Much like ngModel, this is called from our valueAccessor for the attached
                 * ControlDirective to update the value internally.
                 */

                _createClass(SearchBar, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.value = value;
                    }
                }, {
                    key: "inputChanged",
                    value: function inputChanged(event) {
                        this.value = event.target.value;
                        console.log('Search changed', this.value);
                        // TODO: Better way to do this?
                        this.controlDirective._control().updateValue(event.target.value);
                    }
                }, {
                    key: "inputFocused",
                    value: function inputFocused() {
                        this.isFocused = true;
                        this.shouldLeftAlign = true;
                    }
                }, {
                    key: "inputBlurred",
                    value: function inputBlurred() {
                        this.isFocused = false;
                        this.shouldLeftAlign = this.value.trim() != '';
                    }
                }]);

                return SearchBar;
            })(Ion);

            _export("SearchBar", SearchBar);

            _export("SearchBar", SearchBar = __decorate([IonicComponent({
                selector: 'ion-search-bar',
                properties: ['list', 'query'],
                defaultProperties: {
                    'cancelText': 'Cancel',
                    'placeholder': 'Search'
                }
            }), IonicView({
                template: "\n  <div class=\"search-bar-input-container\" [class.left-align]=\"shouldLeftAlign\">\n    <div class=\"search-bar-icon\"></div>\n    <input (focus)=\"inputFocused()\" (blur)=\"inputBlurred()\"\n    (input)=\"inputChanged($event)\" class=\"search-bar-input\" type=\"search\" [attr.placeholder]=\"placeholder\">\n  </div>\n  <button class=\"search-bar-cancel\">{{cancelText}}</button>"
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object])], SearchBar));
        }
    };
});

/*
export class SearchPipe extends Pipe {
  constructor() {
    super();
    this.state = 0;
  }

  supports(newValue) {
    return true;
  }

  transform(value, ...args) {
    console.log('Transforming', value, args);
    return value;
    //return `${value} state:${this.state ++}`;
  }

  create(cdRef) {
    console.log('REF', cdRef);
    return new SearchPipe(cdRef);
  }
}
*/
System.register("ionic/components/segment/segment", ["angular2/angular2", "angular2/forms", "../ion", "../../config/config", "../../config/decorators"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var View, Renderer, ElementRef, EventEmitter, Host, forwardRef, NgControl, Ion, IonicConfig, IonicDirective, IonicComponent, __decorate, __metadata, __param, Segment, SegmentControlValueAccessor, SegmentButton, _a, _b, _c, _d, _e, _f, _g, _h;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Renderer = _angular2Angular2.Renderer;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Host = _angular2Angular2.Host;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_angular2Forms) {
            NgControl = _angular2Forms.NgControl;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicDirective = _configDecorators.IonicDirective;
            IonicComponent = _configDecorators.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Segment = (function (_Ion) {
                _inherits(Segment, _Ion);

                /**
                 * TODO
                 * @param {NgControl} ngControl  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {Renderer} renderer  TODO
                 */

                function Segment(ngControl, elementRef, ionicConfig, renderer) {
                    _classCallCheck(this, Segment);

                    _get(Object.getPrototypeOf(Segment.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.ele = elementRef.nativeElement;
                    this.elementRef = elementRef;
                    this.renderer = renderer;
                    this.change = new EventEmitter('change');
                    this.input = new EventEmitter('input');
                    this.ngControl = ngControl;
                    this.buttons = [];
                }

                /**
                 * Called by child SegmentButtons to bind themselves to
                 * the Segment.
                 * @param {SegmentButton} segmentButton  The child SegmentButton to register.
                 */

                _createClass(Segment, [{
                    key: "register",
                    value: function register(segmentButton) {
                        this.buttons.push(segmentButton);
                        // If this button is registered and matches our value,
                        // make sure to select it
                        if (this.value == segmentButton.value) {
                            this.selected(segmentButton);
                        }
                    }

                    /**
                     * Select the button with the given value.
                     * @param {string} value  Value of the button to select.
                     */
                }, {
                    key: "selectFromValue",
                    value: function selectFromValue(value) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var button = _step.value;

                                if (button.value === value) {
                                    button.isActive = true;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }

                    /**
                     * Indicate a button should be selected.
                     * @param {SegmentButton} segmentButton  The button to select.
                     */
                }, {
                    key: "selected",
                    value: function selected(segmentButton) {
                        var _this = this;

                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var button = _step2.value;

                                button.isActive = false;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        segmentButton.isActive = true;
                        //this.onChange();
                        setTimeout(function () {
                            _this.value = segmentButton.value;
                            _this.ngControl.valueAccessor.writeValue(segmentButton.value);
                            _this.selectFromValue(segmentButton.value);
                            _this.ngControl.control.updateValue(segmentButton.value);
                            // Trigger on change
                            _this.change.next();
                        });
                        //this.ngControl.control().updateValue(this.value);
                        // TODO: Better way to do this?
                        //this.controlDirective._control().updateValue(this.value);
                    }
                }]);

                return Segment;
            })(Ion);

            _export("Segment", Segment);

            _export("Segment", Segment = __decorate([IonicComponent({
                selector: 'ion-segment',
                appInjector: [NgControl],
                properties: ['value'],
                host: {
                    '(click)': 'buttonClicked($event)',
                    '(change)': 'onChange($event)'
                }
            }), View({
                template: '<div class="ion-segment"><ng-content></ng-content></div>',
                directives: [forwardRef(function () {
                    return SegmentButton;
                })]
            }), __metadata('design:paramtypes', [typeof (_a = typeof NgControl !== 'undefined' && NgControl) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _c || Object, typeof (_d = typeof Renderer !== 'undefined' && Renderer) === 'function' && _d || Object])], Segment));
            /**
             * TODO
             */

            SegmentControlValueAccessor = (function () {
                /**
                 * TODO
                 * @param {NgControl} ngControl  TODO
                 * @param {Renderer} renderer  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {Segment} segment  TODO
                 */

                function SegmentControlValueAccessor(ngControl, renderer, elementRef, segment) {
                    _classCallCheck(this, SegmentControlValueAccessor);

                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.ngControl = ngControl;
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    this.segment = segment;
                    ngControl.valueAccessor = this;
                }

                _createClass(SegmentControlValueAccessor, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        // both this.value and setProperty are required at the moment
                        // remove when a proper imperative API is provided
                        this.value = !value ? '' : value;
                        this.renderer.setElementProperty(this.elementRef, 'value', this.value);
                        this.segment.value = this.value;
                        this.segment.selectFromValue(value);
                    }
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return SegmentControlValueAccessor;
            })();

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor);

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor = __decorate([IonicDirective({
                selector: 'ion-segment',
                //properties: ['value'],
                host: {
                    '(change)': 'onChange($event.target.value)',
                    '(input)': 'onChange($event.target.value)',
                    '(blur)': 'onTouched()'
                }
            }), __metadata('design:paramtypes', [typeof (_e = typeof NgControl !== 'undefined' && NgControl) === 'function' && _e || Object, typeof (_f = typeof Renderer !== 'undefined' && Renderer) === 'function' && _f || Object, typeof (_g = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _g || Object, Segment])], SegmentControlValueAccessor));
            /**
             * TODO
             */

            SegmentButton = (function () {
                /**
                 * TODO
                 * @param {Segment} segment  TODO
                 * @param {ElementRef} elementRef  TODO
                 */

                function SegmentButton(segment, elementRef) {
                    _classCallCheck(this, SegmentButton);

                    this.ele = elementRef.ele;
                    this.segment = segment;
                }

                _createClass(SegmentButton, [{
                    key: "onInit",
                    value: function onInit() {
                        this.segment.register(this);
                    }
                }, {
                    key: "buttonClicked",
                    value: function buttonClicked(event) {
                        this.segment.selected(this, event);
                        event.preventDefault();
                    }
                }]);

                return SegmentButton;
            })();

            _export("SegmentButton", SegmentButton);

            _export("SegmentButton", SegmentButton = __decorate([IonicDirective({
                selector: 'ion-segment-button',
                properties: ['value'],
                host: {
                    '(click)': 'buttonClicked($event)',
                    '[class.active]': 'isActive'
                }
            }), __param(0, Host()), __metadata('design:paramtypes', [Segment, typeof (_h = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _h || Object])], SegmentButton));
        }
    };
});
System.register("ionic/components/show-hide-when/show-hide-when", ["angular2/angular2", "../../platform/platform"], function (_export) {
    "use strict";

    var Directive, Attribute, NgZone, IonicPlatform, __decorate, __metadata, __param, DisplayWhen, ShowWhen, HideWhen, _a, _b, _c, _d;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Attribute = _angular2Angular2.Attribute;
            NgZone = _angular2Angular2.NgZone;
        }, function (_platformPlatform) {
            IonicPlatform = _platformPlatform.IonicPlatform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            DisplayWhen = (function () {
                function DisplayWhen(conditions, platform, ngZone) {
                    var _this = this;

                    _classCallCheck(this, DisplayWhen);

                    this.isMatch = false;
                    this.platform = platform;
                    if (!conditions) return;
                    this.conditions = conditions.split(',');
                    // check if its one of the matching platforms first
                    // a platform does not change during the life of an app
                    for (var i = 0; i < this.conditions.length; i++) {
                        if (this.conditions[i] && platform.is(this.conditions[i])) {
                            this.isMatch = true;
                            return;
                        }
                    }
                    if (this.orientation()) {
                        // add window resize listener
                        platform.onResize(function () {
                            ngZone.run(function () {
                                _this.orientation();
                            });
                        });
                        return;
                    }
                }

                /**
                 * TODO
                 */

                _createClass(DisplayWhen, [{
                    key: "orientation",
                    value: function orientation() {
                        for (var i = 0; i < this.conditions.length; i++) {
                            if (this.conditions[i] == 'portrait') {
                                this.isMatch = this.platform.isPortrait();
                                return true;
                            }
                            if (this.conditions[i] == 'landscape') {
                                this.isMatch = this.platform.isLandscape();
                                return true;
                            }
                        }
                    }
                }]);

                return DisplayWhen;
            })();

            ShowWhen = (function (_DisplayWhen) {
                _inherits(ShowWhen, _DisplayWhen);

                /**
                 * TODO
                 * @param {string} showWhen  The value of the element's 'show-when' attribute
                 * @param {NgZone} ngZone  TODO
                 */

                function ShowWhen(showWhen, platform, ngZone) {
                    _classCallCheck(this, ShowWhen);

                    _get(Object.getPrototypeOf(ShowWhen.prototype), "constructor", this).call(this, showWhen, platform, ngZone);
                }

                _createClass(ShowWhen, [{
                    key: "hidden",
                    get: function get() {
                        return !this.isMatch;
                    }
                }]);

                return ShowWhen;
            })(DisplayWhen);

            _export("ShowWhen", ShowWhen);

            _export("ShowWhen", ShowWhen = __decorate([Directive({
                selector: '[show-when]',
                host: {
                    '[hidden]': 'hidden'
                }
            }), __param(0, Attribute('show-when')), __metadata('design:paramtypes', [String, typeof (_a = typeof IonicPlatform !== 'undefined' && IonicPlatform) === 'function' && _a || Object, typeof (_b = typeof NgZone !== 'undefined' && NgZone) === 'function' && _b || Object])], ShowWhen));
            /**
             * TODO
             */

            HideWhen = (function (_DisplayWhen2) {
                _inherits(HideWhen, _DisplayWhen2);

                /**
                 * TODO
                 * @param {string} showWhen  The value of the element's 'hide-when' attribute
                 * @param {NgZone} ngZone  TODO
                 */

                function HideWhen(hideWhen, platform, ngZone) {
                    _classCallCheck(this, HideWhen);

                    _get(Object.getPrototypeOf(HideWhen.prototype), "constructor", this).call(this, hideWhen, platform, ngZone);
                }

                _createClass(HideWhen, [{
                    key: "hidden",
                    get: function get() {
                        return this.isMatch;
                    }
                }]);

                return HideWhen;
            })(DisplayWhen);

            _export("HideWhen", HideWhen);

            _export("HideWhen", HideWhen = __decorate([Directive({
                selector: '[hide-when]',
                host: {
                    '[hidden]': 'hidden'
                }
            }), __param(0, Attribute('hide-when')), __metadata('design:paramtypes', [String, typeof (_c = typeof IonicPlatform !== 'undefined' && IonicPlatform) === 'function' && _c || Object, typeof (_d = typeof NgZone !== 'undefined' && NgZone) === 'function' && _d || Object])], HideWhen));
        }
    };
});
System.register("ionic/components/slides/slides", ["angular2/angular2", "../ion", "ionic/animations/animation", "ionic/gestures/gesture", "../../config/decorators", "../../config/config", "ionic/util", "../../util/dom", "./swiper-widget"], function (_export) {
    /**
     * Slides is a slide box implementation based on Swiper.js
     *
     * Swiper.js:
     * The most modern mobile touch slider and framework with hardware accelerated transitions
     *
     * http://www.idangero.us/swiper/
     *
     * Copyright 2015, Vladimir Kharlampidi
     * The iDangero.us
     * http://www.idangero.us/
     *
     * Licensed under MIT
     *
     */
    "use strict";

    var View, ElementRef, Host, NgIf, NgClass, Ion, Animation, Gesture, IonicComponent, IonicDirective, IonicConfig, dom, util, CSS, Swiper, __decorate, __metadata, __param, Slides, Slide, SlideLazy, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            NgIf = _angular2Angular2.NgIf;
            NgClass = _angular2Angular2.NgClass;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_ionicAnimationsAnimation) {
            Animation = _ionicAnimationsAnimation.Animation;
        }, function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
            IonicDirective = _configDecorators.IonicDirective;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
            util = _ionicUtil;
        }, function (_utilDom) {
            CSS = _utilDom.CSS;
        }, function (_swiperWidget) {
            Swiper = _swiperWidget.Swiper;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Slides = (function (_Ion) {
                _inherits(Slides, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 */

                function Slides(elementRef, config) {
                    var _this = this;

                    _classCallCheck(this, Slides);

                    _get(Object.getPrototypeOf(Slides.prototype), "constructor", this).call(this, elementRef, config);
                    this.rapidUpdate = util.debounce(function () {
                        _this.update();
                    }, 10);
                }

                _createClass(Slides, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        if (!this.options) {
                            this.options = {};
                        }
                        this.showPager = util.isTrueProperty(this.pager);
                        var options = util.defaults({
                            pagination: '.swiper-pagination',
                            paginationClickable: true,
                            lazyLoading: true,
                            preloadImages: false
                        }, this.options);
                        options.onTap = function (swiper, e) {
                            _this2.onTap(swiper, e);
                            return _this2.options.onTap && _this2.options.onTap(swiper, e);
                        };
                        options.onClick = function (swiper, e) {
                            _this2.onClick(swiper, e);
                            return _this2.options.onClick && _this2.options.onClick(swiper, e);
                        };
                        options.onDoubleTap = function (swiper, e) {
                            _this2.onDoubleTap(swiper, e);
                            return _this2.options.onDoubleTap && _this2.options.onDoubleTap(swiper, e);
                        };
                        options.onTransitionStart = function (swiper, e) {
                            _this2.onTransitionStart(swiper, e);
                            return _this2.options.onTransitionStart && _this2.options.onTransitionStart(swiper, e);
                        };
                        options.onTransitionEnd = function (swiper, e) {
                            _this2.onTransitionEnd(swiper, e);
                            return _this2.options.onTransitionEnd && _this2.options.onTransitionEnd(swiper, e);
                        };
                        options.onSlideChangeStart = function (swiper) {
                            return _this2.options.onSlideChangeStart && _this2.options.onSlideChangeStart(swiper);
                        };
                        options.onSlideChangeEnd = function (swiper) {
                            return _this2.options.onSlideChangeEnd && _this2.options.onSlideChangeEnd(swiper);
                        };
                        options.onLazyImageLoad = function (swiper, slide, img) {
                            return _this2.options.onLazyImageLoad && _this2.options.onLazyImageLoad(swiper, slide, img);
                        };
                        options.onLazyImageReady = function (swiper, slide, img) {
                            return _this2.options.onLazyImageReady && _this2.options.onLazyImageReady(swiper, slide, img);
                        };
                        var swiper = new Swiper(this.getNativeElement().children[0], options);
                        this.slider = swiper;
                        /*
                        * TODO: Finish this
                        if(util.isTrueProperty(this.zoom)) {
                          this.enableZoom = true;
                          setTimeout(() => {
                            this.initZoom();
                          })
                        }
                        */
                    }
                }, {
                    key: "onTap",
                    value: function onTap(swiper, e) {}
                }, {
                    key: "onClick",
                    value: function onClick(swiper, e) {}
                }, {
                    key: "onDoubleTap",
                    value: function onDoubleTap(swiper, e) {
                        this.toggleZoom(swiper, e);
                    }
                }, {
                    key: "onLazyImageLoad",
                    value: function onLazyImageLoad(swiper, slide, img) {}
                }, {
                    key: "onLazyImageReady",
                    value: function onLazyImageReady(swiper, slide, img) {}

                    /*
                    nextButton(swiper, e) {
                    }
                    prevButton() {
                    }
                    indexButton() {
                    }
                    */
                }, {
                    key: "initZoom",
                    value: function initZoom() {
                        var _this3 = this;

                        this.zoomDuration = this.zoomDuration || 230;
                        this.maxScale = this.zoomMax || 3;
                        this.zoomElement = this.getNativeElement().children[0].children[0];
                        this.zoomElement && this.zoomElement.classList.add('ion-scroll-zoom');
                        this.zoomGesture = new Gesture(this.zoomElement);
                        this.zoomGesture.listen();
                        this.scale = 1;
                        this.zoomLastPosX = 0;
                        this.zoomLastPosY = 0;
                        var last_scale = undefined,
                            startX = undefined,
                            startY = undefined,
                            posX = 0,
                            posY = 0,
                            zoomRect = undefined;
                        this.viewportWidth = this.getNativeElement().offsetWidth;
                        this.viewportHeight = this.getNativeElement().offsetHeight;
                        this.zoomElement.addEventListener('touchstart', function (e) {
                            _this3.onTouchStart(e);
                        });
                        this.zoomElement.addEventListener('touchmove', function (e) {
                            _this3.onTouchMove(e);
                        });
                        this.zoomElement.addEventListener('touchend', function (e) {
                            _this3.onTouchEnd(e);
                        });
                        this.zoomGesture.on('pinchstart', function (e) {
                            last_scale = _this3.scale;
                            console.log('Last scale', e.scale);
                        });
                        this.zoomGesture.on('pinch', function (e) {
                            _this3.scale = Math.max(1, Math.min(last_scale * e.scale, 10));
                            console.log('Scaling', _this3.scale);
                            _this3.zoomElement.style[CSS.transform] = 'scale(' + _this3.scale + ')';
                            zoomRect = _this3.zoomElement.getBoundingClientRect();
                        });
                        this.zoomGesture.on('pinchend', function (e) {
                            //last_scale = Math.max(1, Math.min(last_scale * e.scale, 10));
                            if (_this3.scale > _this3.maxScale) {
                                var za = new Animation(_this3.zoomElement).duration(_this3.zoomDuration).easing('linear').from('scale', _this3.scale).to('scale', _this3.maxScale);
                                za.play();
                                _this3.scale = _this3.maxScale;
                            }
                        });
                    }
                }, {
                    key: "resetZoom",
                    value: function resetZoom() {
                        if (this.zoomElement) {
                            this.zoomElement.parentElement.style[CSS.transform] = '';
                            this.zoomElement.style[CSS.transform] = 'scale(1)';
                        }
                        this.scale = 1;
                        this.zoomLastPosX = 0;
                        this.zoomLastPosY = 0;
                    }
                }, {
                    key: "toggleZoom",
                    value: function toggleZoom(swiper, e) {
                        console.log('Try toggle zoom');
                        if (!this.enableZoom) {
                            return;
                        }
                        console.log('Toggling zoom', e);
                        /*
                        let x = e.pointers[0].clientX;
                        let y = e.pointers[0].clientY;
                             let mx = this.viewportWidth / 2;
                        let my = this.viewportHeight / 2;
                             let tx, ty;
                             if(x > mx) {
                          // Greater than half
                          tx = -x;
                        } else {
                          // Less than or equal to half
                          tx = (this.viewportWidth - x);
                        }
                        if(y > my) {
                          ty = -y;
                        } else {
                          ty = y-my;
                        }
                             console.log(y);
                        */
                        var zi = new Animation(this.touch.target.children[0]).duration(this.zoomDuration).easing('linear').fill('none');
                        var zw = new Animation(this.touch.target.children[0]).duration(this.zoomDuration).easing('linear');
                        var za = new Animation();
                        za.fill('none');
                        za.add(zi); //, zw);
                        if (this.scale > 1) {
                            // Zoom out
                            //zw.fromTo('translateX', posX + 'px', '0px');
                            //zw.fromTo('translateY', posY + 'px', '0px');
                            zi.from('scale', this.scale);
                            zi.to('scale', 1);
                            za.play();
                            //posX = 0;
                            //posY = 0;
                            this.scale = 1;
                        } else {
                            // Zoom in
                            //zw.fromTo('translateX', posX + 'px', tx + 'px');
                            //zw.fromTo('translateY', posY + 'px', ty + 'px');
                            zi.from('scale', this.scale);
                            zi.to('scale', this.maxScale);
                            za.play();
                            //posX = tx;
                            //posY = ty;
                            this.scale = this.maxScale;
                        }
                    }
                }, {
                    key: "onTransitionStart",
                    value: function onTransitionStart(swiper) {}
                }, {
                    key: "onTransitionEnd",
                    value: function onTransitionEnd(swiper) {}
                }, {
                    key: "onTouchStart",
                    value: function onTouchStart(e) {
                        console.log('Touch start', e);
                        //TODO: Support mice as well
                        var target = dom.closest(e.target, '.slide').children[0].children[0];
                        this.touch = {
                            startX: e.touches[0].clientX,
                            startY: e.touches[0].clientY,
                            deltaX: 0,
                            deltaY: 0,
                            lastX: 0,
                            lastY: 0,
                            target: target.parentElement,
                            zoomable: target,
                            zoomableWidth: target.offsetWidth,
                            zoomableHeight: target.offsetHeight
                        };
                        console.log('Target', this.touch.target);
                        //TODO: android prevent default
                    }
                }, {
                    key: "onTouchMove",
                    value: function onTouchMove(e) {
                        this.touch.deltaX = e.touches[0].clientX - this.touch.startX;
                        this.touch.deltaY = e.touches[0].clientY - this.touch.startY;
                        // TODO: Make sure we need to transform (image is bigger than viewport)
                        var zoomableScaledWidth = this.touch.zoomableWidth * this.scale;
                        var zoomableScaledHeight = this.touch.zoomableHeight * this.scale;
                        var x1 = Math.min(this.viewportWidth / 2 - zoomableScaledWidth / 2, 0);
                        var x2 = -x1;
                        var y1 = Math.min(this.viewportHeight / 2 - zoomableScaledHeight / 2, 0);
                        var y2 = -y1;
                        console.log('BOUNDS', x1, x2, y1, y2);
                        if (this.scale <= 1) {
                            return;
                        }
                        console.log('PAN', e);
                        // Move image
                        this.touch.x = this.touch.deltaX + this.touch.lastX;
                        this.touch.y = this.touch.deltaY + this.touch.lastY;
                        console.log(this.touch.x, this.touch.y);
                        if (this.touch.x < x1) {
                            console.log('OUT ON LEFT');
                        }
                        if (this.touch.x > x2) {
                            console.log('OUT ON RIGHT');
                        }
                        if (this.touch.x > this.viewportWidth) {} else if (-this.touch.x > this.viewportWidth) {} else {
                            console.log('TRANSFORM', this.touch.x, this.touch.y, this.touch.target);
                            //this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
                            this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                    }
                }, {
                    key: "onTouchEnd",
                    value: function onTouchEnd(e) {
                        console.log('PANEND', e);
                        if (this.scale > 1) {
                            if (Math.abs(this.touch.x) > this.viewportWidth) {
                                posX = posX > 0 ? this.viewportWidth - 1 : -(this.viewportWidth - 1);
                                console.log('Setting on posx', this.touch.x);
                            }
                            /*
                            if(posY > this.viewportHeight/2) {
                              let z = new Animation(this.zoomElement.parentElement);
                              z.fromTo('translateY', posY + 'px', Math.min(this.viewportHeight/2 + 30, posY));
                              z.play();
                            } else {
                              let z = new Animation(this.zoomElement.parentElement);
                              z.fromTo('translateY', posY + 'px', Math.max(this.viewportHeight/2 - 30, posY));
                              z.play();
                            }
                            */
                            this.touch.lastX = this.touch.x;
                            this.touch.lastY = this.touch.y;
                        }
                    }

                    /**
                     * Update the underlying slider implementation. Call this if you've added or removed
                     * child slides.
                     */
                }, {
                    key: "update",
                    value: function update() {
                        var _this4 = this;

                        setTimeout(function () {
                            _this4.slider.update();
                            // Don't allow pager to show with > 10 slides
                            if (_this4.slider.slides.length > 10) {
                                _this4.showPager = false;
                            }
                        });
                    }
                }, {
                    key: "next",
                    value: function next() {
                        this.slider.slideNext();
                    }
                }, {
                    key: "prev",
                    value: function prev() {
                        this.slider.slidePrev();
                    }
                }, {
                    key: "getIndex",
                    value: function getIndex() {
                        return this.slider.activeIndex;
                    }
                }, {
                    key: "getNumSlides",
                    value: function getNumSlides() {
                        return this.slider.slides.length;
                    }
                }, {
                    key: "isAtEnd",
                    value: function isAtEnd() {
                        return this.slider.isEnd;
                    }
                }, {
                    key: "isAtBeginning",
                    value: function isAtBeginning() {
                        return this.slider.isBeginning;
                    }
                }, {
                    key: "getSliderWidget",
                    value: function getSliderWidget() {
                        return this.slider;
                    }
                }]);

                return Slides;
            })(Ion);

            _export("Slides", Slides);

            _export("Slides", Slides = __decorate([IonicComponent({
                selector: 'ion-slides',
                properties: ['loop', 'index', 'bounce', 'pager', 'options', 'zoom', 'zoomDuration', 'zoomMax']
            }), View({
                template: "<div class=\"swiper-container\">\n    <div class=\"swiper-wrapper\">\n      <ng-content></ng-content>\n    </div>\n    <div [class.hide]=\"!showPager\" class=\"swiper-pagination\"></div>\n  </div>",
                directives: [NgIf, NgClass]
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object])], Slides));
            /**
             * TODO
             */

            Slide =
            /**
             * TODO
             * @param {Slides} slides  The containing slidebox.
             * @param {ElementRef} elementRef  TODO
             */
            function Slide(elementRef, slides) {
                _classCallCheck(this, Slide);

                this.ele = elementRef.nativeElement;
                this.ele.classList.add('swiper-slide');
                slides.rapidUpdate();
            };

            _export("Slide", Slide);

            _export("Slide", Slide = __decorate([IonicComponent({
                selector: 'ion-slide',
                properties: ['zoom']
            }), View({
                template: "<div class=\"slide-zoom\"><ng-content></ng-content></div>"
            }), __param(1, Host()), __metadata('design:paramtypes', [typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, Slides])], Slide));

            SlideLazy = function SlideLazy(elementRef) {
                _classCallCheck(this, SlideLazy);

                elementRef.getNativeElement().classList.add('swiper-lazy');
            };

            _export("SlideLazy", SlideLazy);

            _export("SlideLazy", SlideLazy = __decorate([IonicDirective({
                selector: 'slide-lazy'
            }), __metadata('design:paramtypes', [typeof (_d = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _d || Object])], SlideLazy));
        }
    };
});
System.register('ionic/components/slides/swiper-widget',[],function(_export){ /**
 * Swiper 3.1.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 *
 * http://www.idangero.us/swiper/
 *
 * Copyright 2015, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: August 22, 2015
 */'use strict';var $,Dom7,swiperDomPlugins,i,domLib;_export('Swiper',Swiper); /*===========================
Swiper
===========================*/function Swiper(container,params){if(!(this instanceof Swiper))return new Swiper(container,params);var defaults={direction:'horizontal',touchEventsTarget:'container',initialSlide:0,speed:300, // autoplay
autoplay:false,autoplayDisableOnInteraction:true, // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
iOSEdgeSwipeDetection:false,iOSEdgeSwipeThreshold:20, // Free mode
freeMode:false,freeModeMomentum:true,freeModeMomentumRatio:1,freeModeMomentumBounce:true,freeModeMomentumBounceRatio:1,freeModeSticky:false, // Set wrapper width
setWrapperSize:false, // Virtual Translate
virtualTranslate:false, // Effects
effect:'slide',coverflow:{rotate:50,stretch:0,depth:100,modifier:1,slideShadows:true},cube:{slideShadows:true,shadow:true,shadowOffset:20,shadowScale:0.94},fade:{crossFade:false}, // Parallax
parallax:false, // Scrollbar
scrollbar:null,scrollbarHide:true, // Keyboard Mousewheel
keyboardControl:false,mousewheelControl:false,mousewheelReleaseOnEdges:false,mousewheelInvert:false,mousewheelForceToAxis:false,mousewheelSensitivity:1, // Hash Navigation
hashnav:false, // Slides grid
spaceBetween:0,slidesPerView:1,slidesPerColumn:1,slidesPerColumnFill:'column',slidesPerGroup:1,centeredSlides:false,slidesOffsetBefore:0,slidesOffsetAfter:0, // Round length
roundLengths:false, // Touches
touchRatio:1,touchAngle:45,simulateTouch:true,shortSwipes:true,longSwipes:true,longSwipesRatio:0.5,longSwipesMs:300,followFinger:true,onlyExternal:false,threshold:0,touchMoveStopPropagation:true, // Pagination
pagination:null,paginationElement:'span',paginationClickable:false,paginationHide:false,paginationBulletRender:null, // Resistance
resistance:true,resistanceRatio:0.85, // Next/prev buttons
nextButton:null,prevButton:null, // Progress
watchSlidesProgress:false,watchSlidesVisibility:false, // Cursor
grabCursor:false, // Clicks
preventClicks:true,preventClicksPropagation:true,slideToClickedSlide:false, // Lazy Loading
lazyLoading:false,lazyLoadingInPrevNext:false,lazyLoadingOnTransitionStart:false, // Images
preloadImages:true,updateOnImagesReady:true, // loop
loop:false,loopAdditionalSlides:0,loopedSlides:null, // Control
control:undefined,controlInverse:false,controlBy:'slide', // Swiping/no swiping
allowSwipeToPrev:true,allowSwipeToNext:true,swipeHandler:null,noSwiping:true,noSwipingClass:'swiper-no-swiping', // NS
slideClass:'swiper-slide',slideActiveClass:'swiper-slide-active',slideVisibleClass:'swiper-slide-visible',slideDuplicateClass:'swiper-slide-duplicate',slideNextClass:'swiper-slide-next',slidePrevClass:'swiper-slide-prev',wrapperClass:'swiper-wrapper',bulletClass:'swiper-pagination-bullet',bulletActiveClass:'swiper-pagination-bullet-active',buttonDisabledClass:'swiper-button-disabled',paginationHiddenClass:'swiper-pagination-hidden', // Observer
observer:false,observeParents:false, // Accessibility
a11y:false,prevSlideMessage:'Previous slide',nextSlideMessage:'Next slide',firstSlideMessage:'This is the first slide',lastSlideMessage:'This is the last slide',paginationBulletMessage:'Go to slide {{index}}', // Callbacks
runCallbacksOnInit:true};var initialVirtualTranslate=params && params.virtualTranslate;params = params || {};for(var def in defaults) {if(typeof params[def] === 'undefined'){params[def] = defaults[def];}else if(typeof params[def] === 'object'){for(var deepDef in defaults[def]) {if(typeof params[def][deepDef] === 'undefined'){params[def][deepDef] = defaults[def][deepDef];}}}} // Swiper
var s=this; // Version
s.version = '3.1.0'; // Params
s.params = params; // Classname
s.classNames = []; /*=========================
      Dom Library and plugins
      ===========================*/if(typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){$ = Dom7;}if(typeof $ === 'undefined'){if(typeof Dom7 === 'undefined'){$ = window.Dom7 || window.Zepto || window.jQuery;}else {$ = Dom7;}if(!$)return;} // Export it to Swiper instance
s.$ = $; /*=========================
      Preparation - Define Container, Wrapper and Pagination
      ===========================*/s.container = $(container);if(s.container.length === 0)return;if(s.container.length > 1){s.container.each(function(){new Swiper(this,params);});return;} // Save instance in container HTML Element and in data
s.container[0].swiper = s;s.container.data('swiper',s);s.classNames.push('swiper-container-' + s.params.direction);if(s.params.freeMode){s.classNames.push('swiper-container-free-mode');}if(!s.support.flexbox){s.classNames.push('swiper-container-no-flexbox');s.params.slidesPerColumn = 1;} // Enable slides progress when required
if(s.params.parallax || s.params.watchSlidesVisibility){s.params.watchSlidesProgress = true;} // Coverflow / 3D
if(['cube','coverflow'].indexOf(s.params.effect) >= 0){if(s.support.transforms3d){s.params.watchSlidesProgress = true;s.classNames.push('swiper-container-3d');}else {s.params.effect = 'slide';}}if(s.params.effect !== 'slide'){s.classNames.push('swiper-container-' + s.params.effect);}if(s.params.effect === 'cube'){s.params.resistanceRatio = 0;s.params.slidesPerView = 1;s.params.slidesPerColumn = 1;s.params.slidesPerGroup = 1;s.params.centeredSlides = false;s.params.spaceBetween = 0;s.params.virtualTranslate = true;s.params.setWrapperSize = false;}if(s.params.effect === 'fade'){s.params.slidesPerView = 1;s.params.slidesPerColumn = 1;s.params.slidesPerGroup = 1;s.params.watchSlidesProgress = true;s.params.spaceBetween = 0;if(typeof initialVirtualTranslate === 'undefined'){s.params.virtualTranslate = true;}} // Grab Cursor
if(s.params.grabCursor && s.support.touch){s.params.grabCursor = false;} // Wrapper
s.wrapper = s.container.children('.' + s.params.wrapperClass); // Pagination
if(s.params.pagination){s.paginationContainer = $(s.params.pagination);if(s.params.paginationClickable){s.paginationContainer.addClass('swiper-pagination-clickable');}} // Is Horizontal
function isH(){return s.params.direction === 'horizontal';} // RTL
s.rtl = isH() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');if(s.rtl){s.classNames.push('swiper-container-rtl');} // Wrong RTL support
if(s.rtl){s.wrongRTL = s.wrapper.css('display') === '-webkit-box';} // Columns
if(s.params.slidesPerColumn > 1){s.classNames.push('swiper-container-multirow');} // Check for Android
if(s.device.android){s.classNames.push('swiper-container-android');} // Add classes
s.container.addClass(s.classNames.join(' ')); // Translate
s.translate = 0; // Progress
s.progress = 0; // Velocity
s.velocity = 0; /*=========================
      Locks, unlocks
      ===========================*/s.lockSwipeToNext = function(){s.params.allowSwipeToNext = false;};s.lockSwipeToPrev = function(){s.params.allowSwipeToPrev = false;};s.lockSwipes = function(){s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;};s.unlockSwipeToNext = function(){s.params.allowSwipeToNext = true;};s.unlockSwipeToPrev = function(){s.params.allowSwipeToPrev = true;};s.unlockSwipes = function(){s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;}; /*=========================
      Round helper
      ===========================*/function round(a){return Math.floor(a);} /*=========================
      Set grab cursor
      ===========================*/if(s.params.grabCursor){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grab';s.container[0].style.cursor = '-moz-grab';s.container[0].style.cursor = 'grab';} /*=========================
      Update on Images Ready
      ===========================*/s.imagesToLoad = [];s.imagesLoaded = 0;s.loadImage = function(imgElement,src,checkForComplete,callback){var image;function onReady(){if(callback)callback();}if(!imgElement.complete || !checkForComplete){if(src){image = new window.Image();image.onload = onReady;image.onerror = onReady;image.src = src;}else {onReady();}}else {onReady();}};s.preloadImages = function(){s.imagesToLoad = s.container.find('img');function _onReady(){if(typeof s === 'undefined' || s === null)return;if(s.imagesLoaded !== undefined)s.imagesLoaded++;if(s.imagesLoaded === s.imagesToLoad.length){if(s.params.updateOnImagesReady)s.update();s.emit('onImagesReady',s);}}for(var i=0;i < s.imagesToLoad.length;i++) {s.loadImage(s.imagesToLoad[i],s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src'),true,_onReady);}}; /*=========================
      Autoplay
      ===========================*/s.autoplayTimeoutId = undefined;s.autoplaying = false;s.autoplayPaused = false;function autoplay(){s.autoplayTimeoutId = setTimeout(function(){if(s.params.loop){s.fixLoop();s._slideNext();}else {if(!s.isEnd){s._slideNext();}else {if(!params.autoplayStopOnLast){s._slideTo(0);}else {s.stopAutoplay();}}}},s.params.autoplay);}s.startAutoplay = function(){if(typeof s.autoplayTimeoutId !== 'undefined')return false;if(!s.params.autoplay)return false;if(s.autoplaying)return false;s.autoplaying = true;s.emit('onAutoplayStart',s);autoplay();};s.stopAutoplay = function(internal){if(!s.autoplayTimeoutId)return;if(s.autoplayTimeoutId)clearTimeout(s.autoplayTimeoutId);s.autoplaying = false;s.autoplayTimeoutId = undefined;s.emit('onAutoplayStop',s);};s.pauseAutoplay = function(speed){if(s.autoplayPaused)return;if(s.autoplayTimeoutId)clearTimeout(s.autoplayTimeoutId);s.autoplayPaused = true;if(speed === 0){s.autoplayPaused = false;autoplay();}else {s.wrapper.transitionEnd(function(){if(!s)return;s.autoplayPaused = false;if(!s.autoplaying){s.stopAutoplay();}else {autoplay();}});}}; /*=========================
      Min/Max Translate
      ===========================*/s.minTranslate = function(){return -s.snapGrid[0];};s.maxTranslate = function(){return -s.snapGrid[s.snapGrid.length - 1];}; /*=========================
      Slider/slides sizes
      ===========================*/s.updateContainerSize = function(){var width,height;if(typeof s.params.width !== 'undefined'){width = s.params.width;}else {width = s.container[0].clientWidth;}if(typeof s.params.height !== 'undefined'){height = s.params.height;}else {height = s.container[0].clientHeight;}if(width === 0 && isH() || height === 0 && !isH()){return;} //Subtract paddings
width = width - parseInt(s.container.css('padding-left'),10) - parseInt(s.container.css('padding-right'),10);height = height - parseInt(s.container.css('padding-top'),10) - parseInt(s.container.css('padding-bottom'),10); // Store values
s.width = width;s.height = height;s.size = isH()?s.width:s.height;};s.updateSlidesSize = function(){s.slides = s.wrapper.children('.' + s.params.slideClass);s.snapGrid = [];s.slidesGrid = [];s.slidesSizesGrid = [];var spaceBetween=s.params.spaceBetween,slidePosition=-s.params.slidesOffsetBefore,i,prevSlideSize=0,index=0;if(typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0){spaceBetween = parseFloat(spaceBetween.replace('%','')) / 100 * s.size;}s.virtualSize = -spaceBetween; // reset margins
if(s.rtl)s.slides.css({marginLeft:'',marginTop:''});else s.slides.css({marginRight:'',marginBottom:''});var slidesNumberEvenToRows;if(s.params.slidesPerColumn > 1){if(Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn){slidesNumberEvenToRows = s.slides.length;}else {slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;}} // Calc slides
var slideSize;var slidesPerColumn=s.params.slidesPerColumn;var slidesPerRow=slidesNumberEvenToRows / slidesPerColumn;var numFullColumns=slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);for(i = 0;i < s.slides.length;i++) {slideSize = 0;var slide=s.slides.eq(i);if(s.params.slidesPerColumn > 1){ // Set slides order
var newSlideOrderIndex;var column,row;if(s.params.slidesPerColumnFill === 'column'){column = Math.floor(i / slidesPerColumn);row = i - column * slidesPerColumn;if(column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1){if(++row >= slidesPerColumn){row = 0;column++;}}newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;slide.css({'-webkit-box-ordinal-group':newSlideOrderIndex,'-moz-box-ordinal-group':newSlideOrderIndex,'-ms-flex-order':newSlideOrderIndex,'-webkit-order':newSlideOrderIndex,'order':newSlideOrderIndex});}else {row = Math.floor(i / slidesPerRow);column = i - row * slidesPerRow;}slide.css({'margin-top':row !== 0 && s.params.spaceBetween && s.params.spaceBetween + 'px'}).attr('data-swiper-column',column).attr('data-swiper-row',row);}if(slide.css('display') === 'none')continue;if(s.params.slidesPerView === 'auto'){slideSize = isH()?slide.outerWidth(true):slide.outerHeight(true);if(s.params.roundLengths)slideSize = round(slideSize);}else {slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;if(s.params.roundLengths)slideSize = round(slideSize);if(isH()){s.slides[i].style.width = slideSize + 'px';}else {s.slides[i].style.height = slideSize + 'px';}}s.slides[i].swiperSlideSize = slideSize;s.slidesSizesGrid.push(slideSize);if(s.params.centeredSlides){slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;if(i === 0)slidePosition = slidePosition - s.size / 2 - spaceBetween;if(Math.abs(slidePosition) < 1 / 1000)slidePosition = 0;if(index % s.params.slidesPerGroup === 0)s.snapGrid.push(slidePosition);s.slidesGrid.push(slidePosition);}else {if(index % s.params.slidesPerGroup === 0)s.snapGrid.push(slidePosition);s.slidesGrid.push(slidePosition);slidePosition = slidePosition + slideSize + spaceBetween;}s.virtualSize += slideSize + spaceBetween;prevSlideSize = slideSize;index++;}s.virtualSize = Math.max(s.virtualSize,s.size) + s.params.slidesOffsetAfter;var newSlidesGrid;if(s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')){s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});}if(!s.support.flexbox || s.params.setWrapperSize){if(isH())s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});else s.wrapper.css({height:s.virtualSize + s.params.spaceBetween + 'px'});}if(s.params.slidesPerColumn > 1){s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});if(s.params.centeredSlides){newSlidesGrid = [];for(i = 0;i < s.snapGrid.length;i++) {if(s.snapGrid[i] < s.virtualSize + s.snapGrid[0])newSlidesGrid.push(s.snapGrid[i]);}s.snapGrid = newSlidesGrid;}} // Remove last grid elements depending on width
if(!s.params.centeredSlides){newSlidesGrid = [];for(i = 0;i < s.snapGrid.length;i++) {if(s.snapGrid[i] <= s.virtualSize - s.size){newSlidesGrid.push(s.snapGrid[i]);}}s.snapGrid = newSlidesGrid;if(Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1])){s.snapGrid.push(s.virtualSize - s.size);}}if(s.snapGrid.length === 0)s.snapGrid = [0];if(s.params.spaceBetween !== 0){if(isH()){if(s.rtl)s.slides.css({marginLeft:spaceBetween + 'px'});else s.slides.css({marginRight:spaceBetween + 'px'});}else s.slides.css({marginBottom:spaceBetween + 'px'});}if(s.params.watchSlidesProgress){s.updateSlidesOffset();}};s.updateSlidesOffset = function(){for(var i=0;i < s.slides.length;i++) {s.slides[i].swiperSlideOffset = isH()?s.slides[i].offsetLeft:s.slides[i].offsetTop;}}; /*=========================
      Slider/slides progress
      ===========================*/s.updateSlidesProgress = function(translate){if(typeof translate === 'undefined'){translate = s.translate || 0;}if(s.slides.length === 0)return;if(typeof s.slides[0].swiperSlideOffset === 'undefined')s.updateSlidesOffset();var offsetCenter=-translate;if(s.rtl)offsetCenter = translate; // Visible Slides
var containerBox=s.container[0].getBoundingClientRect();var sideBefore=isH()?'left':'top';var sideAfter=isH()?'right':'bottom';s.slides.removeClass(s.params.slideVisibleClass);for(var i=0;i < s.slides.length;i++) {var slide=s.slides[i];var slideProgress=(offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);if(s.params.watchSlidesVisibility){var slideBefore=-(offsetCenter - slide.swiperSlideOffset);var slideAfter=slideBefore + s.slidesSizesGrid[i];var isVisible=slideBefore >= 0 && slideBefore < s.size || slideAfter > 0 && slideAfter <= s.size || slideBefore <= 0 && slideAfter >= s.size;if(isVisible){s.slides.eq(i).addClass(s.params.slideVisibleClass);}}slide.progress = s.rtl?-slideProgress:slideProgress;}};s.updateProgress = function(translate){if(typeof translate === 'undefined'){translate = s.translate || 0;}var translatesDiff=s.maxTranslate() - s.minTranslate();if(translatesDiff === 0){s.progress = 0;s.isBeginning = s.isEnd = true;}else {s.progress = (translate - s.minTranslate()) / translatesDiff;s.isBeginning = s.progress <= 0;s.isEnd = s.progress >= 1;}if(s.isBeginning)s.emit('onReachBeginning',s);if(s.isEnd)s.emit('onReachEnd',s);if(s.params.watchSlidesProgress)s.updateSlidesProgress(translate);s.emit('onProgress',s,s.progress);};s.updateActiveIndex = function(){var translate=s.rtl?s.translate:-s.translate;var newActiveIndex,i,snapIndex;for(i = 0;i < s.slidesGrid.length;i++) {if(typeof s.slidesGrid[i + 1] !== 'undefined'){if(translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2){newActiveIndex = i;}else if(translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]){newActiveIndex = i + 1;}}else {if(translate >= s.slidesGrid[i]){newActiveIndex = i;}}} // Normalize slideIndex
if(newActiveIndex < 0 || typeof newActiveIndex === 'undefined')newActiveIndex = 0; // for (i = 0; i < s.slidesGrid.length; i++) {
// if (- translate >= s.slidesGrid[i]) {
// newActiveIndex = i;
// }
// }
snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);if(snapIndex >= s.snapGrid.length)snapIndex = s.snapGrid.length - 1;if(newActiveIndex === s.activeIndex){return;}s.snapIndex = snapIndex;s.previousIndex = s.activeIndex;s.activeIndex = newActiveIndex;s.updateClasses();}; /*=========================
      Classes
      ===========================*/s.updateClasses = function(){s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);var activeSlide=s.slides.eq(s.activeIndex); // Active classes
activeSlide.addClass(s.params.slideActiveClass);activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass); // Pagination
if(s.bullets && s.bullets.length > 0){s.bullets.removeClass(s.params.bulletActiveClass);var bulletIndex;if(s.params.loop){bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup;if(bulletIndex > s.slides.length - 1 - s.loopedSlides * 2){bulletIndex = bulletIndex - (s.slides.length - s.loopedSlides * 2);}if(bulletIndex > s.bullets.length - 1)bulletIndex = bulletIndex - s.bullets.length;}else {if(typeof s.snapIndex !== 'undefined'){bulletIndex = s.snapIndex;}else {bulletIndex = s.activeIndex || 0;}}if(s.paginationContainer.length > 1){s.bullets.each(function(){if($(this).index() === bulletIndex)$(this).addClass(s.params.bulletActiveClass);});}else {s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);}} // Next/active buttons
if(!s.params.loop){if(s.params.prevButton){if(s.isBeginning){$(s.params.prevButton).addClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.disable($(s.params.prevButton));}else {$(s.params.prevButton).removeClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.enable($(s.params.prevButton));}}if(s.params.nextButton){if(s.isEnd){$(s.params.nextButton).addClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.disable($(s.params.nextButton));}else {$(s.params.nextButton).removeClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.enable($(s.params.nextButton));}}}}; /*=========================
      Pagination
      ===========================*/s.updatePagination = function(){if(!s.params.pagination)return;if(s.paginationContainer && s.paginationContainer.length > 0){var bulletsHTML='';var numberOfBullets=s.params.loop?Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup):s.snapGrid.length;for(var i=0;i < numberOfBullets;i++) {if(s.params.paginationBulletRender){bulletsHTML += s.params.paginationBulletRender(i,s.params.bulletClass);}else {bulletsHTML += '<' + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';}}s.paginationContainer.html(bulletsHTML);s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);if(s.params.paginationClickable && s.params.a11y && s.a11y){s.a11y.initPagination();}}}; /*=========================
      Common update method
      ===========================*/s.update = function(updateTranslate){s.updateContainerSize();s.updateSlidesSize();s.updateProgress();s.updatePagination();s.updateClasses();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}function forceSetTranslate(){newTranslate = Math.min(Math.max(s.translate,s.maxTranslate()),s.minTranslate());s.setWrapperTranslate(newTranslate);s.updateActiveIndex();s.updateClasses();}if(updateTranslate){var translated,newTranslate;if(s.controller && s.controller.spline){s.controller.spline = undefined;}if(s.params.freeMode){forceSetTranslate();}else {if((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides){translated = s.slideTo(s.slides.length - 1,0,false,true);}else {translated = s.slideTo(s.activeIndex,0,false,true);}if(!translated){forceSetTranslate();}}}}; /*=========================
      Resize Handler
      ===========================*/s.onResize = function(forceUpdatePagination){ // Disable locks on resize
var allowSwipeToPrev=s.params.allowSwipeToPrev;var allowSwipeToNext=s.params.allowSwipeToNext;s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;s.updateContainerSize();s.updateSlidesSize();if(s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination)s.updatePagination();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}if(s.controller && s.controller.spline){s.controller.spline = undefined;}if(s.params.freeMode){var newTranslate=Math.min(Math.max(s.translate,s.maxTranslate()),s.minTranslate());s.setWrapperTranslate(newTranslate);s.updateActiveIndex();s.updateClasses();}else {s.updateClasses();if((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides){s.slideTo(s.slides.length - 1,0,false,true);}else {s.slideTo(s.activeIndex,0,false,true);}} // Return locks after resize
s.params.allowSwipeToPrev = allowSwipeToPrev;s.params.allowSwipeToNext = allowSwipeToNext;}; /*=========================
      Events
      ===========================*/ //Define Touch Events
var desktopEvents=['mousedown','mousemove','mouseup'];if(window.navigator.pointerEnabled)desktopEvents = ['pointerdown','pointermove','pointerup'];else if(window.navigator.msPointerEnabled)desktopEvents = ['MSPointerDown','MSPointerMove','MSPointerUp'];s.touchEvents = {start:s.support.touch || !s.params.simulateTouch?'touchstart':desktopEvents[0],move:s.support.touch || !s.params.simulateTouch?'touchmove':desktopEvents[1],end:s.support.touch || !s.params.simulateTouch?'touchend':desktopEvents[2]}; // WP8 Touch Events Fix
if(window.navigator.pointerEnabled || window.navigator.msPointerEnabled){(s.params.touchEventsTarget === 'container'?s.container:s.wrapper).addClass('swiper-wp8-' + s.params.direction);} // Attach/detach events
s.initEvents = function(detach){var actionDom=detach?'off':'on';var action=detach?'removeEventListener':'addEventListener';var touchEventsTarget=s.params.touchEventsTarget === 'container'?s.container[0]:s.wrapper[0];var target=s.support.touch?touchEventsTarget:document;var moveCapture=s.params.nested?true:false; //Touch Events
if(s.browser.ie){touchEventsTarget[action](s.touchEvents.start,s.onTouchStart,false);target[action](s.touchEvents.move,s.onTouchMove,moveCapture);target[action](s.touchEvents.end,s.onTouchEnd,false);}else {if(s.support.touch){touchEventsTarget[action](s.touchEvents.start,s.onTouchStart,false);touchEventsTarget[action](s.touchEvents.move,s.onTouchMove,moveCapture);touchEventsTarget[action](s.touchEvents.end,s.onTouchEnd,false);}if(params.simulateTouch && !s.device.ios && !s.device.android){touchEventsTarget[action]('mousedown',s.onTouchStart,false);document[action]('mousemove',s.onTouchMove,moveCapture);document[action]('mouseup',s.onTouchEnd,false);}}window[action]('resize',s.onResize); // Next, Prev, Index
if(s.params.nextButton){$(s.params.nextButton)[actionDom]('click',s.onClickNext);if(s.params.a11y && s.a11y)$(s.params.nextButton)[actionDom]('keydown',s.a11y.onEnterKey);}if(s.params.prevButton){$(s.params.prevButton)[actionDom]('click',s.onClickPrev);if(s.params.a11y && s.a11y)$(s.params.prevButton)[actionDom]('keydown',s.a11y.onEnterKey);}if(s.params.pagination && s.params.paginationClickable){$(s.paginationContainer)[actionDom]('click','.' + s.params.bulletClass,s.onClickIndex);if(s.params.a11y && s.a11y)$(s.paginationContainer)[actionDom]('keydown','.' + s.params.bulletClass,s.a11y.onEnterKey);} // Prevent Links Clicks
if(s.params.preventClicks || s.params.preventClicksPropagation)touchEventsTarget[action]('click',s.preventClicks,true);};s.attachEvents = function(detach){s.initEvents();};s.detachEvents = function(){s.initEvents(true);}; /*=========================
      Handle Clicks
      ===========================*/ // Prevent Clicks
s.allowClick = true;s.preventClicks = function(e){if(!s.allowClick){if(s.params.preventClicks)e.preventDefault();if(s.params.preventClicksPropagation && s.animating){e.stopPropagation();e.stopImmediatePropagation();}}}; // Clicks
s.onClickNext = function(e){e.preventDefault();if(s.isEnd && !s.params.loop)return;s.slideNext();};s.onClickPrev = function(e){e.preventDefault();if(s.isBeginning && !s.params.loop)return;s.slidePrev();};s.onClickIndex = function(e){e.preventDefault();var index=$(this).index() * s.params.slidesPerGroup;if(s.params.loop)index = index + s.loopedSlides;s.slideTo(index);}; /*=========================
      Handle Touches
      ===========================*/function findElementInEvent(e,selector){var el=$(e.target);if(!el.is(selector)){if(typeof selector === 'string'){el = el.parents(selector);}else if(selector.nodeType){var found;el.parents().each(function(index,_el){if(_el === selector)found = selector;});if(!found)return undefined;else return selector;}}if(el.length === 0){return undefined;}return el[0];}s.updateClickedSlide = function(e){var slide=findElementInEvent(e,'.' + s.params.slideClass);var slideFound=false;if(slide){for(var i=0;i < s.slides.length;i++) {if(s.slides[i] === slide)slideFound = true;}}if(slide && slideFound){s.clickedSlide = slide;s.clickedIndex = $(slide).index();}else {s.clickedSlide = undefined;s.clickedIndex = undefined;return;}if(s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex){var slideToIndex=s.clickedIndex,realIndex;if(s.params.loop){realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');if(slideToIndex > s.slides.length - s.params.slidesPerView){s.fixLoop();slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]').eq(0).index();setTimeout(function(){s.slideTo(slideToIndex);},0);}else if(slideToIndex < s.params.slidesPerView - 1){s.fixLoop();var duplicatedSlides=s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]');slideToIndex = duplicatedSlides.eq(duplicatedSlides.length - 1).index();setTimeout(function(){s.slideTo(slideToIndex);},0);}else {s.slideTo(slideToIndex);}}else {s.slideTo(slideToIndex);}}};var isTouched,isMoved,touchStartTime,isScrolling,currentTranslate,startTranslate,allowThresholdMove, // Form elements to match
formElements='input, select, textarea, button', // Last click time
lastClickTime=Date.now(),clickTimeout, //Velocities
velocities=[],allowMomentumBounce; // Animating Flag
s.animating = false; // Touches information
s.touches = {startX:0,startY:0,currentX:0,currentY:0,diff:0}; // Touch handlers
var isTouchEvent,startMoving;s.onTouchStart = function(e){if(e.originalEvent)e = e.originalEvent;isTouchEvent = e.type === 'touchstart';if(!isTouchEvent && 'which' in e && e.which === 3)return;if(s.params.noSwiping && findElementInEvent(e,'.' + s.params.noSwipingClass)){s.allowClick = true;return;}if(s.params.swipeHandler){if(!findElementInEvent(e,s.params.swipeHandler))return;}var startX=s.touches.currentX = e.type === 'touchstart'?e.targetTouches[0].pageX:e.pageX;var startY=s.touches.currentY = e.type === 'touchstart'?e.targetTouches[0].pageY:e.pageY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold){return;}isTouched = true;isMoved = false;isScrolling = undefined;startMoving = undefined;s.touches.startX = startX;s.touches.startY = startY;touchStartTime = Date.now();s.allowClick = true;s.updateContainerSize();s.swipeDirection = undefined;if(s.params.threshold > 0)allowThresholdMove = false;if(e.type !== 'touchstart'){var preventDefault=true;if($(e.target).is(formElements))preventDefault = false;if(document.activeElement && $(document.activeElement).is(formElements)){document.activeElement.blur();}if(preventDefault){e.preventDefault();}}s.emit('onTouchStart',s,e);};s.onTouchMove = function(e){if(e.originalEvent)e = e.originalEvent;if(isTouchEvent && e.type === 'mousemove')return;if(e.preventedByNestedSwiper)return;if(s.params.onlyExternal){ // isMoved = true;
s.allowClick = false;if(isTouched){s.touches.startX = s.touches.currentX = e.type === 'touchmove'?e.targetTouches[0].pageX:e.pageX;s.touches.startY = s.touches.currentY = e.type === 'touchmove'?e.targetTouches[0].pageY:e.pageY;touchStartTime = Date.now();}return;}if(isTouchEvent && document.activeElement){if(e.target === document.activeElement && $(e.target).is(formElements)){isMoved = true;s.allowClick = false;return;}}s.emit('onTouchMove',s,e);if(e.targetTouches && e.targetTouches.length > 1)return;s.touches.currentX = e.type === 'touchmove'?e.targetTouches[0].pageX:e.pageX;s.touches.currentY = e.type === 'touchmove'?e.targetTouches[0].pageY:e.pageY;if(typeof isScrolling === 'undefined'){var touchAngle=Math.atan2(Math.abs(s.touches.currentY - s.touches.startY),Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;isScrolling = isH()?touchAngle > s.params.touchAngle:90 - touchAngle > s.params.touchAngle;}if(isScrolling){s.emit('onTouchMoveOpposite',s,e);}if(typeof startMoving === 'undefined' && s.browser.ieTouch){if(s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY){startMoving = true;}}if(!isTouched)return;if(isScrolling){isTouched = false;return;}if(!startMoving && s.browser.ieTouch){return;}s.allowClick = false;s.emit('onSliderMove',s,e);e.preventDefault();if(s.params.touchMoveStopPropagation && !s.params.nested){e.stopPropagation();}if(!isMoved){if(params.loop){s.fixLoop();}startTranslate = s.getWrapperTranslate();s.setWrapperTransition(0);if(s.animating){s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');}if(s.params.autoplay && s.autoplaying){if(s.params.autoplayDisableOnInteraction){s.stopAutoplay();}else {s.pauseAutoplay();}}allowMomentumBounce = false; //Grab Cursor
if(s.params.grabCursor){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grabbing';s.container[0].style.cursor = '-moz-grabbin';s.container[0].style.cursor = 'grabbing';}}isMoved = true;var diff=s.touches.diff = isH()?s.touches.currentX - s.touches.startX:s.touches.currentY - s.touches.startY;diff = diff * s.params.touchRatio;if(s.rtl)diff = -diff;s.swipeDirection = diff > 0?'prev':'next';currentTranslate = diff + startTranslate;var disableParentSwiper=true;if(diff > 0 && currentTranslate > s.minTranslate()){disableParentSwiper = false;if(s.params.resistance)currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff,s.params.resistanceRatio);}else if(diff < 0 && currentTranslate < s.maxTranslate()){disableParentSwiper = false;if(s.params.resistance)currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff,s.params.resistanceRatio);}if(disableParentSwiper){e.preventedByNestedSwiper = true;} // Directions locks
if(!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate){currentTranslate = startTranslate;}if(!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate){currentTranslate = startTranslate;}if(!s.params.followFinger)return; // Threshold
if(s.params.threshold > 0){if(Math.abs(diff) > s.params.threshold || allowThresholdMove){if(!allowThresholdMove){allowThresholdMove = true;s.touches.startX = s.touches.currentX;s.touches.startY = s.touches.currentY;currentTranslate = startTranslate;s.touches.diff = isH()?s.touches.currentX - s.touches.startX:s.touches.currentY - s.touches.startY;return;}}else {currentTranslate = startTranslate;return;}} // Update active index in free mode
if(s.params.freeMode || s.params.watchSlidesProgress){s.updateActiveIndex();}if(s.params.freeMode){ //Velocity
if(velocities.length === 0){velocities.push({position:s.touches[isH()?'startX':'startY'],time:touchStartTime});}velocities.push({position:s.touches[isH()?'currentX':'currentY'],time:new window.Date().getTime()});} // Update progress
s.updateProgress(currentTranslate); // Update translate
s.setWrapperTranslate(currentTranslate);};s.onTouchEnd = function(e){if(e.originalEvent)e = e.originalEvent;s.emit('onTouchEnd',s,e);if(!isTouched)return; //Return Grab Cursor
if(s.params.grabCursor && isMoved && isTouched){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grab';s.container[0].style.cursor = '-moz-grab';s.container[0].style.cursor = 'grab';} // Time diff
var touchEndTime=Date.now();var timeDiff=touchEndTime - touchStartTime; // Tap, doubleTap, Click
if(s.allowClick){s.updateClickedSlide(e);s.emit('onTap',s,e);if(timeDiff < 300 && touchEndTime - lastClickTime > 300){if(clickTimeout)clearTimeout(clickTimeout);clickTimeout = setTimeout(function(){if(!s)return;if(s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)){s.paginationContainer.toggleClass(s.params.paginationHiddenClass);}s.emit('onClick',s,e);},300);}if(timeDiff < 300 && touchEndTime - lastClickTime < 300){if(clickTimeout)clearTimeout(clickTimeout);s.emit('onDoubleTap',s,e);}}lastClickTime = Date.now();setTimeout(function(){if(s)s.allowClick = true;},0);if(!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate){isTouched = isMoved = false;return;}isTouched = isMoved = false;var currentPos;if(s.params.followFinger){currentPos = s.rtl?s.translate:-s.translate;}else {currentPos = -currentTranslate;}if(s.params.freeMode){if(currentPos < -s.minTranslate()){s.slideTo(s.activeIndex);return;}else if(currentPos > -s.maxTranslate()){if(s.slides.length < s.snapGrid.length){s.slideTo(s.snapGrid.length - 1);}else {s.slideTo(s.slides.length - 1);}return;}if(s.params.freeModeMomentum){if(velocities.length > 1){var lastMoveEvent=velocities.pop(),velocityEvent=velocities.pop();var distance=lastMoveEvent.position - velocityEvent.position;var time=lastMoveEvent.time - velocityEvent.time;s.velocity = distance / time;s.velocity = s.velocity / 2;if(Math.abs(s.velocity) < 0.02){s.velocity = 0;} // this implies that the user stopped moving a finger then released.
// There would be no events with distance zero, so the last event is stale.
if(time > 150 || new window.Date().getTime() - lastMoveEvent.time > 300){s.velocity = 0;}}else {s.velocity = 0;}velocities.length = 0;var momentumDuration=1000 * s.params.freeModeMomentumRatio;var momentumDistance=s.velocity * momentumDuration;var newPosition=s.translate + momentumDistance;if(s.rtl)newPosition = -newPosition;var doBounce=false;var afterBouncePosition;var bounceAmount=Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;if(newPosition < s.maxTranslate()){if(s.params.freeModeMomentumBounce){if(newPosition + s.maxTranslate() < -bounceAmount){newPosition = s.maxTranslate() - bounceAmount;}afterBouncePosition = s.maxTranslate();doBounce = true;allowMomentumBounce = true;}else {newPosition = s.maxTranslate();}}else if(newPosition > s.minTranslate()){if(s.params.freeModeMomentumBounce){if(newPosition - s.minTranslate() > bounceAmount){newPosition = s.minTranslate() + bounceAmount;}afterBouncePosition = s.minTranslate();doBounce = true;allowMomentumBounce = true;}else {newPosition = s.minTranslate();}}else if(s.params.freeModeSticky){var j=0,nextSlide;for(j = 0;j < s.snapGrid.length;j += 1) {if(s.snapGrid[j] > -newPosition){nextSlide = j;break;}}if(Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next'){newPosition = s.snapGrid[nextSlide];}else {newPosition = s.snapGrid[nextSlide - 1];}if(!s.rtl)newPosition = -newPosition;} //Fix duration
if(s.velocity !== 0){if(s.rtl){momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);}else {momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);}}else if(s.params.freeModeSticky){s.slideReset();return;}if(s.params.freeModeMomentumBounce && doBounce){s.updateProgress(afterBouncePosition);s.setWrapperTransition(momentumDuration);s.setWrapperTranslate(newPosition);s.onTransitionStart();s.animating = true;s.wrapper.transitionEnd(function(){if(!s || !allowMomentumBounce)return;s.emit('onMomentumBounce',s);s.setWrapperTransition(s.params.speed);s.setWrapperTranslate(afterBouncePosition);s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd();});});}else if(s.velocity){s.updateProgress(newPosition);s.setWrapperTransition(momentumDuration);s.setWrapperTranslate(newPosition);s.onTransitionStart();if(!s.animating){s.animating = true;s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd();});}}else {s.updateProgress(newPosition);}s.updateActiveIndex();}if(!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs){s.updateProgress();s.updateActiveIndex();}return;} // Find current slide
var i,stopIndex=0,groupSize=s.slidesSizesGrid[0];for(i = 0;i < s.slidesGrid.length;i += s.params.slidesPerGroup) {if(typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined'){if(currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]){stopIndex = i;groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];}}else {if(currentPos >= s.slidesGrid[i]){stopIndex = i;groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];}}} // Find current slide size
var ratio=(currentPos - s.slidesGrid[stopIndex]) / groupSize;if(timeDiff > s.params.longSwipesMs){ // Long touches
if(!s.params.longSwipes){s.slideTo(s.activeIndex);return;}if(s.swipeDirection === 'next'){if(ratio >= s.params.longSwipesRatio)s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);}if(s.swipeDirection === 'prev'){if(ratio > 1 - s.params.longSwipesRatio)s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);}}else { // Short swipes
if(!s.params.shortSwipes){s.slideTo(s.activeIndex);return;}if(s.swipeDirection === 'next'){s.slideTo(stopIndex + s.params.slidesPerGroup);}if(s.swipeDirection === 'prev'){s.slideTo(stopIndex);}}}; /*=========================
      Transitions
      ===========================*/s._slideTo = function(slideIndex,speed){return s.slideTo(slideIndex,speed,true,true);};s.slideTo = function(slideIndex,speed,runCallbacks,internal){if(typeof runCallbacks === 'undefined')runCallbacks = true;if(typeof slideIndex === 'undefined')slideIndex = 0;if(slideIndex < 0)slideIndex = 0;s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);if(s.snapIndex >= s.snapGrid.length)s.snapIndex = s.snapGrid.length - 1;var translate=-s.snapGrid[s.snapIndex]; // Stop autoplay
if(s.params.autoplay && s.autoplaying){if(internal || !s.params.autoplayDisableOnInteraction){s.pauseAutoplay(speed);}else {s.stopAutoplay();}} // Update progress
s.updateProgress(translate); // Normalize slideIndex
for(var i=0;i < s.slidesGrid.length;i++) {if(-Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)){slideIndex = i;}} // Directions locks
if(!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()){return false;}if(!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()){if((s.activeIndex || 0) !== slideIndex)return false;} // Update Index
if(typeof speed === 'undefined')speed = s.params.speed;s.previousIndex = s.activeIndex || 0;s.activeIndex = slideIndex;if(translate === s.translate){s.updateClasses();return false;}s.updateClasses();s.onTransitionStart(runCallbacks);var translateX=isH()?translate:0,translateY=isH()?0:translate;if(speed === 0){s.setWrapperTransition(0);s.setWrapperTranslate(translate);s.onTransitionEnd(runCallbacks);}else {s.setWrapperTransition(speed);s.setWrapperTranslate(translate);if(!s.animating){s.animating = true;s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd(runCallbacks);});}}return true;};s.onTransitionStart = function(runCallbacks){if(typeof runCallbacks === 'undefined')runCallbacks = true;if(s.lazy)s.lazy.onTransitionStart();if(runCallbacks){s.emit('onTransitionStart',s);if(s.activeIndex !== s.previousIndex){s.emit('onSlideChangeStart',s);}}};s.onTransitionEnd = function(runCallbacks){s.animating = false;s.setWrapperTransition(0);if(typeof runCallbacks === 'undefined')runCallbacks = true;if(s.lazy)s.lazy.onTransitionEnd();if(runCallbacks){s.emit('onTransitionEnd',s);if(s.activeIndex !== s.previousIndex){s.emit('onSlideChangeEnd',s);}}if(s.params.hashnav && s.hashnav){s.hashnav.setHash();}};s.slideNext = function(runCallbacks,speed,internal){if(s.params.loop){if(s.animating)return false;s.fixLoop();var clientLeft=s.container[0].clientLeft;return s.slideTo(s.activeIndex + s.params.slidesPerGroup,speed,runCallbacks,internal);}else return s.slideTo(s.activeIndex + s.params.slidesPerGroup,speed,runCallbacks,internal);};s._slideNext = function(speed){return s.slideNext(true,speed,true);};s.slidePrev = function(runCallbacks,speed,internal){if(s.params.loop){if(s.animating)return false;s.fixLoop();var clientLeft=s.container[0].clientLeft;return s.slideTo(s.activeIndex - 1,speed,runCallbacks,internal);}else return s.slideTo(s.activeIndex - 1,speed,runCallbacks,internal);};s._slidePrev = function(speed){return s.slidePrev(true,speed,true);};s.slideReset = function(runCallbacks,speed,internal){return s.slideTo(s.activeIndex,speed,runCallbacks);}; /*=========================
      Translate/transition helpers
      ===========================*/s.setWrapperTransition = function(duration,byController){s.wrapper.transition(duration);if(s.params.effect !== 'slide' && s.effects[s.params.effect]){s.effects[s.params.effect].setTransition(duration);}if(s.params.parallax && s.parallax){s.parallax.setTransition(duration);}if(s.params.scrollbar && s.scrollbar){s.scrollbar.setTransition(duration);}if(s.params.control && s.controller){s.controller.setTransition(duration,byController);}s.emit('onSetTransition',s,duration);};s.setWrapperTranslate = function(translate,updateActiveIndex,byController){var x=0,y=0,z=0;if(isH()){x = s.rtl?-translate:translate;}else {y = translate;}if(!s.params.virtualTranslate){if(s.support.transforms3d)s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');}s.translate = isH()?x:y;if(updateActiveIndex)s.updateActiveIndex();if(s.params.effect !== 'slide' && s.effects[s.params.effect]){s.effects[s.params.effect].setTranslate(s.translate);}if(s.params.parallax && s.parallax){s.parallax.setTranslate(s.translate);}if(s.params.scrollbar && s.scrollbar){s.scrollbar.setTranslate(s.translate);}if(s.params.control && s.controller){s.controller.setTranslate(s.translate,byController);}s.emit('onSetTranslate',s,s.translate);};s.getTranslate = function(el,axis){var matrix,curTransform,curStyle,transformMatrix; // automatic axis detection
if(typeof axis === 'undefined'){axis = 'x';}if(s.params.virtualTranslate){return s.rtl?-s.translate:s.translate;}curStyle = window.getComputedStyle(el,null);if(window.WebKitCSSMatrix){ // Some old versions of Webkit choke when 'none' is passed; pass
// empty string instead in this case
transformMatrix = new window.WebKitCSSMatrix(curStyle.webkitTransform === 'none'?'':curStyle.webkitTransform);}else {transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(','matrix(1, 0, 0, 1,');matrix = transformMatrix.toString().split(',');}if(axis === 'x'){ //Latest Chrome and webkits Fix
if(window.WebKitCSSMatrix)curTransform = transformMatrix.m41;else if(matrix.length === 16)curTransform = parseFloat(matrix[12]);else curTransform = parseFloat(matrix[4]);}if(axis === 'y'){ //Latest Chrome and webkits Fix
if(window.WebKitCSSMatrix)curTransform = transformMatrix.m42;else if(matrix.length === 16)curTransform = parseFloat(matrix[13]);else curTransform = parseFloat(matrix[5]);}if(s.rtl && curTransform)curTransform = -curTransform;return curTransform || 0;};s.getWrapperTranslate = function(axis){if(typeof axis === 'undefined'){axis = isH()?'x':'y';}return s.getTranslate(s.wrapper[0],axis);}; /*=========================
      Observer
      ===========================*/s.observers = [];function initObserver(target,options){options = options || {}; // create an observer instance
var ObserverFunc=window.MutationObserver || window.WebkitMutationObserver;var observer=new ObserverFunc(function(mutations){mutations.forEach(function(mutation){s.onResize(true);s.emit('onObserverUpdate',s,mutation);});});observer.observe(target,{attributes:typeof options.attributes === 'undefined'?true:options.attributes,childList:typeof options.childList === 'undefined'?true:options.childList,characterData:typeof options.characterData === 'undefined'?true:options.characterData});s.observers.push(observer);}s.initObservers = function(){if(s.params.observeParents){var containerParents=s.container.parents();for(var i=0;i < containerParents.length;i++) {initObserver(containerParents[i]);}} // Observe container
initObserver(s.container[0],{childList:false}); // Observe wrapper
initObserver(s.wrapper[0],{attributes:false});};s.disconnectObservers = function(){for(var i=0;i < s.observers.length;i++) {s.observers[i].disconnect();}s.observers = [];}; /*=========================
      Loop
      ===========================*/ // Create looped slides
s.createLoop = function(){ // Remove duplicated slides
s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();var slides=s.wrapper.children('.' + s.params.slideClass);if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides)s.params.loopedSlides = slides.length;s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView,10);s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;if(s.loopedSlides > slides.length){s.loopedSlides = slides.length;}var prependSlides=[],appendSlides=[],i;slides.each(function(index,el){var slide=$(this);if(index < s.loopedSlides)appendSlides.push(el);if(index < slides.length && index >= slides.length - s.loopedSlides)prependSlides.push(el);slide.attr('data-swiper-slide-index',index);});for(i = 0;i < appendSlides.length;i++) {s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));}for(i = prependSlides.length - 1;i >= 0;i--) {s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));}};s.destroyLoop = function(){s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();s.slides.removeAttr('data-swiper-slide-index');};s.fixLoop = function(){var newIndex; //Fix For Negative Oversliding
if(s.activeIndex < s.loopedSlides){newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;newIndex = newIndex + s.loopedSlides;s.slideTo(newIndex,0,false,true);}else if(s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2 || s.activeIndex > s.slides.length - s.params.slidesPerView * 2){newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;newIndex = newIndex + s.loopedSlides;s.slideTo(newIndex,0,false,true);}}; /*=========================
      Append/Prepend/Remove Slides
      ===========================*/s.appendSlide = function(slides){if(s.params.loop){s.destroyLoop();}if(typeof slides === 'object' && slides.length){for(var i=0;i < slides.length;i++) {if(slides[i])s.wrapper.append(slides[i]);}}else {s.wrapper.append(slides);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}};s.prependSlide = function(slides){if(s.params.loop){s.destroyLoop();}var newActiveIndex=s.activeIndex + 1;if(typeof slides === 'object' && slides.length){for(var i=0;i < slides.length;i++) {if(slides[i])s.wrapper.prepend(slides[i]);}newActiveIndex = s.activeIndex + slides.length;}else {s.wrapper.prepend(slides);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}s.slideTo(newActiveIndex,0,false);};s.removeSlide = function(slidesIndexes){if(s.params.loop){s.destroyLoop();s.slides = s.wrapper.children('.' + s.params.slideClass);}var newActiveIndex=s.activeIndex,indexToRemove;if(typeof slidesIndexes === 'object' && slidesIndexes.length){for(var i=0;i < slidesIndexes.length;i++) {indexToRemove = slidesIndexes[i];if(s.slides[indexToRemove])s.slides.eq(indexToRemove).remove();if(indexToRemove < newActiveIndex)newActiveIndex--;}newActiveIndex = Math.max(newActiveIndex,0);}else {indexToRemove = slidesIndexes;if(s.slides[indexToRemove])s.slides.eq(indexToRemove).remove();if(indexToRemove < newActiveIndex)newActiveIndex--;newActiveIndex = Math.max(newActiveIndex,0);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}if(s.params.loop){s.slideTo(newActiveIndex + s.loopedSlides,0,false);}else {s.slideTo(newActiveIndex,0,false);}};s.removeAllSlides = function(){var slidesIndexes=[];for(var i=0;i < s.slides.length;i++) {slidesIndexes.push(i);}s.removeSlide(slidesIndexes);}; /*=========================
      Effects
      ===========================*/s.effects = {fade:{setTranslate:function setTranslate(){for(var i=0;i < s.slides.length;i++) {var slide=s.slides.eq(i);var offset=slide[0].swiperSlideOffset;var tx=-offset;if(!s.params.virtualTranslate)tx = tx - s.translate;var ty=0;if(!isH()){ty = tx;tx = 0;}var slideOpacity=s.params.fade.crossFade?Math.max(1 - Math.abs(slide[0].progress),0):1 + Math.min(Math.max(slide[0].progress,-1),0);slide.css({opacity:slideOpacity}).transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');}},setTransition:function setTransition(duration){s.slides.transition(duration);if(s.params.virtualTranslate && duration !== 0){var eventTriggered=false;s.slides.transitionEnd(function(){if(eventTriggered)return;if(!s)return;eventTriggered = true;s.animating = false;var triggerEvents=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'];for(var i=0;i < triggerEvents.length;i++) {s.wrapper.trigger(triggerEvents[i]);}});}}},cube:{setTranslate:function setTranslate(){var wrapperRotate=0,cubeShadow;if(s.params.cube.shadow){if(isH()){cubeShadow = s.wrapper.find('.swiper-cube-shadow');if(cubeShadow.length === 0){cubeShadow = $('<div class="swiper-cube-shadow"></div>');s.wrapper.append(cubeShadow);}cubeShadow.css({height:s.width + 'px'});}else {cubeShadow = s.container.find('.swiper-cube-shadow');if(cubeShadow.length === 0){cubeShadow = $('<div class="swiper-cube-shadow"></div>');s.container.append(cubeShadow);}}}for(var i=0;i < s.slides.length;i++) {var slide=s.slides.eq(i);var slideAngle=i * 90;var round=Math.floor(slideAngle / 360);if(s.rtl){slideAngle = -slideAngle;round = Math.floor(-slideAngle / 360);}var progress=Math.max(Math.min(slide[0].progress,1),-1);var tx=0,ty=0,tz=0;if(i % 4 === 0){tx = -round * 4 * s.size;tz = 0;}else if((i - 1) % 4 === 0){tx = 0;tz = -round * 4 * s.size;}else if((i - 2) % 4 === 0){tx = s.size + round * 4 * s.size;tz = s.size;}else if((i - 3) % 4 === 0){tx = -s.size;tz = 3 * s.size + s.size * 4 * round;}if(s.rtl){tx = -tx;}if(!isH()){ty = tx;tx = 0;}var transform='rotateX(' + (isH()?0:-slideAngle) + 'deg) rotateY(' + (isH()?slideAngle:0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';if(progress <= 1 && progress > -1){wrapperRotate = i * 90 + progress * 90;if(s.rtl)wrapperRotate = -i * 90 - progress * 90;}slide.transform(transform);if(s.params.cube.slideShadows){ //Set shadows
var shadowBefore=isH()?slide.find('.swiper-slide-shadow-left'):slide.find('.swiper-slide-shadow-top');var shadowAfter=isH()?slide.find('.swiper-slide-shadow-right'):slide.find('.swiper-slide-shadow-bottom');if(shadowBefore.length === 0){shadowBefore = $('<div class="swiper-slide-shadow-' + (isH()?'left':'top') + '"></div>');slide.append(shadowBefore);}if(shadowAfter.length === 0){shadowAfter = $('<div class="swiper-slide-shadow-' + (isH()?'right':'bottom') + '"></div>');slide.append(shadowAfter);}var shadowOpacity=slide[0].progress;if(shadowBefore.length)shadowBefore[0].style.opacity = -slide[0].progress;if(shadowAfter.length)shadowAfter[0].style.opacity = slide[0].progress;}}s.wrapper.css({'-webkit-transform-origin':'50% 50% -' + s.size / 2 + 'px','-moz-transform-origin':'50% 50% -' + s.size / 2 + 'px','-ms-transform-origin':'50% 50% -' + s.size / 2 + 'px','transform-origin':'50% 50% -' + s.size / 2 + 'px'});if(s.params.cube.shadow){if(isH()){cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + -s.width / 2 + 'px) rotateX(90deg) rotateZ(0deg) scale(' + s.params.cube.shadowScale + ')');}else {var shadowAngle=Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;var multiplier=1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);var scale1=s.params.cube.shadowScale,scale2=s.params.cube.shadowScale / multiplier,offset=s.params.cube.shadowOffset;cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + -s.height / 2 / scale2 + 'px) rotateX(-90deg)');}}var zFactor=s.isSafari || s.isUiWebView?-s.size / 2:0;s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isH()?0:wrapperRotate) + 'deg) rotateY(' + (isH()?-wrapperRotate:0) + 'deg)');},setTransition:function setTransition(duration){s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);if(s.params.cube.shadow && !isH()){s.container.find('.swiper-cube-shadow').transition(duration);}}},coverflow:{setTranslate:function setTranslate(){var transform=s.translate;var center=isH()?-transform + s.width / 2:-transform + s.height / 2;var rotate=isH()?s.params.coverflow.rotate:-s.params.coverflow.rotate;var translate=s.params.coverflow.depth; //Each slide offset from center
for(var i=0,length=s.slides.length;i < length;i++) {var slide=s.slides.eq(i);var slideSize=s.slidesSizesGrid[i];var slideOffset=slide[0].swiperSlideOffset;var offsetMultiplier=(center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;var rotateY=isH()?rotate * offsetMultiplier:0;var rotateX=isH()?0:rotate * offsetMultiplier; // var rotateZ = 0
var translateZ=-translate * Math.abs(offsetMultiplier);var translateY=isH()?0:s.params.coverflow.stretch * offsetMultiplier;var translateX=isH()?s.params.coverflow.stretch * offsetMultiplier:0; //Fix for ultra small values
if(Math.abs(translateX) < 0.001)translateX = 0;if(Math.abs(translateY) < 0.001)translateY = 0;if(Math.abs(translateZ) < 0.001)translateZ = 0;if(Math.abs(rotateY) < 0.001)rotateY = 0;if(Math.abs(rotateX) < 0.001)rotateX = 0;var slideTransform='translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';slide.transform(slideTransform);slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;if(s.params.coverflow.slideShadows){ //Set shadows
var shadowBefore=isH()?slide.find('.swiper-slide-shadow-left'):slide.find('.swiper-slide-shadow-top');var shadowAfter=isH()?slide.find('.swiper-slide-shadow-right'):slide.find('.swiper-slide-shadow-bottom');if(shadowBefore.length === 0){shadowBefore = $('<div class="swiper-slide-shadow-' + (isH()?'left':'top') + '"></div>');slide.append(shadowBefore);}if(shadowAfter.length === 0){shadowAfter = $('<div class="swiper-slide-shadow-' + (isH()?'right':'bottom') + '"></div>');slide.append(shadowAfter);}if(shadowBefore.length)shadowBefore[0].style.opacity = offsetMultiplier > 0?offsetMultiplier:0;if(shadowAfter.length)shadowAfter[0].style.opacity = -offsetMultiplier > 0?-offsetMultiplier:0;}} //Set correct perspective for IE10
if(s.browser.ie){var ws=s.wrapper[0].style;ws.perspectiveOrigin = center + 'px 50%';}},setTransition:function setTransition(duration){s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);}}}; /*=========================
      Images Lazy Loading
      ===========================*/s.lazy = {initialImageLoaded:false,loadImageInSlide:function loadImageInSlide(index,loadInDuplicate){if(typeof index === 'undefined')return;if(typeof loadInDuplicate === 'undefined')loadInDuplicate = true;if(s.slides.length === 0)return;var slide=s.slides.eq(index);var img=slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');if(slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')){img.add(slide[0]);}if(img.length === 0)return;img.each(function(){var _img=$(this);_img.addClass('swiper-lazy-loading');var background=_img.attr('data-background');var src=_img.attr('data-src');s.loadImage(_img[0],src || background,false,function(){if(background){_img.css('background-image','url(' + background + ')');_img.removeAttr('data-background');}else {_img.attr('src',src);_img.removeAttr('data-src');}_img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');slide.find('.swiper-lazy-preloader, .preloader').remove();if(s.params.loop && loadInDuplicate){var slideOriginalIndex=slide.attr('data-swiper-slide-index');if(slide.hasClass(s.params.slideDuplicateClass)){var originalSlide=s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');s.lazy.loadImageInSlide(originalSlide.index(),false);}else {var duplicatedSlide=s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');s.lazy.loadImageInSlide(duplicatedSlide.index(),false);}}s.emit('onLazyImageReady',s,slide[0],_img[0]);});s.emit('onLazyImageLoad',s,slide[0],_img[0]);});},load:function load(){var i;if(s.params.watchSlidesVisibility){s.wrapper.children('.' + s.params.slideVisibleClass).each(function(){s.lazy.loadImageInSlide($(this).index());});}else {if(s.params.slidesPerView > 1){for(i = s.activeIndex;i < s.activeIndex + s.params.slidesPerView;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);}}else {s.lazy.loadImageInSlide(s.activeIndex);}}if(s.params.lazyLoadingInPrevNext){if(s.params.slidesPerView > 1){ // Next Slides
for(i = s.activeIndex + s.params.slidesPerView;i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);} // Prev Slides
for(i = s.activeIndex - s.params.slidesPerView;i < s.activeIndex;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);}}else {var nextSlide=s.wrapper.children('.' + s.params.slideNextClass);if(nextSlide.length > 0)s.lazy.loadImageInSlide(nextSlide.index());var prevSlide=s.wrapper.children('.' + s.params.slidePrevClass);if(prevSlide.length > 0)s.lazy.loadImageInSlide(prevSlide.index());}}},onTransitionStart:function onTransitionStart(){if(s.params.lazyLoading){if(s.params.lazyLoadingOnTransitionStart || !s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded){s.lazy.load();}}},onTransitionEnd:function onTransitionEnd(){if(s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart){s.lazy.load();}}}; /*=========================
      Scrollbar
      ===========================*/s.scrollbar = {set:function set(){if(!s.params.scrollbar)return;var sb=s.scrollbar;sb.track = $(s.params.scrollbar);sb.drag = sb.track.find('.swiper-scrollbar-drag');if(sb.drag.length === 0){sb.drag = $('<div class="swiper-scrollbar-drag"></div>');sb.track.append(sb.drag);}sb.drag[0].style.width = '';sb.drag[0].style.height = '';sb.trackSize = isH()?sb.track[0].offsetWidth:sb.track[0].offsetHeight;sb.divider = s.size / s.virtualSize;sb.moveDivider = sb.divider * (sb.trackSize / s.size);sb.dragSize = sb.trackSize * sb.divider;if(isH()){sb.drag[0].style.width = sb.dragSize + 'px';}else {sb.drag[0].style.height = sb.dragSize + 'px';}if(sb.divider >= 1){sb.track[0].style.display = 'none';}else {sb.track[0].style.display = '';}if(s.params.scrollbarHide){sb.track[0].style.opacity = 0;}},setTranslate:function setTranslate(){if(!s.params.scrollbar)return;var diff;var sb=s.scrollbar;var translate=s.translate || 0;var newPos;var newSize=sb.dragSize;newPos = (sb.trackSize - sb.dragSize) * s.progress;if(s.rtl && isH()){newPos = -newPos;if(newPos > 0){newSize = sb.dragSize - newPos;newPos = 0;}else if(-newPos + sb.dragSize > sb.trackSize){newSize = sb.trackSize + newPos;}}else {if(newPos < 0){newSize = sb.dragSize + newPos;newPos = 0;}else if(newPos + sb.dragSize > sb.trackSize){newSize = sb.trackSize - newPos;}}if(isH()){if(s.support.transforms3d){sb.drag.transform('translate3d(' + newPos + 'px, 0, 0)');}else {sb.drag.transform('translateX(' + newPos + 'px)');}sb.drag[0].style.width = newSize + 'px';}else {if(s.support.transforms3d){sb.drag.transform('translate3d(0px, ' + newPos + 'px, 0)');}else {sb.drag.transform('translateY(' + newPos + 'px)');}sb.drag[0].style.height = newSize + 'px';}if(s.params.scrollbarHide){clearTimeout(sb.timeout);sb.track[0].style.opacity = 1;sb.timeout = setTimeout(function(){sb.track[0].style.opacity = 0;sb.track.transition(400);},1000);}},setTransition:function setTransition(duration){if(!s.params.scrollbar)return;s.scrollbar.drag.transition(duration);}}; /*=========================
      Controller
      ===========================*/s.controller = {LinearSpline:function LinearSpline(x,y){this.x = x;this.y = y;this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
// (x1,y1) is the known point before given value,
// (x3,y3) is the known point after given value.
var i1,i3;var l=this.x.length;this.interpolate = function(x2){if(!x2)return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):
i3 = binarySearch(this.x,x2);i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
// y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];};var binarySearch=(function(){var maxIndex,minIndex,guess;return function(array,val){minIndex = -1;maxIndex = array.length;while(maxIndex - minIndex > 1) if(array[guess = maxIndex + minIndex >> 1] <= val){minIndex = guess;}else {maxIndex = guess;}return maxIndex;};})();}, //xxx: for now i will just save one spline function to to
getInterpolateFunction:function getInterpolateFunction(c){if(!s.controller.spline)s.controller.spline = s.params.loop?new s.controller.LinearSpline(s.slidesGrid,c.slidesGrid):new s.controller.LinearSpline(s.snapGrid,c.snapGrid);},setTranslate:function setTranslate(translate,byController){var controlled=s.params.control;var multiplier,controlledTranslate;function setControlledTranslate(c){ // this will create an Interpolate function based on the snapGrids
// x is the Grid of the scrolled scroller and y will be the controlled scroller
// it makes sense to create this only once and recall it for the interpolation
// the function does a lot of value caching for performance
translate = c.rtl && c.params.direction === 'horizontal'?-s.translate:s.translate;if(s.params.controlBy === 'slide'){s.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
// but it did not work out
controlledTranslate = -s.controller.spline.interpolate(-translate);}if(!controlledTranslate || s.params.controlBy === 'container'){multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();}if(s.params.controlInverse){controlledTranslate = c.maxTranslate() - controlledTranslate;}c.updateProgress(controlledTranslate);c.setWrapperTranslate(controlledTranslate,false,s);c.updateActiveIndex();}if(s.isArray(controlled)){for(var i=0;i < controlled.length;i++) {if(controlled[i] !== byController && controlled[i] instanceof Swiper){setControlledTranslate(controlled[i]);}}}else if(controlled instanceof Swiper && byController !== controlled){setControlledTranslate(controlled);}},setTransition:function setTransition(duration,byController){var controlled=s.params.control;var i;function setControlledTransition(c){c.setWrapperTransition(duration,s);if(duration !== 0){c.onTransitionStart();c.wrapper.transitionEnd(function(){if(!controlled)return;if(c.params.loop && s.params.controlBy === 'slide'){c.fixLoop();}c.onTransitionEnd();});}}if(s.isArray(controlled)){for(i = 0;i < controlled.length;i++) {if(controlled[i] !== byController && controlled[i] instanceof Swiper){setControlledTransition(controlled[i]);}}}else if(controlled instanceof Swiper && byController !== controlled){setControlledTransition(controlled);}}}; /*=========================
      Hash Navigation
      ===========================*/s.hashnav = {init:function init(){if(!s.params.hashnav)return;s.hashnav.initialized = true;var hash=document.location.hash.replace('#','');if(!hash)return;var speed=0;for(var i=0,length=s.slides.length;i < length;i++) {var slide=s.slides.eq(i);var slideHash=slide.attr('data-hash');if(slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)){var index=slide.index();s.slideTo(index,speed,s.params.runCallbacksOnInit,true);}}},setHash:function setHash(){if(!s.hashnav.initialized || !s.params.hashnav)return;document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';}}; /*=========================
      Keyboard Control
      ===========================*/function handleKeyboard(e){if(e.originalEvent)e = e.originalEvent; //jquery fix
var kc=e.keyCode || e.charCode; // Directions locks
if(!s.params.allowSwipeToNext && (isH() && kc === 39 || !isH() && kc === 40)){return false;}if(!s.params.allowSwipeToPrev && (isH() && kc === 37 || !isH() && kc === 38)){return false;}if(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey){return;}if(document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')){return;}if(kc === 37 || kc === 39 || kc === 38 || kc === 40){var inView=false; //Check that swiper should be inside of visible area of window
if(s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0){return;}var windowScroll={left:window.pageXOffset,top:window.pageYOffset};var windowWidth=window.innerWidth;var windowHeight=window.innerHeight;var swiperOffset=s.container.offset();if(s.rtl)swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;var swiperCoord=[[swiperOffset.left,swiperOffset.top],[swiperOffset.left + s.width,swiperOffset.top],[swiperOffset.left,swiperOffset.top + s.height],[swiperOffset.left + s.width,swiperOffset.top + s.height]];for(var i=0;i < swiperCoord.length;i++) {var point=swiperCoord[i];if(point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight){inView = true;}}if(!inView)return;}if(isH()){if(kc === 37 || kc === 39){if(e.preventDefault)e.preventDefault();else e.returnValue = false;}if(kc === 39 && !s.rtl || kc === 37 && s.rtl)s.slideNext();if(kc === 37 && !s.rtl || kc === 39 && s.rtl)s.slidePrev();}else {if(kc === 38 || kc === 40){if(e.preventDefault)e.preventDefault();else e.returnValue = false;}if(kc === 40)s.slideNext();if(kc === 38)s.slidePrev();}}s.disableKeyboardControl = function(){$(document).off('keydown',handleKeyboard);};s.enableKeyboardControl = function(){$(document).on('keydown',handleKeyboard);}; /*=========================
      Mousewheel Control
      ===========================*/s.mousewheel = {event:false,lastScrollTime:new window.Date().getTime()};if(s.params.mousewheelControl){try{new window.WheelEvent('wheel');s.mousewheel.event = 'wheel';}catch(e) {}if(!s.mousewheel.event && document.onmousewheel !== undefined){s.mousewheel.event = 'mousewheel';}if(!s.mousewheel.event){s.mousewheel.event = 'DOMMouseScroll';}}function handleMousewheel(e){if(e.originalEvent)e = e.originalEvent; //jquery fix
var we=s.mousewheel.event;var delta=0; //Opera & IE
if(e.detail)delta = -e.detail;else if(we === 'mousewheel'){if(s.params.mousewheelForceToAxis){if(isH()){if(Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY))delta = e.wheelDeltaX;else return;}else {if(Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX))delta = e.wheelDeltaY;else return;}}else {delta = e.wheelDelta;}}else if(we === 'DOMMouseScroll')delta = -e.detail;else if(we === 'wheel'){if(s.params.mousewheelForceToAxis){if(isH()){if(Math.abs(e.deltaX) > Math.abs(e.deltaY))delta = -e.deltaX;else return;}else {if(Math.abs(e.deltaY) > Math.abs(e.deltaX))delta = -e.deltaY;else return;}}else {delta = Math.abs(e.deltaX) > Math.abs(e.deltaY)?-e.deltaX:-e.deltaY;}}if(s.params.mousewheelInvert)delta = -delta;if(!s.params.freeMode){if(new window.Date().getTime() - s.mousewheel.lastScrollTime > 60){if(delta < 0){if((!s.isEnd || s.params.loop) && !s.animating)s.slideNext();else if(s.params.mousewheelReleaseOnEdges)return true;}else {if((!s.isBeginning || s.params.loop) && !s.animating)s.slidePrev();else if(s.params.mousewheelReleaseOnEdges)return true;}}s.mousewheel.lastScrollTime = new window.Date().getTime();}else { //Freemode or scrollContainer:
var position=s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;if(position > 0)position = 0;if(position < s.maxTranslate())position = s.maxTranslate();s.setWrapperTransition(0);s.setWrapperTranslate(position);s.updateProgress();s.updateActiveIndex();if(s.params.freeModeSticky){clearTimeout(s.mousewheel.timeout);s.mousewheel.timeout = setTimeout(function(){s.slideReset();},300);} // Return page scroll on edge positions
if(position === 0 || position === s.maxTranslate())return;}if(s.params.autoplay)s.stopAutoplay();if(e.preventDefault)e.preventDefault();else e.returnValue = false;return false;}s.disableMousewheelControl = function(){if(!s.mousewheel.event)return false;s.container.off(s.mousewheel.event,handleMousewheel);return true;};s.enableMousewheelControl = function(){if(!s.mousewheel.event)return false;s.container.on(s.mousewheel.event,handleMousewheel);return true;}; /*=========================
      Parallax
      ===========================*/function setParallaxTransform(el,progress){el = $(el);var p,pX,pY;p = el.attr('data-swiper-parallax') || '0';pX = el.attr('data-swiper-parallax-x');pY = el.attr('data-swiper-parallax-y');if(pX || pY){pX = pX || '0';pY = pY || '0';}else {if(isH()){pX = p;pY = '0';}else {pY = p;pX = '0';}}if(pX.indexOf('%') >= 0){pX = parseInt(pX,10) * progress + '%';}else {pX = pX * progress + 'px';}if(pY.indexOf('%') >= 0){pY = parseInt(pY,10) * progress + '%';}else {pY = pY * progress + 'px';}el.transform('translate3d(' + pX + ', ' + pY + ',0px)');}s.parallax = {setTranslate:function setTranslate(){s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){setParallaxTransform(this,s.progress);});s.slides.each(function(){var slide=$(this);slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){var progress=Math.min(Math.max(slide[0].progress,-1),1);setParallaxTransform(this,progress);});});},setTransition:function setTransition(duration){if(typeof duration === 'undefined')duration = s.params.speed;s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){var el=$(this);var parallaxDuration=parseInt(el.attr('data-swiper-parallax-duration'),10) || duration;if(duration === 0)parallaxDuration = 0;el.transition(parallaxDuration);});}}; /*=========================
      Plugins API. Collect all and init all plugins
      ===========================*/s._plugins = [];for(var plugin in s.plugins) {var p=s.plugins[plugin](s,s.params[plugin]);if(p)s._plugins.push(p);} // Method to call all plugins event/method
s.callPlugins = function(eventName){for(var i=0;i < s._plugins.length;i++) {if(eventName in s._plugins[i]){s._plugins[i][eventName](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}}}; /*=========================
      Events/Callbacks/Plugins Emitter
      ===========================*/function normalizeEventName(eventName){if(eventName.indexOf('on') !== 0){if(eventName[0] !== eventName[0].toUpperCase()){eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);}else {eventName = 'on' + eventName;}}return eventName;}s.emitterEventListeners = {};s.emit = function(eventName){ // Trigger callbacks
if(s.params[eventName]){s.params[eventName](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}var i; // Trigger events
if(s.emitterEventListeners[eventName]){for(i = 0;i < s.emitterEventListeners[eventName].length;i++) {s.emitterEventListeners[eventName][i](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}} // Trigger plugins
if(s.callPlugins)s.callPlugins(eventName,arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);};s.on = function(eventName,handler){eventName = normalizeEventName(eventName);if(!s.emitterEventListeners[eventName])s.emitterEventListeners[eventName] = [];s.emitterEventListeners[eventName].push(handler);return s;};s.off = function(eventName,handler){var i;eventName = normalizeEventName(eventName);if(typeof handler === 'undefined'){ // Remove all handlers for such event
s.emitterEventListeners[eventName] = [];return s;}if(!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0)return;for(i = 0;i < s.emitterEventListeners[eventName].length;i++) {if(s.emitterEventListeners[eventName][i] === handler)s.emitterEventListeners[eventName].splice(i,1);}return s;};s.once = function(eventName,handler){eventName = normalizeEventName(eventName);var _handler=function _handler(){handler(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);s.off(eventName,_handler);};s.on(eventName,_handler);return s;}; // Accessibility tools
s.a11y = {makeFocusable:function makeFocusable($el){$el.attr('tabIndex','0');return $el;},addRole:function addRole($el,role){$el.attr('role',role);return $el;},addLabel:function addLabel($el,label){$el.attr('aria-label',label);return $el;},disable:function disable($el){$el.attr('aria-disabled',true);return $el;},enable:function enable($el){$el.attr('aria-disabled',false);return $el;},onEnterKey:function onEnterKey(event){if(event.keyCode !== 13)return;if($(event.target).is(s.params.nextButton)){s.onClickNext(event);if(s.isEnd){s.a11y.notify(s.params.lastSlideMessage);}else {s.a11y.notify(s.params.nextSlideMessage);}}else if($(event.target).is(s.params.prevButton)){s.onClickPrev(event);if(s.isBeginning){s.a11y.notify(s.params.firstSlideMessage);}else {s.a11y.notify(s.params.prevSlideMessage);}}if($(event.target).is('.' + s.params.bulletClass)){$(event.target)[0].click();}},liveRegion:$('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),notify:function notify(message){var notification=s.a11y.liveRegion;if(notification.length === 0)return;notification.html('');notification.html(message);},init:function init(){ // Setup accessibility
if(s.params.nextButton){var nextButton=$(s.params.nextButton);s.a11y.makeFocusable(nextButton);s.a11y.addRole(nextButton,'button');s.a11y.addLabel(nextButton,s.params.nextSlideMessage);}if(s.params.prevButton){var prevButton=$(s.params.prevButton);s.a11y.makeFocusable(prevButton);s.a11y.addRole(prevButton,'button');s.a11y.addLabel(prevButton,s.params.prevSlideMessage);}$(s.container).append(s.a11y.liveRegion);},initPagination:function initPagination(){if(s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length){s.bullets.each(function(){var bullet=$(this);s.a11y.makeFocusable(bullet);s.a11y.addRole(bullet,'button');s.a11y.addLabel(bullet,s.params.paginationBulletMessage.replace(/{{index}}/,bullet.index() + 1));});}},destroy:function destroy(){if(s.a11y.liveRegion && s.a11y.liveRegion.length > 0)s.a11y.liveRegion.remove();}}; /*=========================
      Init/Destroy
      ===========================*/s.init = function(){if(s.params.loop)s.createLoop();s.updateContainerSize();s.updateSlidesSize();s.updatePagination();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}if(s.params.effect !== 'slide' && s.effects[s.params.effect]){if(!s.params.loop)s.updateProgress();s.effects[s.params.effect].setTranslate();}if(s.params.loop){s.slideTo(s.params.initialSlide + s.loopedSlides,0,s.params.runCallbacksOnInit);}else {s.slideTo(s.params.initialSlide,0,s.params.runCallbacksOnInit);if(s.params.initialSlide === 0){if(s.parallax && s.params.parallax)s.parallax.setTranslate();if(s.lazy && s.params.lazyLoading){s.lazy.load();s.lazy.initialImageLoaded = true;}}}s.attachEvents();if(s.params.observer && s.support.observer){s.initObservers();}if(s.params.preloadImages && !s.params.lazyLoading){s.preloadImages();}if(s.params.autoplay){s.startAutoplay();}if(s.params.keyboardControl){if(s.enableKeyboardControl)s.enableKeyboardControl();}if(s.params.mousewheelControl){if(s.enableMousewheelControl)s.enableMousewheelControl();}if(s.params.hashnav){if(s.hashnav)s.hashnav.init();}if(s.params.a11y && s.a11y)s.a11y.init();s.emit('onInit',s);}; // Cleanup dynamic styles
s.cleanupStyles = function(){ // Container
s.container.removeClass(s.classNames.join(' ')).removeAttr('style'); // Wrapper
s.wrapper.removeAttr('style'); // Slides
if(s.slides && s.slides.length){s.slides.removeClass([s.params.slideVisibleClass,s.params.slideActiveClass,s.params.slideNextClass,s.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row');} // Pagination/Bullets
if(s.paginationContainer && s.paginationContainer.length){s.paginationContainer.removeClass(s.params.paginationHiddenClass);}if(s.bullets && s.bullets.length){s.bullets.removeClass(s.params.bulletActiveClass);} // Buttons
if(s.params.prevButton)$(s.params.prevButton).removeClass(s.params.buttonDisabledClass);if(s.params.nextButton)$(s.params.nextButton).removeClass(s.params.buttonDisabledClass); // Scrollbar
if(s.params.scrollbar && s.scrollbar){if(s.scrollbar.track && s.scrollbar.track.length)s.scrollbar.track.removeAttr('style');if(s.scrollbar.drag && s.scrollbar.drag.length)s.scrollbar.drag.removeAttr('style');}}; // Destroy
s.destroy = function(deleteInstance,cleanupStyles){ // Detach evebts
s.detachEvents(); // Stop autoplay
s.stopAutoplay(); // Destroy loop
if(s.params.loop){s.destroyLoop();} // Cleanup styles
if(cleanupStyles){s.cleanupStyles();} // Disconnect observer
s.disconnectObservers(); // Disable keyboard/mousewheel
if(s.params.keyboardControl){if(s.disableKeyboardControl)s.disableKeyboardControl();}if(s.params.mousewheelControl){if(s.disableMousewheelControl)s.disableMousewheelControl();} // Disable a11y
if(s.params.a11y && s.a11y)s.a11y.destroy(); // Destroy callback
s.emit('onDestroy'); // Delete instance
if(deleteInstance !== false)s = null;};s.init(); // Return swiper instance
return s;} /*===========================
Add .swiper plugin from Dom libraries
===========================*/function addLibraryPlugin(lib){lib.fn.swiper = function(params){var firstInstance;lib(this).each(function(){var s=new Swiper(this,params);if(!firstInstance)firstInstance = s;});return firstInstance;};}return {setters:[],execute:function(){; /*==================================================
    Prototype
====================================================*/Swiper.prototype = {isSafari:(function(){var ua=navigator.userAgent.toLowerCase();return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;})(),isUiWebView:/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),isArray:function isArray(arr){return Object.prototype.toString.apply(arr) === '[object Array]';}, /*==================================================
    Browser
    ====================================================*/browser:{ie:window.navigator.pointerEnabled || window.navigator.msPointerEnabled,ieTouch:window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1}, /*==================================================
    Devices
    ====================================================*/device:(function(){var ua=navigator.userAgent;var android=ua.match(/(Android);?[\s\/]+([\d.]+)?/);var ipad=ua.match(/(iPad).*OS\s([\d_]+)/);var ipod=ua.match(/(iPod)(.*OS\s([\d_]+))?/);var iphone=!ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);return {ios:ipad || iphone || ipod,android:android};})(), /*==================================================
    Feature Detection
    ====================================================*/support:{touch:window.Modernizr && Modernizr.touch === true || (function(){return !!('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);})(),transforms3d:window.Modernizr && Modernizr.csstransforms3d === true || (function(){var div=document.createElement('div').style;return 'webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div;})(),flexbox:(function(){var div=document.createElement('div').style;var styles='alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' ');for(var i=0;i < styles.length;i++) {if(styles[i] in div)return true;}})(),observer:(function(){return 'MutationObserver' in window || 'WebkitMutationObserver' in window;})()}, /*==================================================
    Plugins
    ====================================================*/plugins:{}}; /*===========================
Dom7 Library
===========================*/Dom7 = (function(){var Dom7=function Dom7(arr){var _this=this,i=0; // Create array-like object
for(i = 0;i < arr.length;i++) {_this[i] = arr[i];}_this.length = arr.length; // Return collection with methods
return this;};var $=function $(selector,context){var arr=[],i=0;if(selector && !context){if(selector instanceof Dom7){return selector;}}if(selector){ // String
if(typeof selector === 'string'){var els,tempParent,html=selector.trim();if(html.indexOf('<') >= 0 && html.indexOf('>') >= 0){var toCreate='div';if(html.indexOf('<li') === 0)toCreate = 'ul';if(html.indexOf('<tr') === 0)toCreate = 'tbody';if(html.indexOf('<td') === 0 || html.indexOf('<th') === 0)toCreate = 'tr';if(html.indexOf('<tbody') === 0)toCreate = 'table';if(html.indexOf('<option') === 0)toCreate = 'select';tempParent = document.createElement(toCreate);tempParent.innerHTML = selector;for(i = 0;i < tempParent.childNodes.length;i++) {arr.push(tempParent.childNodes[i]);}}else {if(!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)){ // Pure ID selector
els = [document.getElementById(selector.split('#')[1])];}else { // Other selectors
els = (context || document).querySelectorAll(selector);}for(i = 0;i < els.length;i++) {if(els[i])arr.push(els[i]);}}}else if(selector.nodeType || selector === window || selector === document){arr.push(selector);}else if(selector.length > 0 && selector[0].nodeType){for(i = 0;i < selector.length;i++) {arr.push(selector[i]);}}}return new Dom7(arr);};Dom7.prototype = { // Classes and attriutes
addClass:function addClass(className){if(typeof className === 'undefined'){return this;}var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.add(classes[i]);}}return this;},removeClass:function removeClass(className){var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.remove(classes[i]);}}return this;},hasClass:function hasClass(className){if(!this[0])return false;else return this[0].classList.contains(className);},toggleClass:function toggleClass(className){var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.toggle(classes[i]);}}return this;},attr:function attr(attrs,value){if(arguments.length === 1 && typeof attrs === 'string'){ // Get attr
if(this[0])return this[0].getAttribute(attrs);else return undefined;}else { // Set attrs
for(var i=0;i < this.length;i++) {if(arguments.length === 2){ // String
this[i].setAttribute(attrs,value);}else { // Object
for(var attrName in attrs) {this[i][attrName] = attrs[attrName];this[i].setAttribute(attrName,attrs[attrName]);}}}return this;}},removeAttr:function removeAttr(attr){for(var i=0;i < this.length;i++) {this[i].removeAttribute(attr);}return this;},data:function data(key,value){if(typeof value === 'undefined'){ // Get value
if(this[0]){var dataKey=this[0].getAttribute('data-' + key);if(dataKey)return dataKey;else if(this[0].dom7ElementDataStorage && key in this[0].dom7ElementDataStorage)return this[0].dom7ElementDataStorage[key];else return undefined;}else return undefined;}else { // Set value
for(var i=0;i < this.length;i++) {var el=this[i];if(!el.dom7ElementDataStorage)el.dom7ElementDataStorage = {};el.dom7ElementDataStorage[key] = value;}return this;}}, // Transforms
transform:function transform(_transform){for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = _transform;}return this;},transition:function transition(duration){if(typeof duration !== 'string'){duration = duration + 'ms';}for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;}return this;}, //Events
on:function on(eventName,targetSelector,listener,capture){function handleLiveEvent(e){var target=e.target;if($(target).is(targetSelector))listener.call(target,e);else {var parents=$(target).parents();for(var k=0;k < parents.length;k++) {if($(parents[k]).is(targetSelector))listener.call(parents[k],e);}}}var events=eventName.split(' ');var i,j;for(i = 0;i < this.length;i++) {if(typeof targetSelector === 'function' || targetSelector === false){ // Usual events
if(typeof targetSelector === 'function'){listener = arguments[1];capture = arguments[2] || false;}for(j = 0;j < events.length;j++) {this[i].addEventListener(events[j],listener,capture);}}else { //Live events
for(j = 0;j < events.length;j++) {if(!this[i].dom7LiveListeners)this[i].dom7LiveListeners = [];this[i].dom7LiveListeners.push({listener:listener,liveListener:handleLiveEvent});this[i].addEventListener(events[j],handleLiveEvent,capture);}}}return this;},off:function off(eventName,targetSelector,listener,capture){var events=eventName.split(' ');for(var i=0;i < events.length;i++) {for(var j=0;j < this.length;j++) {if(typeof targetSelector === 'function' || targetSelector === false){ // Usual events
if(typeof targetSelector === 'function'){listener = arguments[1];capture = arguments[2] || false;}this[j].removeEventListener(events[i],listener,capture);}else { // Live event
if(this[j].dom7LiveListeners){for(var k=0;k < this[j].dom7LiveListeners.length;k++) {if(this[j].dom7LiveListeners[k].listener === listener){this[j].removeEventListener(events[i],this[j].dom7LiveListeners[k].liveListener,capture);}}}}}}return this;},once:function once(eventName,targetSelector,listener,capture){var dom=this;if(typeof targetSelector === 'function'){targetSelector = false;listener = arguments[1];capture = arguments[2];}function proxy(e){listener(e);dom.off(eventName,targetSelector,proxy,capture);}dom.on(eventName,targetSelector,proxy,capture);},trigger:function trigger(eventName,eventData){for(var i=0;i < this.length;i++) {var evt;try{evt = new window.CustomEvent(eventName,{detail:eventData,bubbles:true,cancelable:true});}catch(e) {evt = document.createEvent('Event');evt.initEvent(eventName,true,true);evt.detail = eventData;}this[i].dispatchEvent(evt);}return this;},transitionEnd:function transitionEnd(callback){var events=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'],i,j,dom=this;function fireCallBack(e){ /*jshint validthis:true */if(e.target !== this)return;callback.call(this,e);for(i = 0;i < events.length;i++) {dom.off(events[i],fireCallBack);}}if(callback){for(i = 0;i < events.length;i++) {dom.on(events[i],fireCallBack);}}return this;}, // Sizing/Styles
width:function width(){if(this[0] === window){return window.innerWidth;}else {if(this.length > 0){return parseFloat(this.css('width'));}else {return null;}}},outerWidth:function outerWidth(includeMargins){if(this.length > 0){if(includeMargins)return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));else return this[0].offsetWidth;}else return null;},height:function height(){if(this[0] === window){return window.innerHeight;}else {if(this.length > 0){return parseFloat(this.css('height'));}else {return null;}}},outerHeight:function outerHeight(includeMargins){if(this.length > 0){if(includeMargins)return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));else return this[0].offsetHeight;}else return null;},offset:function offset(){if(this.length > 0){var el=this[0];var box=el.getBoundingClientRect();var body=document.body;var clientTop=el.clientTop || body.clientTop || 0;var clientLeft=el.clientLeft || body.clientLeft || 0;var scrollTop=window.pageYOffset || el.scrollTop;var scrollLeft=window.pageXOffset || el.scrollLeft;return {top:box.top + scrollTop - clientTop,left:box.left + scrollLeft - clientLeft};}else {return null;}},css:function css(props,value){var i;if(arguments.length === 1){if(typeof props === 'string'){if(this[0])return window.getComputedStyle(this[0],null).getPropertyValue(props);}else {for(i = 0;i < this.length;i++) {for(var prop in props) {this[i].style[prop] = props[prop];}}return this;}}if(arguments.length === 2 && typeof props === 'string'){for(i = 0;i < this.length;i++) {this[i].style[props] = value;}return this;}return this;}, //Dom manipulation
each:function each(callback){for(var i=0;i < this.length;i++) {callback.call(this[i],i,this[i]);}return this;},html:function html(_html){if(typeof _html === 'undefined'){return this[0]?this[0].innerHTML:undefined;}else {for(var i=0;i < this.length;i++) {this[i].innerHTML = _html;}return this;}},is:function is(selector){if(!this[0])return false;var compareWith,i;if(typeof selector === 'string'){var el=this[0];if(el === document)return selector === document;if(el === window)return selector === window;if(el.matches)return el.matches(selector);else if(el.webkitMatchesSelector)return el.webkitMatchesSelector(selector);else if(el.mozMatchesSelector)return el.mozMatchesSelector(selector);else if(el.msMatchesSelector)return el.msMatchesSelector(selector);else {compareWith = $(selector);for(i = 0;i < compareWith.length;i++) {if(compareWith[i] === this[0])return true;}return false;}}else if(selector === document)return this[0] === document;else if(selector === window)return this[0] === window;else {if(selector.nodeType || selector instanceof Dom7){compareWith = selector.nodeType?[selector]:selector;for(i = 0;i < compareWith.length;i++) {if(compareWith[i] === this[0])return true;}return false;}return false;}},index:function index(){if(this[0]){var child=this[0];var i=0;while((child = child.previousSibling) !== null) {if(child.nodeType === 1)i++;}return i;}else return undefined;},eq:function eq(index){if(typeof index === 'undefined')return this;var length=this.length;var returnIndex;if(index > length - 1){return new Dom7([]);}if(index < 0){returnIndex = length + index;if(returnIndex < 0)return new Dom7([]);else return new Dom7([this[returnIndex]]);}return new Dom7([this[index]]);},append:function append(newChild){var i,j;for(i = 0;i < this.length;i++) {if(typeof newChild === 'string'){var tempDiv=document.createElement('div');tempDiv.innerHTML = newChild;while(tempDiv.firstChild) {this[i].appendChild(tempDiv.firstChild);}}else if(newChild instanceof Dom7){for(j = 0;j < newChild.length;j++) {this[i].appendChild(newChild[j]);}}else {this[i].appendChild(newChild);}}return this;},prepend:function prepend(newChild){var i,j;for(i = 0;i < this.length;i++) {if(typeof newChild === 'string'){var tempDiv=document.createElement('div');tempDiv.innerHTML = newChild;for(j = tempDiv.childNodes.length - 1;j >= 0;j--) {this[i].insertBefore(tempDiv.childNodes[j],this[i].childNodes[0]);}}else if(newChild instanceof Dom7){for(j = 0;j < newChild.length;j++) {this[i].insertBefore(newChild[j],this[i].childNodes[0]);}}else {this[i].insertBefore(newChild,this[i].childNodes[0]);}}return this;},insertBefore:function insertBefore(selector){var before=$(selector);for(var i=0;i < this.length;i++) {if(before.length === 1){before[0].parentNode.insertBefore(this[i],before[0]);}else if(before.length > 1){for(var j=0;j < before.length;j++) {before[j].parentNode.insertBefore(this[i].cloneNode(true),before[j]);}}}},insertAfter:function insertAfter(selector){var after=$(selector);for(var i=0;i < this.length;i++) {if(after.length === 1){after[0].parentNode.insertBefore(this[i],after[0].nextSibling);}else if(after.length > 1){for(var j=0;j < after.length;j++) {after[j].parentNode.insertBefore(this[i].cloneNode(true),after[j].nextSibling);}}}},next:function next(selector){if(this.length > 0){if(selector){if(this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector))return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);}else {if(this[0].nextElementSibling)return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);}}else return new Dom7([]);},nextAll:function nextAll(selector){var nextEls=[];var el=this[0];if(!el)return new Dom7([]);while(el.nextElementSibling) {var next=el.nextElementSibling;if(selector){if($(next).is(selector))nextEls.push(next);}else nextEls.push(next);el = next;}return new Dom7(nextEls);},prev:function prev(selector){if(this.length > 0){if(selector){if(this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector))return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);}else {if(this[0].previousElementSibling)return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);}}else return new Dom7([]);},prevAll:function prevAll(selector){var prevEls=[];var el=this[0];if(!el)return new Dom7([]);while(el.previousElementSibling) {var prev=el.previousElementSibling;if(selector){if($(prev).is(selector))prevEls.push(prev);}else prevEls.push(prev);el = prev;}return new Dom7(prevEls);},parent:function parent(selector){var parents=[];for(var i=0;i < this.length;i++) {if(selector){if($(this[i].parentNode).is(selector))parents.push(this[i].parentNode);}else {parents.push(this[i].parentNode);}}return $($.unique(parents));},parents:function parents(selector){var parents=[];for(var i=0;i < this.length;i++) {var parent=this[i].parentNode;while(parent) {if(selector){if($(parent).is(selector))parents.push(parent);}else {parents.push(parent);}parent = parent.parentNode;}}return $($.unique(parents));},find:function find(selector){var foundElements=[];for(var i=0;i < this.length;i++) {var found=this[i].querySelectorAll(selector);for(var j=0;j < found.length;j++) {foundElements.push(found[j]);}}return new Dom7(foundElements);},children:function children(selector){var children=[];for(var i=0;i < this.length;i++) {var childNodes=this[i].childNodes;for(var j=0;j < childNodes.length;j++) {if(!selector){if(childNodes[j].nodeType === 1)children.push(childNodes[j]);}else {if(childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector))children.push(childNodes[j]);}}}return new Dom7($.unique(children));},remove:function remove(){for(var i=0;i < this.length;i++) {if(this[i].parentNode)this[i].parentNode.removeChild(this[i]);}return this;},add:function add(){var dom=this;var i,j;for(i = 0;i < arguments.length;i++) {var toAdd=$(arguments[i]);for(j = 0;j < toAdd.length;j++) {dom[dom.length] = toAdd[j];dom.length++;}}return dom;}};$.fn = Dom7.prototype;$.unique = function(arr){var unique=[];for(var i=0;i < arr.length;i++) {if(unique.indexOf(arr[i]) === -1)unique.push(arr[i]);}return unique;};return $;})(); /*===========================
 Get Dom libraries
 ===========================*/swiperDomPlugins = ['jQuery','Zepto','Dom7'];for(i = 0;i < swiperDomPlugins.length;i++) {if(window[swiperDomPlugins[i]]){addLibraryPlugin(window[swiperDomPlugins[i]]);}} // Required DOM Plugins
if(typeof Dom7 === 'undefined'){domLib = window.Dom7 || window.Zepto || window.jQuery;}else {domLib = Dom7;}if(domLib){if(!('transitionEnd' in domLib.fn)){domLib.fn.transitionEnd = function(callback){var events=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'],i,j,dom=this;function fireCallBack(e){ /*jshint validthis:true */if(e.target !== this)return;callback.call(this,e);for(i = 0;i < events.length;i++) {dom.off(events[i],fireCallBack);}}if(callback){for(i = 0;i < events.length;i++) {dom.on(events[i],fireCallBack);}}return this;};}if(!('transform' in domLib.fn)){domLib.fn.transform = function(transform){for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;}return this;};}if(!('transition' in domLib.fn)){domLib.fn.transition = function(duration){if(typeof duration !== 'string'){duration = duration + 'ms';}for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;}return this;};}}}};});
System.register("ionic/components/switch/switch", ["angular2/angular2", "../ion", "../form/input", "../../config/config", "../../config/decorators", "../../util/dom"], function (_export) {
    /**
     * @name mediaSwitch
     * @private
     */
    "use strict";

    var Directive, ElementRef, Host, Optional, NgControl, Inject, forwardRef, Ion, IonInput, IonicConfig, IonicComponent, IonicView, pointerCoord, __decorate, __metadata, __param, MediaSwitch, Switch, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_formInput) {
            IonInput = _formInput.IonInput;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
            IonicView = _configDecorators.IonicView;
        }, function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            MediaSwitch =
            /**
             * TODO
             * @param {Switch} swtch  TODO
             * @param {} elementRef  TODO
             * @param {IonicConfig} config  TODO
             */
            function MediaSwitch(swtch, elementRef) {
                _classCallCheck(this, MediaSwitch);

                swtch.switchEle = elementRef.nativeElement;
                this.swtch = swtch;
            };

            MediaSwitch = __decorate([Directive({
                selector: '.media-switch',
                host: {
                    'tappable': 'true',
                    '(touchstart)': 'swtch.pointerDown($event)',
                    '(mousedown)': 'swtch.pointerDown($event)',
                    '[class.switch-activated]': 'swtch.isActivated'
                }
            }), __param(0, Host()), __param(0, Inject(forwardRef(function () {
                return Switch;
            }))), __metadata('design:paramtypes', [Switch, typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object])], MediaSwitch);
            /**
             * @name ionSwitch
             * @description
             * A switch technically is the same thing as an HTML checkbox input, except it looks different and is easier to use on a touch device. Ionic prefers to wrap the checkbox input with the <label> in order to make the entire toggle easy to tap or drag.
             *
             * Toggles can also have colors assigned to them, by adding the `toggle-assertive` attribute to assign the assertive color.
             *
             * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
             *
             * @usage
             * ```html
             * // Create a single switch
             *  <ion-switch checked="true">
             *    Pineapple
             *  </ion-switch>
             *
             * // Create a list of switches:
             *  <ion-list>
             *
             *    <ion-switch checked="true">
             *      Apple
             *    </ion-switch>
             *
             *     <ion-switch checked="false">
             *       Banana
             *     </ion-switch>
             *
             *     <ion-switch disabled="true">
             *       Cherry
             *     </ion-switch>
             *
             *  </ion-list>
             * ```
             *
             */

            Switch = (function (_Ion) {
                _inherits(Switch, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {NgControl=} ngControl  TODO
                 */

                function Switch(elementRef, config, ngControl) {
                    _classCallCheck(this, Switch);

                    _get(Object.getPrototypeOf(Switch.prototype), "constructor", this).call(this, elementRef, config);
                    this.ngControl = ngControl;
                    var self = this;
                    self.id = IonInput.nextId();
                    self.tabIndex = 0;
                    self.lastTouch = 0;
                    self.onChange = function (_) {};
                    self.onTouched = function (_) {};
                    if (ngControl) ngControl.valueAccessor = this;
                    function pointerMove(ev) {
                        var currentX = pointerCoord(ev).x;
                        if (self.checked) {
                            if (currentX + 15 < self.startX) {
                                self.toggle();
                                self.startX = currentX;
                            }
                        } else if (currentX - 15 > self.startX) {
                            self.toggle();
                            self.startX = currentX;
                        }
                    }
                    function pointerOut(ev) {
                        if (ev.currentTarget === ev.target) {
                            self.pointerUp(ev);
                        }
                    }
                    this.addMoveListener = function () {
                        this.switchEle.addEventListener('touchmove', pointerMove);
                        this.switchEle.addEventListener('mousemove', pointerMove);
                        elementRef.nativeElement.addEventListener('mouseout', pointerOut);
                    };
                    this.removeMoveListener = function () {
                        this.switchEle.removeEventListener('touchmove', pointerMove);
                        this.switchEle.removeEventListener('mousemove', pointerMove);
                        elementRef.nativeElement.removeEventListener('mouseout', pointerOut);
                    };
                }

                _createClass(Switch, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Switch.prototype), "onInit", this).call(this);
                        this.labelId = 'label-' + this.id;
                    }

                    /**
                     * Set checked state of this switch.
                     * @param {boolean} value  Boolean to set this switch's checked state to.
                     */
                }, {
                    key: "check",
                    value: function check(value) {
                        this.checked = !!value;
                        this.onChange(this.checked);
                    }

                    /**
                     * Toggle the checked state of this switch.
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.check(!this.checked);
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.toggle();
                    }
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.checked = value;
                    }
                }, {
                    key: "pointerDown",
                    value: function pointerDown(ev) {
                        if (/touch/.test(ev.type)) {
                            this.lastTouch = Date.now();
                        }
                        if (this.lastTouch + 999 > Date.now() && /mouse/.test(ev.type)) {
                            return;
                        }
                        this.startX = pointerCoord(ev).x;
                        this.removeMoveListener();
                        this.addMoveListener();
                        this.isActivated = true;
                    }
                }, {
                    key: "pointerUp",
                    value: function pointerUp(ev) {
                        if (this.lastTouch + 999 > Date.now() && /mouse/.test(ev.type)) {
                            return;
                        }
                        var endX = pointerCoord(ev).x;
                        if (this.checked) {
                            if (this.startX + 4 > endX) {
                                this.toggle();
                            }
                        } else if (this.startX - 4 < endX) {
                            this.toggle();
                        }
                        this.removeMoveListener();
                        this.isActivated = false;
                    }

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.removeMoveListener();
                        this.switchEle = this.addMoveListener = this.removeMoveListener = null;
                    }
                }]);

                return Switch;
            })(Ion);

            _export("Switch", Switch);

            _export("Switch", Switch = __decorate([IonicComponent({
                selector: 'ion-switch',
                properties: ['value', 'checked', 'disabled', 'id'],
                host: {
                    'class': 'item',
                    'role': 'checkbox',
                    '[attr.tab-index]': 'tabIndex',
                    '[attr.aria-checked]': 'checked',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'labelId',
                    '(touchend)': 'pointerUp($event)',
                    '(mouseup)': 'pointerUp($event)'
                }
            }), IonicView({
                template: '<ng-content select="[item-left]"></ng-content>' + '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>' + '<div item-right class="media-switch">' + '<div class="switch-icon"></div>' + '</div>',
                directives: [MediaSwitch]
            }), __param(2, Optional()), __metadata('design:paramtypes', [typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _c || Object, typeof (_d = typeof NgControl !== 'undefined' && NgControl) === 'function' && _d || Object])], Switch));
        }
    };
});
System.register("ionic/components/tabs/tab", ["angular2/angular2", "../nav/nav-controller", "../nav/view-controller", "./tabs"], function (_export) {
    /**
     * @name ionTab
     * @requires ionTabs
     * @description
     * Contains a tab's content. The content only exists while the given tab is selected.
     *
     * @usage
     * ```html
     * <ion-tab tab-title="Heart" tab-icon="ion-ios-heart-outline" [root]="root1"></ion-tab>
     * ```
     */
    "use strict";

    var Directive, Component, View, Host, ElementRef, forwardRef, Injector, NgZone, NavController, ViewController, Tabs, __decorate, __metadata, __param, Tab, TabPaneAnchor, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Host = _angular2Angular2.Host;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            NgZone = _angular2Angular2.NgZone;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_tabs) {
            Tabs = _tabs.Tabs;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tab = (function (_NavController) {
                _inherits(Tab, _NavController);

                /**
                 * TODO
                 * @param {Tabs} tabs  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {Injector} injector  TODO
                 * @param {NgZone} zone  TODO
                 */

                function Tab(tabs, elementRef, injector, zone) {
                    var _this = this;

                    _classCallCheck(this, Tab);

                    // A Tab is both a container of many views, and is a view itself.
                    // A Tab is one ViewController within it's Host Tabs (which extends NavController)
                    // A Tab is a NavController for its child ViewControllers
                    _get(Object.getPrototypeOf(Tab.prototype), "constructor", this).call(this, tabs, injector, elementRef, zone);
                    this.tabs = tabs;
                    this.childNavbar(true);
                    var viewCtrl = this.viewCtrl = new ViewController(tabs.Host);
                    viewCtrl.setInstance(this);
                    viewCtrl.viewElementRef(elementRef);
                    tabs.addTab(this);
                    this.navbarView = viewCtrl.navbarView = function () {
                        var activeView = _this.getActive();
                        return activeView && activeView.navbarView();
                    };
                    viewCtrl.enableBack = function () {
                        // override ViewController's enableBack(), should use the
                        // active child nav item's enableBack() instead
                        var activeView = _this.getActive();
                        return activeView && activeView.enableBack();
                    };
                    this.panelId = 'tab-panel-' + viewCtrl.id;
                    this.labeledBy = 'tab-button-' + viewCtrl.id;
                }

                _createClass(Tab, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        if (this._initialResolve) {
                            this.tabs.select(this).then(function () {
                                _this2._initialResolve();
                                _this2._initialResolve = null;
                            });
                        }
                    }

                    /**
                     * TODO
                     * @param {Function} callback  TODO
                     */
                }, {
                    key: "load",
                    value: function load(callback) {
                        if (!this._loaded && this.root) {
                            var opts = {
                                animate: false,
                                navbar: false
                            };
                            this.push(this.root, null, opts).then(function () {
                                callback && callback();
                            });
                            this._loaded = true;
                        } else {
                            callback && callback();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "queueInitial",
                    value: function queueInitial() {
                        var _this3 = this;

                        // this Tab will be used as the initial one for the first load of Tabs
                        return new Promise(function (res) {
                            _this3._initialResolve = res;
                        });
                    }
                }, {
                    key: "isSelected",
                    get: function get() {
                        return this.tabs.isActive(this.viewCtrl);
                    }
                }, {
                    key: "isNotSelected",
                    get: function get() {
                        return !this.tabs.isActive(this.viewCtrl);
                    }
                }]);

                return Tab;
            })(NavController);

            _export("Tab", Tab);

            _export("Tab", Tab = __decorate([Component({
                selector: 'ion-tab',
                properties: ['root', 'tabTitle', 'tabIcon'],
                host: {
                    '[attr.id]': 'panelId',
                    '[attr.aria-labelledby]': 'labeledBy',
                    '[attr.aria-hidden]': 'isNotSelected',
                    '[class.tab-selected]': 'isSelected',
                    'role': 'tabpanel'
                }
            }), View({
                template: '<template pane-anchor></template><ng-content></ng-content>',
                directives: [forwardRef(function () {
                    return TabPaneAnchor;
                })]
            }), __param(0, Host()), __metadata('design:paramtypes', [typeof (_a = typeof Tabs !== 'undefined' && Tabs) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Injector !== 'undefined' && Injector) === 'function' && _c || Object, typeof (_d = typeof NgZone !== 'undefined' && NgZone) === 'function' && _d || Object])], Tab));
            /**
             * TODO
             */

            TabPaneAnchor =
            /**
            * TODO
            * @param {Tab} tab  TODO
            * @param {ElementRef} elementRef  TODO
            */
            function TabPaneAnchor(tab, elementRef) {
                _classCallCheck(this, TabPaneAnchor);

                tab.anchorElementRef(elementRef);
            };

            TabPaneAnchor = __decorate([Directive({
                selector: 'template[pane-anchor]'
            }), __param(0, Host()), __metadata('design:paramtypes', [Tab, typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object])], TabPaneAnchor);
        }
    };
});
System.register("ionic/components/tabs/tabs", ["angular2/angular2", "../app/app", "../nav/nav-controller", "../nav/view-controller", "../../config/decorators", "../../config/config"], function (_export) {
    /**
     * @name ionTabs
     * @description
     * Powers a multi-tabbed interface with a Tab Bar and a set of "pages"
     * that can be tabbed through.
     *
     * Assign any tabs attribute to the element to define its look and feel.
     *
     * For iOS, tabs will appear at the bottom of the screen. For Android, tabs
     * will be at the top of the screen, below the nav-bar. This follows each platform's
     * design specification, but can be configured with IonicConfig.
     *
     * See the ionTab component's documentation for more details on individual tabs.
     *
     * @usage
     * ```html
     * <ion-tabs>
     *   <ion-tab tab-title="Heart" tab-icon="ion-ios-heart-outline" [root]="root1"></ion-tab>
     *   <ion-tab tab-title="Star" tab-icon="ion-ios-star-outline" [root]="root2"></ion-tab>
     *   <ion-tab tab-title="Stopwatch" tab-icon="ion-ios-stopwatch-outline" [root]="root3"></ion-tab>
     * </ion-tabs>
     * ```
     *
     */
    "use strict";

    var Directive, Injector, ElementRef, Optional, Host, forwardRef, NgZone, IonicApp, NavController, ViewController, IonicComponent, IonicView, IonicConfig, __decorate, __metadata, __param, Tabs, TabButton, _a, _b, _c, _d, _e, _f, _g, _h;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Injector = _angular2Angular2.Injector;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Host = _angular2Angular2.Host;
            forwardRef = _angular2Angular2.forwardRef;
            NgZone = _angular2Angular2.NgZone;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_configDecorators) {
            IonicComponent = _configDecorators.IonicComponent;
            IonicView = _configDecorators.IonicView;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tabs = (function (_NavController) {
                _inherits(Tabs, _NavController);

                /**
                 * TODO
                 */

                function Tabs(hostNavCtrl, viewCtrl, app, injector, elementRef, zone) {
                    var _this = this;

                    _classCallCheck(this, Tabs);

                    _get(Object.getPrototypeOf(Tabs.prototype), "constructor", this).call(this, hostNavCtrl, injector, elementRef, zone);
                    this.app = app;
                    // Tabs may also be an actual ViewController which was navigated to
                    // if Tabs is static and not navigated to within a NavController
                    // then skip this and don't treat it as it's own ViewController
                    if (viewCtrl) {
                        this.viewCtrl = viewCtrl;
                        // special overrides for the Tabs ViewController
                        // the Tabs ViewController does not have it's own navbar
                        // so find the navbar it should use within it's active Tab
                        viewCtrl.navbarView = function () {
                            var activeTab = _this.getActive();
                            if (activeTab && activeTab.instance) {
                                return activeTab.instance.navbarView();
                            }
                        };
                        // a Tabs ViewController should not have a back button
                        // enableBack back button will later be determined
                        // by the active ViewController that has a navbar
                        viewCtrl.enableBack = function () {
                            return false;
                        };
                    }
                }

                /**
                 * TODO
                 * @param {Tab} tab  TODO
                 */

                _createClass(Tabs, [{
                    key: "addTab",
                    value: function addTab(tab) {
                        // tab.viewCtrl refers to the ViewController of the individual Tab being added to Tabs (NavController)
                        // this.viewCtrl refers to the ViewController instsance on Tabs
                        this.add(tab.viewCtrl);
                        if (this.length() === 1) {
                            // this was the first tab added, queue this one to be loaded and selected
                            var promise = tab.queueInitial();
                            this.viewCtrl && this.viewCtrl.addPromise(promise);
                        }
                    }

                    /**
                     * TODO
                     * @param {Tab} tab  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "select",
                    value: function select(tab) {
                        var _this2 = this;

                        var enteringView = null;
                        if (typeof tab === 'number') {
                            enteringView = this.getByIndex(tab);
                        } else {
                            enteringView = this.getByInstance(tab);
                        }
                        if (!enteringView || !enteringView.instance || !this.app.isEnabled()) {
                            return Promise.reject();
                        }
                        return new Promise(function (resolve) {
                            enteringView.instance.load(function () {
                                var opts = {
                                    animate: false
                                };
                                var leavingView = _this2.getActive() || new ViewController();
                                leavingView.shouldDestroy = false;
                                leavingView.shouldCache = true;
                                _this2.transition(enteringView, leavingView, opts, function () {
                                    resolve();
                                });
                            });
                        });
                    }
                }, {
                    key: "tabs",
                    get: function get() {
                        return this.instances();
                    }
                }]);

                return Tabs;
            })(NavController);

            _export("Tabs", Tabs);

            _export("Tabs", Tabs = __decorate([IonicComponent({
                selector: 'ion-tabs',
                defaultProperties: {
                    'tabBarPlacement': 'bottom',
                    'tabBarIcons': 'top'
                }
            }), IonicView({
                template: '' + '<nav class="tab-bar-container">' + '<div class="tab-bar" role="tablist">' + '<a *ng-for="#t of tabs" [tab]="t" class="tab-button" role="tab">' + '<icon [name]="t.tabIcon" [is-active]="t.isSelected" class="tab-button-icon"></icon>' + '<span class="tab-button-text">{{t.tabTitle}}</span>' + '</a>' + '</div>' + '</nav>' + '<section class="content-container">' + '<ng-content></ng-content>' + '</section>',
                directives: [forwardRef(function () {
                    return TabButton;
                })]
            }), __param(0, Optional()), __param(1, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof ViewController !== 'undefined' && ViewController) === 'function' && _b || Object, typeof (_c = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _c || Object, typeof (_d = typeof Injector !== 'undefined' && Injector) === 'function' && _d || Object, typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object, typeof (_f = typeof NgZone !== 'undefined' && NgZone) === 'function' && _f || Object])], Tabs));
            /**
             * TODO
             */

            TabButton = (function () {
                function TabButton(tabs, config, elementRef) {
                    _classCallCheck(this, TabButton);

                    this.tabs = tabs;
                    if (config.setting('hoverCSS') === false) {
                        elementRef.nativeElement.classList.add('disable-hover');
                    }
                }

                _createClass(TabButton, [{
                    key: "onInit",
                    value: function onInit() {
                        var id = this.tab.viewCtrl.id;
                        this.btnId = 'tab-button-' + id;
                        this.panelId = 'tab-panel-' + id;
                        this.hasTitle = !!this.tab.tabTitle;
                        this.hasIcon = !!this.tab.tabIcon;
                        this.hasTitleOnly = this.hasTitle && !this.hasIcon;
                        this.hasIconOnly = this.hasIcon && !this.hasTitle;
                    }
                }, {
                    key: "onClick",
                    value: function onClick(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.tabs.select(this.tab);
                    }
                }]);

                return TabButton;
            })();

            TabButton = __decorate([Directive({
                selector: '.tab-button',
                properties: ['tab'],
                host: {
                    '[attr.id]': 'btnId',
                    '[attr.aria-controls]': 'panelId',
                    '[attr.aria-selected]': 'tab.isSelected',
                    '[class.has-title]': 'hasTitle',
                    '[class.has-icon]': 'hasIcon',
                    '[class.has-title-only]': 'hasTitleOnly',
                    '[class.icon-only]': 'hasIconOnly',
                    '(click)': 'onClick($event)'
                }
            }), __param(0, Host()), __metadata('design:paramtypes', [Tabs, typeof (_g = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _g || Object, typeof (_h = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _h || Object])], TabButton);
        }
    };
});
System.register('ionic/components/tap-click/activator', ['../../util/dom'], function (_export) {
    'use strict';

    var raf, Activator;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            raf = _utilDom.raf;
        }],
        execute: function () {
            Activator = (function () {
                function Activator(app, config) {
                    _classCallCheck(this, Activator);

                    this.app = app;
                    this.queue = [];
                    this.active = [];
                    this.clearStateTimeout = 180;
                    this.clearAttempt = 0;
                    this.activatedClass = config.setting('activatedClass') || 'activated';
                    this.x = 0;
                    this.y = 0;
                }

                _createClass(Activator, [{
                    key: 'downAction',
                    value: function downAction(targetEle, pointerX, pointerY, callback) {
                        var _this = this;

                        // the user just pressed down
                        // remember where they pressed
                        this.x = pointerX;
                        this.y = pointerY;
                        // queue to have this element activated
                        this.queue.push(targetEle);
                        raf(function () {
                            var targetEle = undefined;
                            for (var i = 0; i < _this.queue.length; i++) {
                                targetEle = _this.queue[i];
                                if (targetEle && targetEle.parentNode) {
                                    _this.active.push(targetEle);
                                    targetEle.classList.add(_this.activatedClass);
                                }
                            }
                            _this.queue = [];
                        });
                    }
                }, {
                    key: 'upAction',
                    value: function upAction() {
                        var _this2 = this;

                        // the user was pressing down, then just let up
                        setTimeout(function () {
                            _this2.clearState();
                        }, this.clearStateTimeout);
                    }
                }, {
                    key: 'clearState',
                    value: function clearState() {
                        // all states should return to normal
                        if ((!this.app.isEnabled() || this.app.isTransitioning()) && this.clearAttempt < 30) {
                            // the app is actively disabled, so don't bother deactivating anything.
                            // this makes it easier on the GPU so it doesn't have to redraw any
                            // buttons during a transition. This will retry in XX milliseconds.
                            ++this.clearAttempt;
                            this.upAction();
                        } else {
                            // not actively transitioning, good to deactivate any elements
                            this.deactivate();
                            this.clearAttempt = 0;
                        }
                    }
                }, {
                    key: 'deactivate',
                    value: function deactivate() {
                        // remove the active class from all active elements
                        for (var i = 0; i < this.active.length; i++) {
                            this.active[i].classList.remove(this.activatedClass);
                        }
                        this.queue = [];
                        this.active = [];
                    }
                }]);

                return Activator;
            })();

            _export('Activator', Activator);
        }
    };
});
System.register('ionic/components/tap-click/ripple', ['./activator', '../../util/dom', '../../animations/animation'], function (_export) {
    'use strict';

    var Activator, removeElement, raf, Animation, RippleActivator, NO_RIPPLE_TAGNAMES;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function isRippleElement(targetEle) {
        return targetEle && targetEle.parentNode && !NO_RIPPLE_TAGNAMES.test(targetEle.tagName);
    }
    return {
        setters: [function (_activator) {
            Activator = _activator.Activator;
        }, function (_utilDom) {
            removeElement = _utilDom.removeElement;
            raf = _utilDom.raf;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            RippleActivator = (function (_Activator) {
                _inherits(RippleActivator, _Activator);

                function RippleActivator(app, config) {
                    _classCallCheck(this, RippleActivator);

                    _get(Object.getPrototypeOf(RippleActivator.prototype), 'constructor', this).call(this, app, config);
                    this.ripples = {};
                }

                _createClass(RippleActivator, [{
                    key: 'downAction',
                    value: function downAction(targetEle, pointerX, pointerY) {
                        var _this = this;

                        _get(Object.getPrototypeOf(RippleActivator.prototype), 'downAction', this).call(this, targetEle, pointerX, pointerY);
                        if (!isRippleElement(targetEle)) return;
                        // create a new ripple element
                        var r = targetEle.getBoundingClientRect();
                        var x = Math.max(Math.abs(r.width - pointerX), pointerX) * 2;
                        var y = Math.max(Math.abs(r.height - pointerY), pointerY) * 2;
                        var size = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) - 10;
                        var rippleEle = document.createElement('md-ripple');
                        var eleStyle = rippleEle.style;
                        eleStyle.width = size + 'px';
                        eleStyle.height = size + 'px';
                        eleStyle.marginTop = -(size / 2) + 'px';
                        eleStyle.marginLeft = -(size / 2) + 'px';
                        eleStyle.left = pointerX - r.left + 'px';
                        eleStyle.top = pointerY - r.top + 'px';
                        targetEle.appendChild(rippleEle);
                        var ripple = this.ripples[Date.now()] = { ele: rippleEle };
                        // expand the circle from the users starting point
                        // start slow, and when they let up, then speed up the animation
                        ripple.expand = new Animation(rippleEle, { renderDelay: 0 });
                        ripple.expand.fromTo('scale', '0.001', '1').duration(300).playbackRate(0.35).onFinish(function () {
                            // finished expanding
                            ripple.expand && ripple.expand.dispose();
                            ripple.expand = null;
                            ripple.expanded = true;
                            _this.next();
                        }).play();
                        this.next();
                    }
                }, {
                    key: 'upAction',
                    value: function upAction() {
                        var _this2 = this;

                        this.deactivate();
                        var ripple = undefined;
                        for (var rippleId in this.ripples) {
                            ripple = this.ripples[rippleId];
                            if (!ripple.fade) {
                                // ripple has not been let up yet
                                // spped up the rate if the animation is still going
                                setTimeout(function () {
                                    ripple.expand && ripple.expand.playbackRate(1);
                                    ripple.fade = new Animation(ripple.ele);
                                    ripple.fade.fadeOut().duration(750).onFinish(function () {
                                        ripple.fade && ripple.fade.dispose();
                                        ripple.fade = null;
                                        ripple.faded = true;
                                        _this2.next();
                                    }).play();
                                }, 16);
                            }
                        }
                        this.next();
                    }
                }, {
                    key: 'next',
                    value: function next(forceComplete) {
                        var _this3 = this;

                        var ripple = undefined,
                            rippleEle = undefined;

                        var _loop = function (rippleId) {
                            ripple = _this3.ripples[rippleId];
                            if (ripple.expanded && ripple.faded && ripple.ele || forceComplete || parseInt(rippleId) + 5000 < Date.now()) {
                                // finished expanding and the user has lifted the pointer
                                raf(function () {
                                    _this3.remove(rippleId);
                                });
                            }
                        };

                        for (var rippleId in this.ripples) {
                            _loop(rippleId);
                        }
                    }
                }, {
                    key: 'clearState',
                    value: function clearState() {
                        this.deactivate();
                        this.next(true);
                    }
                }, {
                    key: 'remove',
                    value: function remove(rippleId) {
                        var ripple = this.ripples[rippleId];
                        if (ripple) {
                            ripple.expand && ripple.expand.dispose();
                            ripple.fade && ripple.fade.dispose();
                            removeElement(ripple.ele);
                            ripple.ele = ripple.expand = ripple.fade = null;
                            delete this.ripples[rippleId];
                        }
                    }
                }]);

                return RippleActivator;
            })(Activator);

            _export('RippleActivator', RippleActivator);

            NO_RIPPLE_TAGNAMES = /BACKDROP/;
        }
    };
});
System.register('ionic/components/tap-click/tap-click', ['../../util/dom', './activator', './ripple'], function (_export) {
    'use strict';

    var pointerCoord, hasPointerMoved, Activator, RippleActivator, TapClick;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
            hasPointerMoved = _utilDom.hasPointerMoved;
        }, function (_activator) {
            Activator = _activator.Activator;
        }, function (_ripple) {
            RippleActivator = _ripple.RippleActivator;
        }],
        execute: function () {
            TapClick = (function () {
                function TapClick(app, config, window, document) {
                    _classCallCheck(this, TapClick);

                    var self = this;
                    self.app = app;
                    self.config = config;
                    self.win = window;
                    self.doc = document;
                    self.pointerTolerance = 4;
                    self.lastTouch = 0;
                    self.disableClick = 0;
                    self.disableClickLimit = 2500;
                    self.tapPolyfill = config.setting('tapPolyfill') !== false;
                    if (config.setting('mdRipple')) {
                        self.activator = new RippleActivator(app, config);
                    } else {
                        self.activator = new Activator(app, config);
                    }
                    function bindDom(type, listener, useCapture) {
                        document.addEventListener(type, listener, useCapture);
                    }
                    bindDom('click', function (ev) {
                        self.click(ev);
                    }, true);
                    bindDom('touchstart', function (ev) {
                        self.lastTouch = Date.now();
                        self.pointerStart(ev);
                    });
                    bindDom('touchend', function (ev) {
                        self.lastTouch = Date.now();
                        self.touchEnd(ev);
                    });
                    bindDom('touchcancel', function (ev) {
                        self.lastTouch = Date.now();
                        self.pointerCancel(ev);
                    });
                    bindDom('mousedown', function (ev) {
                        self.mouseDown(ev);
                    }, true);
                    bindDom('mouseup', function (ev) {
                        self.mouseUp(ev);
                    }, true);
                    self.pointerMove = function (ev) {
                        var moveCoord = pointerCoord(ev);
                        if (hasPointerMoved(10, self.start, moveCoord)) {
                            self.pointerCancel(ev);
                        }
                    };
                    self.moveListeners = function (shouldAdd) {
                        document.removeEventListener('touchmove', self.pointerMove);
                        document.removeEventListener('mousemove', self.pointerMove);
                        if (shouldAdd) {
                            bindDom('touchmove', self.pointerMove);
                            bindDom('mousemove', self.pointerMove);
                        }
                    };
                }

                /**
                 * TODO
                 * @param {TODO} ev  TODO
                 */

                _createClass(TapClick, [{
                    key: 'touchEnd',
                    value: function touchEnd(ev) {
                        var self = this;
                        if (self.tapPolyfill && self.start && self.app.isEnabled()) {
                            var endCoord = pointerCoord(ev);
                            if (!hasPointerMoved(self.pointerTolerance, self.start, endCoord)) {
                                console.debug('create click');
                                self.disableClick = Date.now();
                                var clickEvent = self.doc.createEvent('MouseEvents');
                                clickEvent.initMouseEvent('click', true, true, self.win, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
                                clickEvent.isIonicTap = true;
                                ev.target.dispatchEvent(clickEvent);
                            }
                        }
                        self.pointerEnd(ev);
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseDown',
                    value: function mouseDown(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseDown prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else if (this.lastTouch + 999 < Date.now()) {
                            this.pointerStart(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseUp',
                    value: function mouseUp(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseUp prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        if (this.lastTouch + 999 < Date.now()) {
                            this.pointerEnd(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'pointerStart',
                    value: function pointerStart(ev) {
                        var targetEle = this.getActivatableTarget(ev.target);
                        if (targetEle) {
                            this.start = pointerCoord(ev);
                            this.activator.downAction(targetEle, this.start.x, this.start.y);
                            this.moveListeners(true);
                        } else {
                            this.start = null;
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerEnd',
                    value: function pointerEnd(ev) {
                        this.activator.upAction();
                        this.moveListeners(false);
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerCancel',
                    value: function pointerCancel(ev) {
                        console.debug('pointerCancel');
                        this.activator.clearState();
                        this.moveListeners(false);
                        this.disableClick = Date.now();
                    }
                }, {
                    key: 'isDisabledClick',
                    value: function isDisabledClick() {
                        return this.disableClick + this.disableClickLimit > Date.now();
                    }

                    /**
                     * Whether the supplied click event should be allowed or not.
                     * @param {MouseEvent} ev  The click event.
                     * @return {boolean} True if click event should be allowed, otherwise false.
                     */
                }, {
                    key: 'allowClick',
                    value: function allowClick(ev) {
                        if (!this.app.isEnabled()) {
                            return false;
                        }
                        if (!ev.isIonicTap) {
                            if (this.isDisabledClick()) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * TODO
                     * @param {MouseEvent} ev  TODO
                     */
                }, {
                    key: 'click',
                    value: function click(ev) {
                        if (!this.allowClick(ev)) {
                            console.debug('click prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    }
                }, {
                    key: 'getActivatableTarget',
                    value: function getActivatableTarget(ele) {
                        var targetEle = ele;
                        for (var x = 0; x < 4; x++) {
                            if (!targetEle) break;
                            if (this.isActivatable(targetEle)) return targetEle;
                            targetEle = targetEle.parentElement;
                        }
                        return null;
                    }
                }, {
                    key: 'isActivatable',
                    value: function isActivatable(ele) {
                        if (/^(A|BUTTON)$/.test(ele.tagName)) {
                            return true;
                        }
                        var attributes = ele.attributes;
                        for (var i = 0, l = attributes.length; i < l; i++) {
                            if (/click|tappable/.test(attributes[i].name)) {
                                return true;
                            }
                        }
                        return false;
                    }
                }]);

                return TapClick;
            })();

            _export('TapClick', TapClick);
        }
    };
});
System.register("ionic/components/text-input/label", ["angular2/angular2", "../../config/config", "../../util/dom"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, IonicConfig, pointerCoord, hasPointerMoved, __decorate, __metadata, Label, _a;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
            hasPointerMoved = _utilDom.hasPointerMoved;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Label = (function () {
                /**
                 * TODO
                 * @param {IonicConfig} config
                 */

                function Label(config) {
                    _classCallCheck(this, Label);

                    this.scrollAssist = config.setting('keyboardScrollAssist');
                }

                /**
                 * TODO
                 * @param {TODO} ev  TODO
                 */

                _createClass(Label, [{
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = pointerCoord(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (this.container) {
                            // get where the touchend/mouseup ended
                            var endCoord = pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            if (!hasPointerMoved(20, this.startCoord, endCoord)) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.container.focus();
                            }
                            this.startCoord = null;
                        }
                    }
                }]);

                return Label;
            })();

            _export("Label", Label);

            _export("Label", Label = __decorate([Directive({
                selector: 'ion-label',
                properties: ['id'],
                host: {
                    '[attr.id]': 'id',
                    'class': 'input-label',
                    '(touchstart)': 'pointerStart($event)',
                    '(touchend)': 'pointerEnd($event)',
                    '(mousedown)': 'pointerStart($event)',
                    '(mouseup)': 'pointerEnd($event)'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _a || Object])], Label));
        }
    };
});
System.register("ionic/components/text-input/text-input", ["angular2/angular2", "../../config/decorators", "../../config/config", "../form/input", "./label", "../ion", "../app/app", "../content/content", "../../util/dom", "../../platform/platform"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, Host, Optional, ElementRef, Attribute, Query, QueryList, NgZone, IonicDirective, IonicConfig, IonInput, Label, Ion, IonicApp, Content, dom, IonicPlatform, __decorate, __metadata, __param, TextInputElement, _TextInput, SCROLL_INTO_VIEW_DURATION, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            Attribute = _angular2Angular2.Attribute;
            Query = _angular2Angular2.Query;
            QueryList = _angular2Angular2.QueryList;
            NgZone = _angular2Angular2.NgZone;
        }, function (_configDecorators) {
            IonicDirective = _configDecorators.IonicDirective;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_formInput) {
            IonInput = _formInput.IonInput;
        }, function (_label) {
            Label = _label.Label;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_utilDom) {
            dom = _utilDom;
        }, function (_platformPlatform) {
            IonicPlatform = _platformPlatform.IonicPlatform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            TextInputElement = (function () {
                /**
                 * TODO
                 * @param {string} type  The value of the underlying element's type attribute.
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function TextInputElement(type, elementRef, config) {
                    _classCallCheck(this, TextInputElement);

                    this.type = type;
                    this.elementRef = elementRef;
                    this.tabIndex = this.tabIndex || '';
                }

                /**
                 * Focus the input.
                 */

                _createClass(TextInputElement, [{
                    key: "setFocus",
                    value: function setFocus() {
                        this.elementRef.nativeElement.focus();
                    }

                    /**
                     * Whether the input has focus or not.
                     * @returns {boolean}  true if the input has focus, otherwise false.
                     */
                }, {
                    key: "hasFocus",
                    get: function get() {
                        return dom.hasFocus(this.elementRef);
                    }

                    /**
                     * Whether the input has a value.
                     * @returns {boolean}  true if the input has a value, otherwise false.
                     */
                }, {
                    key: "hasValue",
                    get: function get() {
                        return this.elementRef.nativeElement.value !== '';
                    }
                }]);

                return TextInputElement;
            })();

            _export("TextInputElement", TextInputElement);

            _export("TextInputElement", TextInputElement = __decorate([Directive({
                selector: 'textarea,input[type=text],input[type=password],input[type=number],input[type=search],input[type=email],input[type=url],input[type=tel]',
                property: ['tabIndex'],
                host: {
                    '[tabIndex]': 'tabIndex',
                    '[attr.aria-labelledby]': 'labelledBy',
                    'class': 'text-input input'
                }
            }), __param(0, Attribute('type')), __metadata('design:paramtypes', [String, typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object])], TextInputElement));
            /**
             * TODO
             */

            _TextInput = (function (_Ion) {
                _inherits(TextInput, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {IonicApp} app  TODO
                 * @param {NgZone} ngZone  TODO
                 * @param {Content=} scrollView  The parent scroll view.
                 * @param {QueryList<TextInputElement>} inputQry  TODO
                 * @param {QueryList<Label>} labelQry  TODO
                 */

                function TextInput(elementRef, config, app, ngZone, platform, scrollView, inputQry, labelQry) {
                    _classCallCheck(this, TextInput);

                    _get(Object.getPrototypeOf(TextInput.prototype), "constructor", this).call(this, elementRef, config);
                    this.scrollView = scrollView;
                    this.scrollAssist = config.setting('keyboardScrollAssist');
                    this.id = IonInput.nextId();
                    IonInput.registerInput(this);
                    this.app = app;
                    this.zone = ngZone;
                    this.platform = platform;
                    this.inputQry = inputQry;
                    this.labelQry = labelQry;
                    this.keyboardHeight = this.config.setting('keyboardHeight');
                }

                /**
                 * TODO
                 */

                _createClass(TextInput, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(TextInput.prototype), "onInit", this).call(this);
                        var label = this.labelQry.first;
                        this.input = this.inputQry.first;
                        if (this.input) {
                            this.type = this.input.type;
                            this.input.tabIndex = -1;
                            if (label) {
                                label.id = label.id || 'label-' + this.id;
                                this.input.labelledBy = label.id;
                            }
                        }
                        var self = this;
                        self.scrollMove = function (ev) {
                            self.deregListeners();
                            if (self.inputHasFocus) {
                                self.tempFocusMove();
                            }
                        };
                    }

                    /**
                     * TODO
                     * @param {Event} ev  TODO
                     */
                }, {
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist && this.app.isEnabled()) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = dom.pointerCoord(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {Event} ev TODO
                     */
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        var _this = this;

                        if (!this.app.isEnabled()) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else if (this.scrollAssist && ev.type === 'touchend') {
                            // get where the touchend/mouseup ended
                            var endCoord = dom.pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            // and the input doesn't already have focus
                            if (!dom.hasPointerMoved(8, this.startCoord, endCoord) && !this.inputHasFocus) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.zone.runOutsideAngular(function () {
                                    _this.initFocus();
                                    // temporarily prevent mouseup's from focusing
                                    _this.preventMouse = true;
                                    clearTimeout(_this.mouseTimer);
                                    _this.mouseTimer = setTimeout(function () {
                                        _this.preventMouse = false;
                                    }, 500);
                                });
                            }
                        } else if (!this.preventMouse) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            this.zone.runOutsideAngular(function () {
                                _this.setFocus();
                            });
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                    //TODO inconsistent return value, sometimes undefined
                }, {
                    key: "initFocus",
                    value: function initFocus() {
                        var _this2 = this;

                        var scrollView = this.scrollView;
                        if (scrollView && this.scrollAssist) {
                            // this input is inside of a scroll view
                            // find out if text input should be manually scrolled into view
                            var ele = this.elementRef.nativeElement;
                            var scrollData = _TextInput.getScollData(ele.offsetTop, ele.offsetHeight, scrollView.getDimensions(), this.keyboardHeight, this.platform.height());
                            if (scrollData.noScroll) {
                                // the text input is in a safe position that doesn't require
                                // it to be scrolled into view, just set focus now
                                return this.setFocus();
                            }
                            // add padding to the bottom of the scroll view (if needed)
                            scrollView.addKeyboardPadding(scrollData.scrollPadding);
                            // manually scroll the text input to the top
                            // do not allow any clicks while it's scrolling
                            this.app.setEnabled(false, SCROLL_INTO_VIEW_DURATION);
                            this.app.setTransitioning(true, SCROLL_INTO_VIEW_DURATION);
                            // temporarily move the focus to the focus holder so the browser
                            // doesn't freak out while it's trying to get the input in place
                            // at this point the native text input still does not have focus
                            this.tempFocusMove();
                            // scroll the input into place
                            scrollView.scrollTo(0, scrollData.scrollTo, SCROLL_INTO_VIEW_DURATION, 6).then(function () {
                                // the scroll view is in the correct position now
                                // give the native text input focus
                                _this2.setFocus();
                                // all good, allow clicks again
                                _this2.app.setEnabled(true);
                                _this2.app.setTransitioning(false);
                            });
                        } else {
                            // not inside of a scroll view, just focus it
                            this.setFocus();
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} inputOffsetTop  TODO
                     * @param {TODO} inputOffsetHeight  TODO
                     * @param {TODO} scrollViewDimensions  TODO
                     * @param {TODO} keyboardHeight  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "deregListeners",

                    /**
                     * TODO
                     */
                    value: function deregListeners() {
                        this.deregScroll && this.deregScroll();
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "setFocus",
                    value: function setFocus() {
                        var _this3 = this;

                        this.zone.run(function () {
                            // set focus on the input element
                            _this3.input && _this3.input.setFocus();
                            // ensure the body hasn't scrolled down
                            document.body.scrollTop = 0;
                            IonInput.setAsLastInput(_this3);
                        });
                        if (this.scrollAssist && this.scrollView) {
                            setTimeout(function () {
                                _this3.deregListeners();
                                _this3.deregScroll = _this3.scrollView.addScrollEventListener(_this3.scrollMove);
                            }, 100);
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "tempFocusMove",
                    value: function tempFocusMove() {
                        var focusHolder = this.app.focusHolder();
                        focusHolder.setFocusHolder(this.type);
                    }
                }, {
                    key: "receivedFocus",

                    /**
                     * TODO
                     * @param {boolean} receivedFocus  TODO
                     */
                    value: function receivedFocus(_receivedFocus) {
                        if (_receivedFocus && !this.inputHasFocus) {
                            this.initFocus();
                        } else {
                            this.deregListeners();
                        }
                    }
                }, {
                    key: "inputHasFocus",
                    get: function get() {
                        return !!this.input && this.input.hasFocus;
                    }
                }, {
                    key: "inputHasValue",
                    get: function get() {
                        return !!this.input && this.input.hasValue;
                    }
                }, {
                    key: "activeTabIndex",
                    get: function get() {
                        this.input.tabIndex = this.inputHasFocus ? 1000 : -1;
                        return -1;
                    }
                }], [{
                    key: "getScollData",
                    value: function getScollData(inputOffsetTop, inputOffsetHeight, scrollViewDimensions, keyboardHeight, plaformHeight) {
                        // compute input's Y values relative to the body
                        var inputTop = inputOffsetTop + scrollViewDimensions.contentTop - scrollViewDimensions.scrollTop;
                        var inputBottom = inputTop + inputOffsetHeight;
                        // compute the safe area which is the viewable content area when the soft keyboard is up
                        var safeAreaTop = scrollViewDimensions.contentTop;
                        var safeAreaHeight = plaformHeight - keyboardHeight - safeAreaTop;
                        safeAreaHeight /= 2;
                        var safeAreaBottom = safeAreaTop + safeAreaHeight;
                        var inputTopWithinSafeArea = inputTop >= safeAreaTop && inputTop <= safeAreaBottom;
                        var inputTopAboveSafeArea = inputTop < safeAreaTop;
                        var inputTopBelowSafeArea = inputTop > safeAreaBottom;
                        var inputBottomWithinSafeArea = inputBottom >= safeAreaTop && inputBottom <= safeAreaBottom;
                        var inputBottomBelowSafeArea = inputBottom > safeAreaBottom;
                        /*
                        Text Input Scroll To Scenarios
                        ---------------------------------------
                        1) Input top within safe area, bottom within safe area
                        2) Input top within safe area, bottom below safe area, room to scroll
                        3) Input top above safe area, bottom within safe area, room to scroll
                        4) Input top below safe area, no room to scroll, input smaller than safe area
                        5) Input top within safe area, bottom below safe area, no room to scroll, input smaller than safe area
                        6) Input top within safe area, bottom below safe area, no room to scroll, input larger than safe area
                        7) Input top below safe area, no room to scroll, input larger than safe area
                        */
                        if (inputTopWithinSafeArea && inputBottomWithinSafeArea) {
                            // Input top within safe area, bottom within safe area
                            // no need to scroll to a position, it's good as-is
                            return { noScroll: true };
                        }
                        // looks like we'll have to do some auto-scrolling
                        var scrollData = {
                            scrollAmount: 0,
                            scrollTo: 0,
                            scrollPadding: 0
                        };
                        if (inputTopBelowSafeArea || inputBottomBelowSafeArea) {
                            // Input top and bottom below safe area
                            // auto scroll the input up so at least the top of it shows
                            if (safeAreaHeight > inputOffsetHeight) {
                                // safe area height is taller than the input height, so we
                                // can bring it up the input just enough to show the input bottom
                                scrollData.scrollAmount = safeAreaBottom - inputBottom;
                            } else {
                                // safe area height is smaller than the input height, so we can
                                // only scroll it up so the input top is at the top of the safe area
                                // however the input bottom will be below the safe area
                                scrollData.scrollAmount = safeAreaTop - inputTop;
                            }
                        } else if (inputTopAboveSafeArea) {
                            // Input top above safe area
                            // auto scroll the input down so at least the top of it shows
                            scrollData.scrollAmount = safeAreaTop - inputTop;
                        }
                        // figure out where it should scroll to for the best position to the input
                        scrollData.scrollTo = scrollViewDimensions.scrollTop - scrollData.scrollAmount;
                        if (scrollData.scrollAmount < 0) {
                            // when auto-scrolling up, there also needs to be enough
                            // content padding at the bottom of the scroll view
                            // manually add it if there isn't enough scrollable area
                            // figure out how many scrollable area is left to scroll up
                            var availablePadding = scrollViewDimensions.scrollHeight - scrollViewDimensions.scrollTop - scrollViewDimensions.contentHeight;
                            var paddingSpace = availablePadding + scrollData.scrollAmount;
                            if (paddingSpace < 0) {
                                // there's not enough scrollable area at the bottom, so manually add more
                                scrollData.scrollPadding = scrollViewDimensions.contentHeight - safeAreaHeight;
                            }
                        }
                        // if (!window.safeAreaEle) {
                        //   window.safeAreaEle = document.createElement('div');
                        //   window.safeAreaEle.style.position = 'absolute';
                        //   window.safeAreaEle.style.background = 'rgba(0, 128, 0, 0.3)';
                        //   window.safeAreaEle.style.padding = '10px';
                        //   window.safeAreaEle.style.textShadow = '2px 2px white';
                        //   window.safeAreaEle.style.left = '0px';
                        //   window.safeAreaEle.style.right = '0px';
                        //   window.safeAreaEle.style.pointerEvents = 'none';
                        //   document.body.appendChild(window.safeAreaEle);
                        // }
                        // window.safeAreaEle.style.top = safeAreaTop + 'px';
                        // window.safeAreaEle.style.height = safeAreaHeight + 'px';
                        // window.safeAreaEle.innerHTML = `
                        //   <div>scrollTo: ${scrollData.scrollTo}</div>
                        //   <div>scrollAmount: ${scrollData.scrollAmount}</div>
                        //   <div>scrollPadding: ${scrollData.scrollPadding}</div>
                        //   <div>scrollHeight: ${scrollViewDimensions.scrollHeight}</div>
                        //   <div>scrollTop: ${scrollViewDimensions.scrollTop}</div>
                        //   <div>contentHeight: ${scrollViewDimensions.contentHeight}</div>
                        // `;
                        return scrollData;
                    }
                }]);

                return TextInput;
            })(Ion);

            _export("TextInput", _TextInput);

            _TextInput = __decorate([IonicDirective({
                selector: 'ion-input',
                classId: 'item-input',
                properties: ['tabIndex'],
                host: {
                    '(focus)': 'receivedFocus(true)',
                    '(blur)': 'receivedFocus(false)',
                    '(touchstart)': 'pointerStart($event)',
                    '(touchend)': 'pointerEnd($event)',
                    '(mouseup)': 'pointerEnd($event)',
                    '[class.has-focus]': 'inputHasFocus',
                    '[class.has-value]': 'inputHasValue',
                    '[tabIndex]': 'activeTabIndex',
                    'class': 'item'
                }
            }), __param(5, Optional()), __param(5, Host()), __param(6, Query(TextInputElement)), __param(7, Query(Label)), __metadata('design:paramtypes', [typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, typeof (_d = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _d || Object, typeof (_e = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _e || Object, typeof (_f = typeof NgZone !== 'undefined' && NgZone) === 'function' && _f || Object, typeof (_g = typeof IonicPlatform !== 'undefined' && IonicPlatform) === 'function' && _g || Object, typeof (_h = typeof Content !== 'undefined' && Content) === 'function' && _h || Object, typeof (_j = typeof QueryList !== 'undefined' && QueryList) === 'function' && _j || Object, typeof (_k = typeof QueryList !== 'undefined' && QueryList) === 'function' && _k || Object])], _TextInput);
            SCROLL_INTO_VIEW_DURATION = 400;
        }
    };
});
System.register("ionic/components/toolbar/toolbar", ["angular2/angular2", "../ion", "../../config/config", "../../config/decorators", "../nav-bar/nav-bar"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Component, Directive, View, ElementRef, Optional, forwardRef, Inject, Ion, IonicConfig, IonicView, Navbar, __decorate, __metadata, __param, ToolbarBase, Toolbar, ToolbarTitle, ToolbarItem, _a, _b, _c, _d, _e, _f;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            forwardRef = _angular2Angular2.forwardRef;
            Inject = _angular2Angular2.Inject;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configDecorators) {
            IonicView = _configDecorators.IonicView;
        }, function (_navBarNavBar) {
            Navbar = _navBarNavBar.Navbar;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ToolbarBase = (function (_Ion) {
                _inherits(ToolbarBase, _Ion);

                function ToolbarBase(elementRef, config) {
                    _classCallCheck(this, ToolbarBase);

                    _get(Object.getPrototypeOf(ToolbarBase.prototype), "constructor", this).call(this, elementRef, config);
                    this.itemRefs = [];
                    this.titleRef = null;
                }

                /**
                 * TODO
                 */

                _createClass(ToolbarBase, [{
                    key: "setTitleCmp",
                    value: function setTitleCmp(titleCmp) {
                        this.titleCmp = titleCmp;
                    }
                }, {
                    key: "getTitleText",
                    value: function getTitleText() {
                        return this.titleCmp && this.titleCmp.getTitleText() || '';
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "getTitleRef",
                    value: function getTitleRef() {
                        return this.titleCmp && this.titleCmp.elementRef;
                    }

                    /**
                     * A toolbar items include the left and right side `ion-nav-items`,
                     * and every `menu-toggle`. It does not include the `ion-title`.
                     * @returns {TODO} Array of this toolbar's item ElementRefs.
                     */
                }, {
                    key: "getItemRefs",
                    value: function getItemRefs() {
                        return this.itemRefs;
                    }
                }, {
                    key: "addItemRef",
                    value: function addItemRef(itemElementRef) {
                        this.itemRefs.push(itemElementRef);
                    }
                }]);

                return ToolbarBase;
            })(Ion);

            _export("ToolbarBase", ToolbarBase);

            Toolbar = (function (_ToolbarBase) {
                _inherits(Toolbar, _ToolbarBase);

                function Toolbar(elementRef, config) {
                    _classCallCheck(this, Toolbar);

                    _get(Object.getPrototypeOf(Toolbar.prototype), "constructor", this).call(this, elementRef, config);
                }

                return Toolbar;
            })(ToolbarBase);

            _export("Toolbar", Toolbar);

            _export("Toolbar", Toolbar = __decorate([Component({
                selector: 'ion-toolbar',
                host: {
                    'class': 'toolbar'
                }
            }), IonicView({
                template: '<div class="toolbar-inner">' + '<ng-content select="[menu-toggle]"></ng-content>' + '<ng-content select="ion-title"></ng-content>' + '<ng-content select="ion-nav-items[primary]"></ng-content>' + '<ng-content select="ion-nav-items[secondary]"></ng-content>' + '</div>' + '<div class="toolbar-background"></div>'
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof IonicConfig !== 'undefined' && IonicConfig) === 'function' && _b || Object])], Toolbar));

            ToolbarTitle = (function (_Ion2) {
                _inherits(ToolbarTitle, _Ion2);

                function ToolbarTitle(elementRef, toolbar, navbar) {
                    _classCallCheck(this, ToolbarTitle);

                    _get(Object.getPrototypeOf(ToolbarTitle.prototype), "constructor", this).call(this, elementRef, null);
                    toolbar && toolbar.setTitleCmp(this);
                    navbar && navbar.setTitleCmp(this);
                }

                _createClass(ToolbarTitle, [{
                    key: "getTitleText",
                    value: function getTitleText() {
                        return this.getNativeElement().textContent;
                    }
                }]);

                return ToolbarTitle;
            })(Ion);

            _export("ToolbarTitle", ToolbarTitle);

            _export("ToolbarTitle", ToolbarTitle = __decorate([Component({
                selector: 'ion-title'
            }), View({
                template: '<div class="toolbar-title">' + '<ng-content></ng-content>' + '</div>'
            }), __param(1, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, Toolbar, typeof (_d = typeof Navbar !== 'undefined' && Navbar) === 'function' && _d || Object])], ToolbarTitle));

            ToolbarItem = (function (_Ion3) {
                _inherits(ToolbarItem, _Ion3);

                function ToolbarItem(elementRef, toolbar, navbar) {
                    _classCallCheck(this, ToolbarItem);

                    _get(Object.getPrototypeOf(ToolbarItem.prototype), "constructor", this).call(this, elementRef, null);
                    toolbar && toolbar.addItemRef(elementRef);
                    navbar && navbar.addItemRef(elementRef);
                }

                return ToolbarItem;
            })(Ion);

            _export("ToolbarItem", ToolbarItem);

            _export("ToolbarItem", ToolbarItem = __decorate([Directive({
                selector: 'ion-nav-items,[menu-toggle]'
            }), __param(1, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object, Toolbar, typeof (_f = typeof Navbar !== 'undefined' && Navbar) === 'function' && _f || Object])], ToolbarItem));
        }
    };
});
System.register('ionic/components/view/swipe-back', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, SwipeBackGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            SwipeBackGesture = (function (_SlideEdgeGesture) {
                _inherits(SwipeBackGesture, _SlideEdgeGesture);

                function SwipeBackGesture(element, opts, viewCtrl) {
                    if (opts === undefined) opts = {};

                    _classCallCheck(this, SwipeBackGesture);

                    _get(Object.getPrototypeOf(SwipeBackGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                    this.viewCtrl = viewCtrl;
                }

                _createClass(SwipeBackGesture, [{
                    key: 'onSlideStart',
                    value: function onSlideStart() {
                        this.viewCtrl.swipeBackStart();
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.viewCtrl.swipeBackProgress(slide.distance / slide.max);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        var shouldComplete = Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5;
                        // TODO: calculate a better playback rate depending on velocity and distance
                        this.viewCtrl.swipeBackEnd(shouldComplete, 1);
                    }
                }]);

                return SwipeBackGesture;
            })(SlideEdgeGesture);

            _export('SwipeBackGesture', SwipeBackGesture);
        }
    };
});
System.register('ionic/components/view/view-controller', ['angular2/angular2', 'angular2/src/core/compiler/dynamic_component_loader', 'angular2/src/core/compiler/view_manager', '../ion', '../../config/config', '../app/app', './view-item', '../nav/nav-controller', '../nav/pane', '../../transitions/transition', './swipe-back', 'ionic/util'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var Compiler, Injector, bind, DynamicComponentLoader, AppViewManager, Ion, IonicConfig, IonicApp, ViewItem, NavController, PaneController, Transition, SwipeBackGesture, util, ViewController, ACTIVE_STATE, CACHED_STATE, STAGED_ENTERING_STATE, STAGED_LEAVING_STATE, ctrlIds;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Compiler = _angular2Angular2.Compiler;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_angular2SrcCoreCompilerDynamic_component_loader) {
            DynamicComponentLoader = _angular2SrcCoreCompilerDynamic_component_loader.DynamicComponentLoader;
        }, function (_angular2SrcCoreCompilerView_manager) {
            AppViewManager = _angular2SrcCoreCompilerView_manager.AppViewManager;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_viewItem) {
            ViewItem = _viewItem.ViewItem;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_navPane) {
            PaneController = _navPane.PaneController;
        }, function (_transitionsTransition) {
            Transition = _transitionsTransition.Transition;
        }, function (_swipeBack) {
            SwipeBackGesture = _swipeBack.SwipeBackGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            ViewController = (function (_Ion) {
                _inherits(ViewController, _Ion);

                function ViewController(parentViewCtrl, injector, elementRef, zone) {
                    _classCallCheck(this, ViewController);

                    var config = injector.get(IonicConfig);
                    _get(Object.getPrototypeOf(ViewController.prototype), 'constructor', this).call(this, elementRef, config);
                    this.parent = parentViewCtrl;
                    this.compiler = injector.get(Compiler);
                    this.loader = injector.get(DynamicComponentLoader);
                    this.viewMngr = injector.get(AppViewManager);
                    this.app = injector.get(IonicApp);
                    this.config = config;
                    this.zone = zone;
                    this.items = [];
                    this.panes = new PaneController(this);
                    this._sbTrans = null;
                    this.sbEnabled = config.setting('swipeBackEnabled') || false;
                    this.sbThreshold = config.setting('swipeBackThreshold') || 40;
                    this.id = ++ctrlIds;
                    this._ids = -1;
                    this.zIndexes = -1;
                    // build a new injector for child ViewItems to use
                    this.bindings = Injector.resolve([bind(ViewController).toValue(this), bind(NavController).toValue(new NavController(this))]);
                }

                /**
                 * TODO
                 * @param {TODO} componentType  TODO
                 * @param {TODO} [params={}]  TODO
                 * @param {TODO} [opts={}]  TODO
                 * @returns {Promise} TODO
                 */

                _createClass(ViewController, [{
                    key: 'push',
                    value: function push(componentType) {
                        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        if (!componentType) {
                            return Promise.reject();
                        }
                        if (typeof componentType !== 'function') {
                            throw 'Loading component must be a component class, not "' + componentType.toString() + '"';
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // do not animate if this is the first in the stack
                        if (!this.items.length) {
                            opts.animation = 'none';
                        }
                        // default the direction to "forward"
                        opts.direction = opts.direction || 'forward';
                        // the active item is going to be the leaving one (if one exists)
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : true;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // create a new ViewItem
                        var enteringItem = new ViewItem(this, componentType, params);
                        // add the item to the stack
                        this.add(enteringItem);
                        if (this.router) {
                            // notify router of the state change
                            this.router.stateChange('push', enteringItem, params);
                        }
                        // start the transition
                        this.transition(enteringItem, leavingItem, opts, function () {
                            resolve();
                        });
                        return promise;
                    }

                    /**
                     * TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'pop',
                    value: function pop() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        if (!this.canGoBack()) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // default the direction to "back"
                        opts.direction = opts.direction || 'back';
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : false;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // the entering item is now the new last item
                        // Note: we might not have an entering item if this is the
                        // only item on the history stack.
                        var enteringItem = this.getPrevious(leavingItem);
                        if (enteringItem) {
                            if (this.router) {
                                // notify router of the state change
                                this.router.stateChange('pop', enteringItem);
                            }
                            // start the transition
                            this.transition(enteringItem, leavingItem, opts, function () {
                                // transition completed, destroy the leaving item
                                resolve();
                            });
                        } else {
                            this._transComplete();
                            resolve();
                        }
                        return promise;
                    }

                    /**
                     * Set the item stack to reflect the given component classes.
                     * @param {TODO} components  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'setItems',
                    value: function setItems(components) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (!components || !components.length) {
                            return Promise.resolve();
                        }
                        // if animate has not been set then default to false
                        opts.animate = opts.animate || false;
                        // ensure leaving items are not cached, and should be destroyed
                        opts.cacheLeavingItem = false;
                        // get the items to auto remove without having to do a transiton for each
                        // the last item (the currently active one) will do a normal transition out
                        if (this.items.length > 1) {
                            var autoRemoveItems = this.items.slice(0, this.items.length - 1);
                            for (var i = 0; i < autoRemoveItems.length; i++) {
                                autoRemoveItems[i].shouldDestroy = true;
                                autoRemoveItems[i].shouldCache = false;
                                autoRemoveItems[i].willUnload();
                            }
                        }
                        var componentObj = null;
                        var componentType = null;
                        var viewItem = null;
                        // create the ViewItems that go before the new active ViewItem in the stack
                        // but the previous views won't should render yet
                        if (components.length > 1) {
                            var newBeforeItems = components.slice(0, components.length - 1);
                            for (var j = 0; j < newBeforeItems.length; j++) {
                                componentObj = newBeforeItems[j];
                                if (componentObj) {
                                    // could be an object with a componentType property, or it is a componentType
                                    componentType = componentObj.componentType || componentObj;
                                    viewItem = new ViewItem(this, componentType, componentObj.params);
                                    viewItem.state = CACHED_STATE;
                                    viewItem.shouldDestroy = false;
                                    viewItem.shouldCache = false;
                                    // add the item to the stack
                                    this.add(viewItem);
                                }
                            }
                        }
                        // get the component that will become the active item
                        // it'll be the last one in the given components array
                        componentObj = components[components.length - 1];
                        componentType = componentObj.componentType || componentObj;
                        // transition the leaving and entering
                        return this.push(componentType, componentObj.params, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} componentType  TODO
                     * @param {TODO} [params={}]  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'setRoot',
                    value: function setRoot(componentType) {
                        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return this.setItems([{
                            componentType: componentType,
                            params: params
                        }], opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} enteringItem  TODO
                     * @param {TODO} leavingItem  TODO
                     * @param {TODO} opts  TODO
                     * @param {Function} callback  TODO
                     * @returns {any} TODO
                     */
                }, {
                    key: 'transition',
                    value: function transition(enteringItem, leavingItem, opts, callback) {
                        var _this = this;

                        if (!enteringItem || enteringItem === leavingItem) {
                            return callback();
                        }
                        if (opts.animate === false) {
                            opts.animation = 'none';
                        } else if (!opts.animation) {
                            opts.animation = this.config.setting('viewTransition');
                        }
                        opts.animate = opts.animation !== 'none';
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            _this.zone.runOutsideAngular(function () {
                                enteringItem.shouldDestroy = false;
                                enteringItem.shouldCache = false;
                                enteringItem.willEnter();
                                leavingItem.willLeave();
                                // set that the new item pushed on the stack is staged to be entering/leaving
                                // staged state is important for the transition to find the correct item
                                enteringItem.state = STAGED_ENTERING_STATE;
                                leavingItem.state = STAGED_LEAVING_STATE;
                                // init the transition animation
                                var transAnimation = Transition.create(_this, opts);
                                if (!opts.animate) {
                                    // force it to not animate the elements, just apply the "to" styles
                                    transAnimation.duration(0);
                                }
                                var duration = transAnimation.duration();
                                if (duration > 64) {
                                    // block any clicks during the transition and provide a
                                    // fallback to remove the clickblock if something goes wrong
                                    _this.app.setEnabled(false, duration);
                                }
                                // start the transition
                                transAnimation.play().then(function () {
                                    // transition has completed, update each item's state
                                    enteringItem.state = ACTIVE_STATE;
                                    leavingItem.state = CACHED_STATE;
                                    // dispose any items that shouldn't stay around
                                    transAnimation.dispose();
                                    enteringItem.didEnter();
                                    leavingItem.didLeave();
                                    // all done!
                                    _this.zone.run(function () {
                                        _this._transComplete();
                                        callback();
                                    });
                                });
                            });
                        });
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'swipeBackStart',
                    value: function swipeBackStart() {
                        var _this2 = this;

                        if (!this.app.isEnabled() || !this.canSwipeBack()) {
                            return;
                        }
                        // disables the app during the transition
                        this.app.setEnabled(false);
                        // default the direction to "back"
                        var opts = {
                            direction: 'back'
                        };
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldDestroy = true;
                        leavingItem.shouldCache = false;
                        leavingItem.willLeave();
                        leavingItem.willUnload();
                        // the entering item is now the new last item
                        var enteringItem = this.getPrevious(leavingItem);
                        enteringItem.shouldDestroy = false;
                        enteringItem.shouldCache = false;
                        enteringItem.willEnter();
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            _this2.zone.runOutsideAngular(function () {
                                // set that the new item pushed on the stack is staged to be entering/leaving
                                // staged state is important for the transition to find the correct item
                                enteringItem.state = STAGED_ENTERING_STATE;
                                leavingItem.state = STAGED_LEAVING_STATE;
                                // init the swipe back transition animation
                                _this2._sbTrans = Transition.create(_this2, opts);
                                _this2._sbTrans.easing('linear').progressStart();
                            });
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} progress  TODO
                     */
                }, {
                    key: 'swipeBackProgress',
                    value: function swipeBackProgress(value) {
                        if (this._sbTrans) {
                            // continue to disable the app while actively dragging
                            this.app.setEnabled(false, 4000);
                            // set the transition animation's progress
                            this._sbTrans.progress(value);
                        }
                    }

                    /**
                     * @private
                     * @param {TODO} completeSwipeBack  Should the swipe back complete or not.
                     * @param {number} rate  How fast it closes
                     */
                }, {
                    key: 'swipeBackEnd',
                    value: function swipeBackEnd(completeSwipeBack, rate) {
                        var _this3 = this;

                        if (!this._sbTrans) return;
                        // disables the app during the transition
                        this.app.setEnabled(false);
                        this._sbTrans.progressEnd(completeSwipeBack, rate).then(function () {
                            _this3.zone.run(function () {
                                // find the items that were entering and leaving
                                var enteringItem = _this3.getStagedEnteringItem();
                                var leavingItem = _this3.getStagedLeavingItem();
                                if (enteringItem && leavingItem) {
                                    // finish up the animation
                                    if (completeSwipeBack) {
                                        // swipe back has completed navigating back
                                        // update each item's state
                                        enteringItem.state = ACTIVE_STATE;
                                        leavingItem.state = CACHED_STATE;
                                        enteringItem.didEnter();
                                        leavingItem.didLeave();
                                        if (_this3.router) {
                                            // notify router of the pop state change
                                            _this3.router.stateChange('pop', enteringItem);
                                        }
                                    } else {
                                        // cancelled the swipe back, they didn't end up going back
                                        // return items to their original state
                                        leavingItem.state = ACTIVE_STATE;
                                        enteringItem.state = CACHED_STATE;
                                        leavingItem.willEnter();
                                        leavingItem.didEnter();
                                        enteringItem.didLeave();
                                        leavingItem.shouldDestroy = false;
                                        enteringItem.shouldDestroy = false;
                                    }
                                }
                                // empty out and dispose the swipe back transition animation
                                _this3._sbTrans && _this3._sbTrans.dispose();
                                _this3._sbTrans = null;
                                // all done!
                                _this3._transComplete();
                            });
                        });
                    }
                }, {
                    key: '_runSwipeBack',
                    value: function _runSwipeBack() {
                        if (this.canSwipeBack()) {
                            // it is possible to swipe back
                            if (this.sbGesture) {
                                // this is already an active gesture, don't create another one
                                return;
                            }
                            var opts = {
                                edge: 'left',
                                threshold: this.sbThreshold
                            };
                            this.sbGesture = new SwipeBackGesture(this.getNativeElement(), opts, this);
                            console.debug('SwipeBackGesture listen');
                            this.sbGesture.listen();
                        } else if (this.sbGesture) {
                            // it is not possible to swipe back and there is an
                            // active sbGesture, so unlisten it
                            console.debug('SwipeBackGesture unlisten');
                            this.sbGesture.unlisten();
                            this.sbGesture = null;
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isSwipeBackEnabled',
                    value: function isSwipeBackEnabled(val) {
                        if (arguments.length) {
                            this.sbEnabled = !!val;
                        }
                        return this.sbEnabled;
                    }

                    /**
                     * If it's possible to use swipe back or not. If it's not possible
                     * to go back, or swipe back is not enable then this will return false.
                     * If it is possible to go back, and swipe back is enabled, then this
                     * will return true.
                     * @returns {boolean}
                     */
                }, {
                    key: 'canSwipeBack',
                    value: function canSwipeBack() {
                        return this.sbEnabled && this.canGoBack();
                    }

                    /**
                     * Returns `true` if there's a valid previous view that we can pop back to.
                     * Otherwise returns false.
                     * @returns {boolean}
                     */
                }, {
                    key: 'canGoBack',
                    value: function canGoBack() {
                        var activeItem = this.getActive();
                        if (activeItem) {
                            return activeItem.enableBack();
                        }
                        return false;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_transComplete',
                    value: function _transComplete() {
                        var _this4 = this;

                        var destroys = [];
                        this.items.forEach(function (item) {
                            if (item) {
                                if (item.shouldDestroy) {
                                    destroys.push(item);
                                } else if (item.state === CACHED_STATE && item.shouldCache) {
                                    item.shouldCache = false;
                                }
                            }
                        });
                        destroys.forEach(function (item) {
                            _this4.remove(item);
                            item.destroy();
                        });
                        // allow clicks again, but still set an enable time
                        // meaning nothing with this view controller can happen for XXms
                        this.app.setEnabled(true);
                        if (this.items.length === 1) {
                            this.elementRef.nativeElement.classList.add('has-views');
                        }
                        this._runSwipeBack();
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getActive',
                    value: function getActive() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === ACTIVE_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} instance  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getByInstance',
                    value: function getByInstance(instance) {
                        if (instance) {
                            for (var i = 0, ii = this.items.length; i < ii; i++) {
                                if (this.items[i].instance === instance) {
                                    return this.items[i];
                                }
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} index  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getByIndex',
                    value: function getByIndex(index) {
                        if (index < this.items.length && index > -1) {
                            return this.items[index];
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getPrevious',
                    value: function getPrevious(item) {
                        if (item) {
                            return this.items[this.items.indexOf(item) - 1];
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getStagedEnteringItem',
                    value: function getStagedEnteringItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_ENTERING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getStagedLeavingItem',
                    value: function getStagedLeavingItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_LEAVING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} nbContainer  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarViewContainer',
                    value: function navbarViewContainer(nbContainer) {
                        if (nbContainer) {
                            this._nbContainer = nbContainer;
                        }
                        if (this._nbContainer) {
                            return this._nbContainer;
                        }
                        if (this.parent) {
                            return this.parent.navbarViewContainer();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'anchorElementRef',
                    value: function anchorElementRef() {
                        if (arguments.length) {
                            this._anchorER = arguments[0];
                        }
                        return this._anchorER;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'anchorViewContainerRef',
                    value: function anchorViewContainerRef() {
                        if (arguments.length) {
                            this._anchorVC = arguments[0];
                        }
                        return this._anchorVC;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'childNavbar',
                    value: function childNavbar() {
                        if (arguments.length) {
                            this._childNavbar = arguments[0];
                        }
                        return this._childNavbar;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'add',
                    value: function add(item) {
                        item.id = this.id + '-' + ++this._ids;
                        this.items.push(item);
                    }

                    /**
                     * TODO
                     * @param {TODO} itemOrIndex  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'remove',
                    value: function remove(itemOrIndex) {
                        util.array.remove(this.items, itemOrIndex);
                    }

                    /**
                     * First view item in this view controller's stack. This would
                     * not return an item which is about to be destroyed.
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'first',
                    value: function first() {
                        for (var i = 0, l = this.items.length; i < l; i++) {
                            if (!this.items[i].shouldDestroy) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * Last view item in this view controller's stack. This would
                     * not return an item which is about to be destroyed.
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'last',
                    value: function last() {
                        for (var i = this.items.length - 1; i >= 0; i--) {
                            if (!this.items[i].shouldDestroy) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'indexOf',
                    value: function indexOf(item) {
                        return this.items.indexOf(item);
                    }

                    /**
                     * Number of sibling view items in the view controller. This does
                     * not include items which are about to be destroyed.
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'length',
                    value: function length() {
                        var len = 0;
                        for (var i = 0, l = this.items.length; i < l; i++) {
                            if (!this.items[i].shouldDestroy) {
                                len++;
                            }
                        }
                        return len;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'instances',
                    value: function instances() {
                        var instances = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var item = _step.value;

                                if (item.instance) {
                                    instances.push(item.instance);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return instances;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isActive',
                    value: function isActive(item) {
                        return item && item.state === ACTIVE_STATE;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isStagedEntering',
                    value: function isStagedEntering(item) {
                        return item && item.state === STAGED_ENTERING_STATE;
                    }

                    /**
                     * TODO
                     * @param {TODO} router  TODO
                     */
                }, {
                    key: 'registerRouter',
                    value: function registerRouter(router) {
                        this.router = router;
                    }
                }]);

                return ViewController;
            })(Ion);

            _export('ViewController', ViewController);

            ACTIVE_STATE = 1;
            CACHED_STATE = 2;
            STAGED_ENTERING_STATE = 3;
            STAGED_LEAVING_STATE = 4;
            ctrlIds = -1;
        }
    };
});
System.register('ionic/components/view/view-item', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../nav/nav-controller'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var Component, bind, Injector, ComponentRef, DirectiveBinding, NavParams, ViewItem;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function isComponent(elementBinder, id) {
        return elementBinder && elementBinder.componentDirective && elementBinder.componentDirective.metadata.id == id;
    }
    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            bind = _angular2Angular2.bind;
            Injector = _angular2Angular2.Injector;
            ComponentRef = _angular2Angular2.ComponentRef;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_navNavController) {
            NavParams = _navNavController.NavParams;
        }],
        execute: function () {
            ViewItem = (function () {
                function ViewItem(viewCtrl, componentType) {
                    var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                    _classCallCheck(this, ViewItem);

                    this.viewCtrl = viewCtrl;
                    this.componentType = componentType;
                    this.params = new NavParams(params);
                    this.instance = null;
                    this.state = 0;
                    this.disposals = [];
                    this.protos = {};
                    this._nbItms = [];
                    this._promises = [];
                    this.templateRefs = {};
                }

                /**
                 * TODO
                 * @param {TODO} name  TODO
                 * @param {TODO} protoViewRef  TODO
                 */

                _createClass(ViewItem, [{
                    key: 'addProtoViewRef',
                    value: function addProtoViewRef(name, protoViewRef) {
                        this.protos[name] = protoViewRef;
                    }

                    /**
                     * TODO
                     * @param {TODO} name  TODO
                     * @param {TODO} templateRef  TODO
                     */
                }, {
                    key: 'addTemplateRef',
                    value: function addTemplateRef(name, templateRef) {
                        this.templateRefs[name] = templateRef;
                    }

                    /**
                     * TODO
                     * @param {Function} callback  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'stage',
                    value: function stage(callback) {
                        var _this = this;

                        var viewCtrl = this.viewCtrl;
                        if (this.instance || !viewCtrl) {
                            // already compiled this view
                            return callback();
                        }
                        var annotation = new Component({
                            selector: 'ion-view',
                            host: {
                                'class': 'nav-item'
                            }
                        });
                        var ionViewComponentType = DirectiveBinding.createFromType(this.componentType, annotation);
                        // create a unique token that works as a cache key
                        ionViewComponentType.token = 'ionView' + this.componentType.name;
                        // compile the Component
                        viewCtrl.compiler.compileInHost(ionViewComponentType).then(function (hostProtoViewRef) {
                            // figure out the sturcture of this Component
                            // does it have a navbar? Is it tabs? Should it not have a navbar or any toolbars?
                            var itemStructure = _this.sturcture = _this.inspectStructure(hostProtoViewRef);
                            // get the appropriate Pane which this ViewItem will fit into
                            viewCtrl.panes.get(itemStructure, function (pane) {
                                _this.pane = pane;
                                var bindings = viewCtrl.bindings.concat(Injector.resolve([bind(NavParams).toValue(_this.params), bind(ViewItem).toValue(_this)]));
                                // add the content of the view to the content area
                                // it will already have the correct context
                                var contentContainer = pane.contentContainerRef;
                                // the same guts as DynamicComponentLoader.loadNextToLocation
                                var hostViewRef = contentContainer.createHostView(hostProtoViewRef, -1, bindings);
                                var newLocation = viewCtrl.viewMngr.getHostElement(hostViewRef);
                                var newComponent = viewCtrl.viewMngr.getComponent(newLocation);
                                pane.totalItems++;
                                var dispose = function dispose() {
                                    var index = contentContainer.indexOf(hostViewRef);
                                    if (index !== -1) {
                                        contentContainer.remove(index);
                                        // remove the pane if there are no view items left
                                        pane.totalItems--;
                                        if (pane.totalItems === 0) {
                                            pane.dispose();
                                        }
                                    }
                                };
                                _this.disposals.push(dispose);
                                var viewComponetRef = new ComponentRef(newLocation, newComponent, dispose);
                                // get the component's instance, and set it to the this ViewItem
                                _this.setInstance(viewComponetRef.instance);
                                _this.viewElementRef(viewComponetRef.location);
                                // // get the item container's nav bar
                                var navbarViewContainer = viewCtrl.navbarViewContainer();
                                // // get the item's navbar protoview
                                var navbarTemplateRef = _this.templateRefs.navbar;
                                // add a navbar view if the pane has a navbar container, and the
                                // item's instance has a navbar protoview to go to inside of it
                                if (navbarViewContainer && navbarTemplateRef) {
                                    (function () {
                                        var navbarView = navbarViewContainer.createEmbeddedView(navbarTemplateRef, -1);
                                        _this.disposals.push(function () {
                                            var index = navbarViewContainer.indexOf(navbarView);
                                            if (index > -1) {
                                                navbarViewContainer.remove(index);
                                            }
                                        });
                                    })();
                                }
                                // this item has finished loading
                                try {
                                    _this.loaded();
                                } catch (e) {
                                    console.error(e);
                                }
                                // fire callback when all child promises have been resolved
                                Promise.all(_this._promises).then(function () {
                                    callback();
                                    _this._promises = [];
                                });
                            }, function (panesErr) {
                                console.error(panesErr);
                            });
                        }, function (compileInHostErr) {
                            console.error(compileInHostErr);
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} childPromise  TODO
                     */
                }, {
                    key: 'addPromise',
                    value: function addPromise(childPromise) {
                        this._promises.push(childPromise);
                    }

                    /**
                     * TODO
                     * @param {TODO} componentProtoViewRef  TODO
                     */
                }, {
                    key: 'inspectStructure',
                    value: function inspectStructure(componentProtoViewRef) {
                        var navbar = false;
                        var key = '_';
                        componentProtoViewRef._protoView.elementBinders.forEach(function (rootElementBinder) {
                            if (!rootElementBinder.componentDirective || !rootElementBinder.nestedProtoView) return;
                            rootElementBinder.nestedProtoView.elementBinders.forEach(function (nestedElementBinder) {
                                if (isComponent(nestedElementBinder, 'Tabs')) {
                                    navbar = true;
                                }
                                if (!nestedElementBinder.componentDirective && nestedElementBinder.nestedProtoView) {
                                    nestedElementBinder.nestedProtoView.elementBinders.forEach(function (templatedElementBinder) {
                                        if (isComponent(templatedElementBinder, 'Navbar')) {
                                            navbar = true;
                                        }
                                    });
                                }
                            });
                        });
                        if (this.viewCtrl.childNavbar()) {
                            navbar = false;
                        }
                        if (navbar) key += 'n';
                        return {
                            navbar: navbar,
                            key: key
                        };
                    }

                    /**
                     * TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'enableBack',
                    value: function enableBack() {
                        // update if it's possible to go back from this nav item
                        if (this.viewCtrl) {
                            var previousItem = this.viewCtrl.getPrevious(this);
                            // the previous view may exist, but if it's about to be destroyed
                            // it shouldn't be able to go back to
                            return !!(previousItem && !previousItem.shouldDestroy);
                        }
                        return false;
                    }

                    /**
                     * TODO
                     * @param {TODO} instance  TODO
                     */
                }, {
                    key: 'setInstance',
                    value: function setInstance(instance) {
                        this.instance = instance;
                        this.instance._viewItem = this;
                    }
                }, {
                    key: 'isRoot',
                    value: function isRoot() {
                        return this.index === 0;
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        for (var i = 0; i < this.disposals.length; i++) {
                            this.disposals[i]();
                        }
                        this.didUnload();
                        // just to help prevent any possible memory leaks
                        for (var _name in this) {
                            if (this.hasOwnProperty(_name)) {
                                this[_name] = null;
                            }
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'viewElementRef',
                    value: function viewElementRef(val) {
                        if (arguments.length) {
                            this._vwEle = val;
                        }
                        return this._vwEle;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarView',
                    value: function navbarView() {
                        if (arguments.length) {
                            this._nbView = arguments[0];
                        }
                        return this._nbView;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarRef',
                    value: function navbarRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getElementRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'titleRef',
                    value: function titleRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getTitleRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarItemRefs',
                    value: function navbarItemRefs() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getItemRefs();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'backBtnRef',
                    value: function backBtnRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getBackButtonRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'backBtnTextRef',
                    value: function backBtnTextRef() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getBackButtonTextRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'postRender',
                    value: function postRender() {}
                    // the elements are in the DOM and the browser
                    // has rendered them in their correct locations

                    /**
                     * The view has loaded. This event only happens once per view being
                     * created. If a view leaves but is cached, then this will not
                     * fire again on a subsequent viewing. This method is a good place
                     * to put your setup code for the view; however, it is not the
                     * recommended method to use when a view becomes active.
                     */

                }, {
                    key: 'loaded',
                    value: function loaded() {
                        this.instance && this.instance.onViewLoaded && this.instance.onViewLoaded();
                    }

                    /**
                     * The view is about to enter and become the active view.
                     */
                }, {
                    key: 'willEnter',
                    value: function willEnter() {
                        this.instance && this.instance.onViewWillEnter && this.instance.onViewWillEnter();
                    }

                    /**
                     * The view has fully entered and is now the active view. This
                     * will fire, whether it was the first load or loaded from the cache.
                     */
                }, {
                    key: 'didEnter',
                    value: function didEnter() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.didEnter();
                        }
                        this.instance && this.instance.onViewDidEnter && this.instance.onViewDidEnter();
                    }

                    /**
                     * The view has is about to leave and no longer be the active view.
                     */
                }, {
                    key: 'willLeave',
                    value: function willLeave() {
                        this.instance && this.instance.onViewWillLeave && this.instance.onViewWillLeave();
                    }

                    /**
                     * The view has finished leaving and is no longer the active view. This
                     * will fire, whether it is cached or unloaded.
                     */
                }, {
                    key: 'didLeave',
                    value: function didLeave() {
                        this.instance && this.instance.onViewDidLeave && this.instance.onViewDidLeave();
                    }

                    /**
                     * The view is about to be destroyed and have its elements removed.
                     */
                }, {
                    key: 'willUnload',
                    value: function willUnload() {
                        this.instance && this.instance.onViewWillUnload && this.instance.onViewWillUnload();
                    }

                    /**
                     * The view has been destroyed and its elements have been removed.
                     */
                }, {
                    key: 'didUnload',
                    value: function didUnload() {
                        this.instance && this.instance.onViewDidUnload && this.instance.onViewDidUnload();
                    }
                }, {
                    key: 'index',
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.indexOf(this) : -1;
                    }
                }]);

                return ViewItem;
            })();

            _export('ViewItem', ViewItem);
        }
    };
});
System.register("ionic/platform/applinks/applinks", ["../plugin"], function (_export) {
    /**
     * Open installed apps on the device. Note: Android and iOS have different ways of
     * opening and specifying launch params, so they have separate launch functions.
     *
     * Example:
     *
     * if(platform.is('ios') {
     *   AppLinks.check('twitter://').then((installed) => {
     *     AppLinks.openIOS('twitter://user?screen_name=ionicframework')
     *   }, (err) => {
     *
     *   })
     * } else if(platform.is('android') {
     *   AppLinks.check('com.twitter.android').then((installed) => {
     *     AppLinks.openAndroid([["action", "VIEW"], ['twitter://user?screen_name=ionicframework']])
     *   })
     * }
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, AppLinks;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            AppLinks = (function () {
                function AppLinks() {
                    _classCallCheck(this, AppLinks);
                }

                _createClass(AppLinks, null, [{
                    key: "openIOS",

                    /**
                     * Open app on iOS with a given URL (iOS), or scheme (Android)
                     */
                    value: function openIOS(url) {
                        this.ifPlugin(function () {
                            navigator.startApp.start(url);
                        });
                    }

                    /**
                     * Open app on Android with a given scheme and params.
                     */
                }, {
                    key: "openAndroid",
                    value: function openAndroid(args) {
                        this.ifPlugin(function () {
                            var _navigator$startApp;

                            (_navigator$startApp = navigator.startApp).start.apply(_navigator$startApp, _toConsumableArray(args));
                        });
                    }

                    /**
                     * Check if an installed app can be opened from the given URL.
                     */
                }, {
                    key: "canOpen",
                    value: function canOpen(urlOrScheme) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            var hasPlugin = _this.ifPlugin(function () {
                                navigator.startApp.check(urlOrScheme, function (message) {
                                    resolve(message);
                                }, function (err) {
                                    reject(err);
                                });
                            });
                            if (!hasPlugin) {
                                reject('Plugin not installed');
                            }
                        });
                    }
                }]);

                return AppLinks;
            })();

            _export("AppLinks", AppLinks);

            _export("AppLinks", AppLinks = __decorate([NativePlugin({
                name: 'AppLinks',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-statusbar'
                },
                pluginCheck: function pluginCheck() {
                    return !!navigator.startApp;
                }
            }), __metadata('design:paramtypes', [])], AppLinks));
        }
    };
});
System.register("ionic/platform/barcode/barcode", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Barcode;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Barcode = (function () {
                function Barcode() {
                    _classCallCheck(this, Barcode);
                }

                _createClass(Barcode, null, [{
                    key: "scan",

                    /**
                     * Scan a barcode.
                     *
                     * @return Promise that resolves with an object of the format: {
                     *   text: text that was scanned,
                     *   format: format of barcode,
                     *   cancelled: was it canceled?
                     * }
                     */
                    value: function scan() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            var hasPlugin = _this.ifPlugin(function () {
                                window.cordova.plugins.barcodeScanner.scan(function (result) {
                                    resolve(result);
                                }, function (err) {
                                    reject(err);
                                });
                            });
                            if (!hasPlugin) {
                                reject('No scanner available');
                            }
                        });
                    }

                    /**
                     * Encode the given data in a barcode.
                     *
                     * @param type the type to use for encoding (if in doubt, use TYPE_TEXT).
                     * @param data the data to encode
                     * @return Promise
                     */
                }, {
                    key: "encode",
                    value: function encode(type, data) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            var hasPlugin = _this2.ifPlugin(function () {
                                window.cordova.plugins.barcodeScanner.encode(type, data, function (result) {
                                    resolve(result);
                                }, function (err) {
                                    reject(err);
                                });
                            });
                            if (!hasPlugin) {
                                reject('No scanner available');
                            }
                        });
                    }
                }]);

                return Barcode;
            })();

            _export("Barcode", Barcode);

            Barcode.TEXT_TYPE = "TEXT_TYPE";
            Barcode.EMAIL_TYPE = "EMAIL_TYPE";
            Barcode.PHONE_TYPE = "PHONE_TYPE";
            Barcode.SMS_TYPE = "SMS_TYPE";
            _export("Barcode", Barcode = __decorate([NativePlugin({
                name: 'Barcode',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'phonegap-plugin-barcodescanner'
                },
                pluginCheck: function pluginCheck() {
                    return window.cordova && window.cordova.plugins && window.cordova.plugins.barcodeScanner;
                }
            }), __metadata('design:paramtypes', [])], Barcode));
        }
    };
});
System.register("ionic/platform/battery/battery", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, _Battery;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _Battery = (function () {
                function Battery() {
                    _classCallCheck(this, Battery);
                }

                _createClass(Battery, null, [{
                    key: "getStatus",
                    value: function getStatus() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (navigator.getBattery) {
                                navigator.getBattery().then(function (battery) {
                                    _this.battery = battery;
                                    resolve(_Battery._format(battery));
                                });
                            } else {
                                var fnCb = function fnCb(battery) {
                                    resolve(battery);
                                    window.removeEventListener('batterystatus', fnCb);
                                };
                                window.addEventListener('batterystatus', fnCb);
                            }
                        });
                    }
                }, {
                    key: "_format",
                    value: function _format(batteryObj) {
                        if (typeof batteryObj.isPlugged !== 'undefined') {
                            // This is the old format, map it to the new format
                            util.extend(batteryObj, {
                                charging: batteryObj.isPlugged,
                                level: batteryObj.level / 100,
                                chargingTime: 0,
                                dischargingTime: 0 //not provided
                            });
                        }
                        return batteryObj;
                    }
                }]);

                return Battery;
            })();

            _export("Battery", _Battery);

            _Battery = __decorate([NativePlugin({
                name: 'Battery',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-battery-status'
                }
            }), __metadata('design:paramtypes', [])], _Battery);
        }
    };
});
System.register("ionic/platform/camera/camera", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, Camera;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Camera = (function () {
                function Camera() {
                    _classCallCheck(this, Camera);
                }

                _createClass(Camera, null, [{
                    key: "getPicture",
                    value: function getPicture(options) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.camera) {
                                _this.pluginWarn();
                                resolve(null);
                                return;
                            }
                            var options = util.defaults({
                                quality: 80,
                                destinationType: window.Camera.DestinationType.DATA_URL,
                                sourceType: window.Camera.PictureSourceType.CAMERA,
                                allowEdit: true,
                                encodingType: window.Camera.EncodingType.JPEG,
                                popoverOptions: window.CameraPopoverOptions,
                                saveToPhotoAlbum: false
                            }, options);
                            navigator.camera.getPicture(function (imageData) {
                                resolve(imageData);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "cleanup",
                    value: function cleanup() {
                        return new Promise(function (resolve, reject) {
                            navigator.camera.cleanup(function () {
                                resolve();
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Camera;
            })();

            _export("Camera", Camera);

            _export("Camera", Camera = __decorate([NativePlugin({
                name: 'Camera',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-camera'
                },
                pluginCheck: function pluginCheck() {
                    return !!navigator.camera;
                }
            }), __metadata('design:paramtypes', [])], Camera));
        }
    };
});
System.register("ionic/platform/camera-roll/camera-roll", ["../plugin"], function (_export) {
    /**
     * Save and load photos from the Camera Roll
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, CameraRoll;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            CameraRoll = (function () {
                function CameraRoll() {
                    _classCallCheck(this, CameraRoll);
                }

                _createClass(CameraRoll, null, [{
                    key: "save",

                    /**
                     * Save the base64 encoded image to the camera roll.
                     */
                    value: function save(base64String) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            _this.ifPlugin(function () {
                                window.CameraRoll.saveToCameraRoll(base64String, function () {
                                    resolve();
                                }, function (err) {
                                    reject(err);
                                });
                            });
                        });
                    }

                    /**
                     * Get photos from the camera roll
                     */
                }, {
                    key: "getPhotos",
                    value: function getPhotos(options) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            _this2.ifPlugin(function () {
                                window.CameraRoll.saveToCameraRoll(base64String);
                            });
                        });
                    }
                }]);

                return CameraRoll;
            })();

            _export("CameraRoll", CameraRoll);

            _export("CameraRoll", CameraRoll = __decorate([NativePlugin({
                name: 'CameraRoll',
                platforms: ['ios'],
                engines: {
                    cordova: 'cordova-plugin-camera-roll'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.CameraRoll;
                }
            }), __metadata('design:paramtypes', [])], CameraRoll));
        }
    };
});
System.register("ionic/platform/contacts/contacts", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Contacts;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Contacts = (function () {
                function Contacts() {
                    _classCallCheck(this, Contacts);
                }

                _createClass(Contacts, null, [{
                    key: "save",
                    value: function save(contact) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.save(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "remove",
                    value: function remove(contact) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this2.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.remove(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "clone",
                    value: function clone(contact) {
                        if (!navigator.contacts) {
                            this.pluginWarn();
                            return null;
                        }
                        var deviceContact = navigator.contacts.create(contact);
                        return deviceContact.clone(contact);
                    }
                }, {
                    key: "find",
                    value: function find(options) {
                        return new Promise(function (resolve, reject) {
                            var fields = options.fields || ['id', 'displayName'];
                            delete options.fields;
                            if (Object.keys(options).length === 0) {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                }, options);
                            }
                        });
                    }
                }, {
                    key: "pickContact",
                    value: function pickContact() {
                        return new Promise(function (resolve, reject) {
                            navigator.contacts.pickContact(function (contact) {
                                resolve(contact);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Contacts;
            })();

            _export("Contacts", Contacts);

            _export("Contacts", Contacts = __decorate([NativePlugin({
                name: 'Contacts',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-contacts'
                }
            }), __metadata('design:paramtypes', [])], Contacts));
        }
    };
});
System.register("ionic/platform/device/device", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, _Device;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _Device = (function () {
                function Device() {
                    _classCallCheck(this, Device);
                }

                _createClass(Device, null, [{
                    key: "getDevice",

                    /**
                     * Returns the whole device object.
                     * @see https://github.com/apache/cordova-plugin-device
                     * @returns {Object} The device object.
                     */
                    value: function getDevice() {
                        return this.ifPlugin(function () {
                            return device;
                        }, function () {
                            return {
                                name: _Device.getName(),
                                model: _Device.getModel(),
                                platform: _Device.getPlatform(),
                                uuid: _Device.getUUID(),
                                version: _Device.getVersion()
                            };
                        });
                    }

                    /**
                     * Returns the Cordova version.
                     * @see https://github.com/apache/cordova-plugin-device#devicecordova
                     * @returns {String} The Cordova version.
                     */
                }, {
                    key: "getCordova",
                    value: function getCordova() {
                        this.ifPlugin(function () {
                            return device.cordova;
                        });
                    }

                    /**
                     * Returns the name of the device's model or product.
                     * @see https://github.com/apache/cordova-plugin-device#devicemodel
                     * @returns {String} The name of the device's model or product.
                     */
                }, {
                    key: "getModel",
                    value: function getModel() {
                        this.ifPlugin(function () {
                            return device.model;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * @deprecated device.name is deprecated as of version 2.3.0. Use device.model instead.
                     * @returns {String}
                     */
                }, {
                    key: "getName",
                    value: function getName() {
                        this.ifPlugin(function () {
                            return device.name;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device's operating system name.
                     * @see https://github.com/apache/cordova-plugin-device#deviceplatform
                     * @returns {String} The device's operating system name.
                     */
                }, {
                    key: "getPlatform",
                    value: function getPlatform() {
                        this.ifPlugin(function () {
                            return device.name;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device's Universally Unique Identifier.
                     * @see https://github.com/apache/cordova-plugin-device#deviceuuid
                     * @returns {String} The device's Universally Unique Identifier
                     */
                }, {
                    key: "getUUID",
                    value: function getUUID() {
                        this.ifPlugin(function () {
                            return device.uuid;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the operating system version.
                     * @see https://github.com/apache/cordova-plugin-device#deviceversion
                     * @returns {String}
                     */
                }, {
                    key: "getVersion",
                    value: function getVersion() {
                        this.ifPlugin(function () {
                            return device.version;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device manufacturer.
                     * @returns {String}
                     */
                }, {
                    key: "getManufacturer",
                    value: function getManufacturer() {
                        this.ifPlugin(function () {
                            return device.manufacturer;
                        }, function () {
                            return 'unknown';
                        });
                    }
                }]);

                return Device;
            })();

            _export("Device", _Device);

            _Device = __decorate([NativePlugin({
                name: 'Device',
                plugins: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-device'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.device;
                }
            }), __metadata('design:paramtypes', [])], _Device);
        }
    };
});
System.register("ionic/platform/device-motion/device-motion", ["rx", "ionic/util", "../plugin"], function (_export) {
    "use strict";

    var Rx, util, NativePlugin, __decorate, __metadata, _DeviceMotion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceMotion = (function () {
                function DeviceMotion() {
                    _classCallCheck(this, DeviceMotion);
                }

                _createClass(DeviceMotion, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        // Mimic the DeviceMotionEvent
                        return util.extend({
                            acceleration: result,
                            accelerationIncludingGravity: result,
                            rotationRate: 0,
                            interval: 0,
                            native: true
                        }, result);
                    }
                }, {
                    key: "getCurrentAcceleration",
                    value: function getCurrentAcceleration() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                                var fnCb = function fnCb(eventData) {
                                    resolve(_DeviceMotion._wrap(eventData));
                                    window.removeEventListener('devicemotion', fnCb);
                                };
                                window.addEventListener('devicemotion', fnCb);
                            } else if (navigator.accelerometer) {
                                navigator.accelerometer.getCurrentAcceleration(function (result) {
                                    resolve(_DeviceMotion._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device motion events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchAcceleration",
                    value: function watchAcceleration(options) {
                        if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    observer.onNext(_DeviceMotion._wrap(eventData));
                                };
                                window.addEventListener('devicemotion', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('devicemotion', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.accelerometer.watchAcceleration(function (result) {
                                        observer.onNext(_DeviceMotion._wrap(result));
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.accelerometer.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceMotion;
            })();

            _export("DeviceMotion", _DeviceMotion);

            _DeviceMotion = __decorate([NativePlugin({
                name: 'Device Motion',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-device-motion'
                }
            }), __metadata('design:paramtypes', [])], _DeviceMotion);
        }
    };
});
System.register("ionic/platform/device-orientation/device-orientation", ["rx", "ionic/util", "../plugin"], function (_export) {
    "use strict";

    var Rx, util, NativePlugin, __decorate, __metadata, _DeviceOrientation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceOrientation = (function () {
                function DeviceOrientation() {
                    _classCallCheck(this, DeviceOrientation);
                }

                _createClass(DeviceOrientation, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        return util.extend({
                            alpha: result.magneticHeading,
                            magneticHeading: result.webkitCompassHeading || result.alpha
                        }, result);
                    }
                }, {
                    key: "getCurrentHeading",
                    value: function getCurrentHeading() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceOrientationEvent) {
                                var fnCb = function fnCb(eventData) {
                                    resolve(_DeviceOrientation._wrap(eventData));
                                    window.removeEventListener('deviceorientation', fnCb);
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            } else if (navigator.compass) {
                                navigator.compass.getCurrentHeading(function (result) {
                                    resolve(_DeviceOrientation._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device orientation events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchHeading",
                    value: function watchHeading(options) {
                        if (window.DeviceOrientationEvent) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    observer.onNext(_DeviceOrientation._wrap(eventData));
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('deviceorientation', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.compass.watchHeading(function (result) {
                                        observer.onNext(_DeviceOrientation._wrap(result));
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.compass.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceOrientation;
            })();

            _export("DeviceOrientation", _DeviceOrientation);

            _DeviceOrientation = __decorate([NativePlugin({
                name: 'Device Orientation',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-device-orientation'
                }
            }), __metadata('design:paramtypes', [])], _DeviceOrientation);
        }
    };
});
System.register("ionic/platform/dialogs/dialogs", ["../plugin"], function (_export) {
    /**
     * A native dialogs system. Native dialogs can give you a bit more
     * control over the UI than the browser built-ins, though the Dialogs
     * plugin will fall back to the built-ins when necessary.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, Dialogs;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Dialogs = (function () {
                function Dialogs() {
                    _classCallCheck(this, Dialogs);
                }

                _createClass(Dialogs, null, [{
                    key: "alert",

                    /**
                     * Trigger an alert prompt.
                     *
                     * @param message the message to show
                     * @param title the title to show
                     * @param buttonName the button label to use (not available on browser fallback)
                     * @return Promise
                     */
                    value: (function (_alert) {
                        function alert(_x, _x2, _x3) {
                            return _alert.apply(this, arguments);
                        }

                        alert.toString = function () {
                            return _alert.toString();
                        };

                        return alert;
                    })(function (message, title, buttonName) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this.pluginWarn();
                                alert(message);
                                resolve();
                            } else {
                                navigator.notification.alert(message, function () {
                                    resolve();
                                }, title, buttonName);
                            }
                        });
                    })

                    /**
                     * Trigger a confirm prompt.
                     *
                     * @param message the message to show
                     * @param title the title to show
                     * @param buttonLabels the button labels to use (not available on browser fallback)
                     * @return Promise that resolves with the index of the button selected (zero indexed). 1 is OK on browser fallback
                     */
                }, {
                    key: "confirm",
                    value: (function (_confirm) {
                        function confirm(_x4, _x5, _x6) {
                            return _confirm.apply(this, arguments);
                        }

                        confirm.toString = function () {
                            return _confirm.toString();
                        };

                        return confirm;
                    })(function (message, title, buttonLabels) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this2.pluginWarn();
                                var ok = confirm(message);
                                // Use 2 as OK
                                resolve(ok ? 2 : 0);
                            } else {
                                navigator.notification.confirm(message, function (buttonIndex) {
                                    resolve(buttonIndex - 1);
                                }, title, buttonLabels);
                            }
                        });
                    })
                }, {
                    key: "prompt",
                    value: (function (_prompt) {
                        function prompt(_x7, _x8, _x9, _x10) {
                            return _prompt.apply(this, arguments);
                        }

                        prompt.toString = function () {
                            return _prompt.toString();
                        };

                        return prompt;
                    })(function (message, title, buttonLabels, defaultText) {
                        var _this3 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this3.pluginWarn();
                                var response = prompt(message);
                                // Use 1 as OK
                                resolve(response);
                            } else {
                                navigator.notification.prompt(message, function (results) {
                                    resolve(results.input1, buttonIndex - 1);
                                }, title, buttonLabels, defaultText);
                            }
                        });
                    })

                    /**
                     * Beep n times. Not available on browser.
                     * @param times the number of times to beep
                     */
                }, {
                    key: "beep",
                    value: function beep(times) {
                        navigator.notification && navigator.notification.beep(times);
                    }
                }]);

                return Dialogs;
            })();

            _export("Dialogs", Dialogs);

            _export("Dialogs", Dialogs = __decorate([NativePlugin({
                name: 'Dialogs',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-dialogs'
                }
            }), __metadata('design:paramtypes', [])], Dialogs));
        }
    };
});
System.register("ionic/platform/geolocation/geolocation", ["rx", "../plugin"], function (_export) {
    "use strict";

    var Rx, NativePlugin, __decorate, __metadata, Geolocation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Geolocation = (function () {
                function Geolocation() {
                    _classCallCheck(this, Geolocation);
                }

                _createClass(Geolocation, null, [{
                    key: "getCurrentPosition",
                    value: function getCurrentPosition(options) {
                        return new Promise(function (resolve, reject) {
                            navigator.geolocation.getCurrentPosition(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "watchPosition",
                    value: function watchPosition(options) {
                        var watchID = undefined;
                        var source = Rx.Observable.create(function (observer) {
                            watchID = navigator.geolocation.watchPosition(function (result) {
                                observer.onNext(result);
                            }, function (err) {
                                observer.onError(err, observer);
                            }, options);
                        });
                        return {
                            source: source,
                            watchID: watchID,
                            clear: function clear() {
                                navigator.geolocation.clearWatch(watchID);
                            }
                        };
                    }
                }, {
                    key: "clearWatch",
                    value: function clearWatch(watchID) {
                        return navigator.geolocation.clearWatch(watchID);
                    }
                }]);

                return Geolocation;
            })();

            _export("Geolocation", Geolocation);

            _export("Geolocation", Geolocation = __decorate([NativePlugin({
                name: 'Geolocation',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-geolocation'
                }
            }), __metadata('design:paramtypes', [])], Geolocation));
        }
    };
});
System.register("ionic/platform/keyboard/keyboard", ["../plugin"], function (_export) {
    /**
     * Manage the native keyboard. Note: this plugin performs mainly in the native
     * app context. Most operations are non-functional in a normal web browser as
     * keyboard control is limited.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, Keyboard;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Keyboard = (function () {
                function Keyboard() {
                    _classCallCheck(this, Keyboard);
                }

                _createClass(Keyboard, null, [{
                    key: "setAccessoryBarVisible",

                    /**
                     * Set whether the accessory bar is visible.
                     *
                     * Note: this only works while running natively (accessory bar cannot be removed
                     * in most web browsers), and by default the bar is hidden when running natively.
                     *
                     * @param isVisible whether the accessory bar is visible
                     */
                    value: function setAccessoryBarVisible(isVisible) {
                        this.ifPlugin(function () {
                            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(!isVisible);
                        });
                    }

                    /**
                     * Close the keyboard.
                     */
                }, {
                    key: "close",
                    value: function close() {
                        this.ifPlugin(function () {
                            cordova.plugins.Keyboard.close();
                        });
                    }

                    /**
                     * Show the keyboard. Does nothing on iOS (has to be triggered from an input)
                     */
                }, {
                    key: "show",
                    value: function show() {
                        this.ifPlugin(function () {
                            cordova.plugins.Keyboard.show();
                        });
                    }

                    /**
                     * @return the visibility of the keyboard.
                     */
                }, {
                    key: "isVisible",
                    value: function isVisible() {
                        return this.ifPlugin(function () {
                            return cordova.plugins.Keyboard.isVisible;
                        });
                    }
                }]);

                return Keyboard;
            })();

            _export("Keyboard", Keyboard);

            _export("Keyboard", Keyboard = __decorate([NativePlugin({
                name: 'Keyboard',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'ionic-plugin-keyboard'
                },
                pluginCheck: function pluginCheck() {
                    return window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard;
                }
            }), __metadata('design:paramtypes', [])], Keyboard));
        }
    };
});
System.register("ionic/platform/loading/loading", ["../plugin"], function (_export) {
    /**
     * Simple loading popup indicators.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, Loading;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Loading = (function () {
                function Loading() {
                    _classCallCheck(this, Loading);
                }

                _createClass(Loading, null, [{
                    key: "simple",
                    value: function simple(dim, label, detail) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showSimple(dim);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showSimpleWithLabel(dim, label);
                                return;
                            }
                            window.ProgressIndicator.showSimpleWithLabelDetail(dim, label, detail);
                        });
                    }
                }, {
                    key: "determinate",
                    value: function determinate(dim, timeout, label) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showDeterminate(dim, timeout);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showSimpleWithLabel(dim, timeout, label);
                                return;
                            }
                        });
                    }
                }, {
                    key: "annular",
                    value: function annular(dim, timeout, label) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showAnnular(dim, timeout);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showAnnularWithLabel(dim, timeout, label);
                                return;
                            }
                        });
                    }
                }, {
                    key: "bar",
                    value: function bar(dim, timeout, label) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showBar(dim, timeout);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showBarWithLabel(dim, timeout, label);
                                return;
                            }
                        });
                    }
                }, {
                    key: "success",
                    value: function success(dim, label) {
                        this.ifPlugin(function () {
                            window.ProgressIndicator.showSuccess(dim, label);
                        });
                    }
                }, {
                    key: "hide",
                    value: function hide() {
                        this.ifPlugin(function () {
                            window.ProgressIndicator.hide();
                        });
                    }
                }]);

                return Loading;
            })();

            _export("Loading", Loading);

            _export("Loading", Loading = __decorate([NativePlugin({
                name: 'Loading',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-progressindicator'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.ProgressIndicator;
                }
            }), __metadata('design:paramtypes', [])], Loading));
        }
    };
});
System.register("ionic/platform/statusbar/statusbar", ["../plugin"], function (_export) {
    /**
     * Manage the appearance of the native status bar.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, _StatusBar;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _StatusBar = (function () {
                function StatusBar() {
                    _classCallCheck(this, StatusBar);
                }

                _createClass(StatusBar, null, [{
                    key: "show",

                    /**
                     * Show the StatusBar
                     */
                    value: function show() {
                        this.ifPlugin(function () {
                            window.StatusBar.show();
                        });
                    }

                    /**
                     * Hide the StatusBar
                     */
                }, {
                    key: "hide",
                    value: function hide() {
                        this.ifPlugin(function () {
                            window.StatusBar.hide();
                        });
                    }

                    /**
                     * Hide the StatusBar
                     *
                     * Options:
                     *
                     * StatusBar.DEFAULT
                     * StatusBar.LIGHT_CONTENT
                     * StatusBar.BLACK_TRANSLUCENT
                     * StatusBar.BLACK_OPAQUE
                     *
                     * @param style the style from above
                     */
                }, {
                    key: "setStyle",
                    value: function setStyle(style) {
                        this.ifPlugin(function () {
                            switch (style) {
                                case _StatusBar.DEFAULT:
                                    window.StatusBar.styleDefault();
                                    break;
                                case _StatusBar.LIGHT_CONTENT:
                                    window.StatusBar.styleLightContent();
                                    break;
                                case _StatusBar.BLACK_TRANSLUCENT:
                                    window.StatusBar.styleBlackTranslucent();
                                    break;
                                case _StatusBar.BLACK_OPAQUE:
                                    window.StatusBar.styleBlackOpaque();
                                    break;
                            }
                        });
                    }

                    /**
                     * Set the status bar to a specific hex color (CSS shorthand supported!).
                     *
                     * iOS note: you must call StatusBar.setOverlay(false) to enable color changing.
                     *
                     * @param hex the hex value of the color.
                     */
                }, {
                    key: "setHexColor",
                    value: function setHexColor(hex) {
                        this.ifPlugin(function () {
                            window.StatusBar.backgroundColorByHexName(hex);
                        });
                    }

                    /**
                     * Set the status bar to a specific named color. Valid options:
                     * black, darkGray, lightGray, white, gray, red, green, blue, cyan, yellow, magenta, orange, purple, brown.
                     *
                     * iOS note: you must call StatusBar.setOverlay(false) to enable color changing.
                     *
                     * @param name the name of the color (from above)
                     */
                }, {
                    key: "setNamedColor",
                    value: function setNamedColor(name) {
                        this.ifPlugin(function () {
                            window.StatusBar.backgroundColorByName(name);
                        });
                    }

                    /**
                     * Set whether the status bar overlays the main app view. The default
                     * is true.
                     *
                     * @param doesOverlay whether the status bar overlays the main app view.
                     */
                }, {
                    key: "setOverlays",
                    value: function setOverlays(doesOverlay) {
                        this.ifPlugin(function () {
                            window.StatusBar.overlaysWebView(doesOverlay);
                        });
                    }
                }]);

                return StatusBar;
            })();

            _export("StatusBar", _StatusBar);

            _StatusBar.DEFAULT = 0;
            _StatusBar.LIGHT_CONTENT = 1;
            _StatusBar.BLACK_TRANSLUCENT = 2;
            _StatusBar.BLACK_OPAQUE = 3;
            _StatusBar = __decorate([NativePlugin({
                name: 'StatusBar',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-statusbar'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.StatusBar;
                }
            }), __metadata('design:paramtypes', [])], _StatusBar);
        }
    };
});
System.register('ionic/platform/storage/local-storage', ['./storage'], function (_export) {
    /**
     * The LocalStorage storage engine uses the browser's local storage system for
     * storing key/value pairs.
     *
     * Note: LocalStorage should ONLY be used for temporary data that you can afford to lose.
     * Given disk space constraints on a mobile device, local storage might be "cleaned up"
     * by the operating system (iOS).
     *
     * For guaranteed, long-term storage, use the SqlStorage engine which stores data in a file.
     */
    'use strict';

    var StorageEngine, LocalStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }],
        execute: function () {
            LocalStorage = (function (_StorageEngine) {
                _inherits(LocalStorage, _StorageEngine);

                function LocalStorage() {
                    _classCallCheck(this, LocalStorage);

                    _get(Object.getPrototypeOf(LocalStorage.prototype), 'constructor', this).call(this);
                }

                _createClass(LocalStorage, [{
                    key: 'get',
                    value: function get(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                var value = window.localStorage.getItem(key);
                                resolve(value);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.setItem(key, value);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.removeItem(key);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return LocalStorage;
            })(StorageEngine);

            _export('LocalStorage', LocalStorage);
        }
    };
});
System.register('ionic/platform/storage/sql', ['./storage', 'ionic/util'], function (_export) {
    'use strict';

    var StorageEngine, util, DB_NAME, SqlStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            DB_NAME = '__ionicstorage';

            /**
             * SqlStorage uses SQLite or WebSQL (development only!) to store data in a
             * persistent SQL store on the filesystem.
             *
             * This is the preferred storage engine, as data will be stored in appropriate
             * app storage, unlike Local Storage which is treated differently by the OS.
             */

            SqlStorage = (function (_StorageEngine) {
                _inherits(SqlStorage, _StorageEngine);

                function SqlStorage(options) {
                    _classCallCheck(this, SqlStorage);

                    _get(Object.getPrototypeOf(SqlStorage.prototype), 'constructor', this).call(this);
                    var dbOptions = util.defaults({
                        name: DB_NAME,
                        backupFlag: SqlStorage.BACKUP_NONE,
                        existingDatabase: false
                    }, options);
                    if (window.sqlitePlugin) {
                        var _location = this._getBackupLocation(dbOptions);
                        this._db = window.sqlitePlugin.openDatabase(util.extend({
                            name: dbOptions.name,
                            location: _location,
                            createFromLocation: dbOptions.existingDatabase ? 1 : 0
                        }, dbOptions));
                    } else {
                        console.warn('Storage: SQLite plugin not installed, falling back to WebSQL. Make sure to install cordova-sqlite-storage in production!');
                        this._db = window.openDatabase(dbOptions.name, '1.0', 'database', 5 * 1024 * 1024);
                    }
                    this._tryInit();
                }

                _createClass(SqlStorage, [{
                    key: '_getBackupLocation',
                    value: function _getBackupLocation(dbFlag) {
                        switch (dbFlag) {
                            case SqlStorage.BACKUP_LOCAL:
                                return 2;
                            case SqlStorage.BACKUP_LIBRARY:
                                return 1;
                            case SqlStorage.BACKUP_DOCUMENTS:
                                return 0;
                            default:
                                throw Error('Invalid backup flag: ' + dbFlag);
                        }
                    }

                    // Initialize the DB with our required tables
                }, {
                    key: '_tryInit',
                    value: function _tryInit() {
                        this._db.transaction(function (tx) {
                            tx.executeSql('CREATE TABLE IF NOT EXISTS kv (key text primary key, value text)', [], function (tx, res) {}, function (tx, err) {
                                console.error('Storage: Unable to create initial storage tables', tx, err);
                            });
                        });
                    }

                    /**
                     * Perform an arbitrary SQL operation on the database. Use this method
                     * to have full control over the underlying database through SQL operations
                     * like SELECT, INSERT, and UPDATE.
                     *
                     * @param {string} query the query to run
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'query',
                    value: function query(_query) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            _this._db.transaction(function (tx) {
                                ts.executeSql(_query, [], function (tx, res) {
                                    resolve({
                                        tx: tx,
                                        res: res
                                    });
                                }, function (tx, err) {
                                    reject({
                                        tx: tx,
                                        err: err
                                    });
                                });
                            });
                        });
                    }

                    /**
                     * Get the value in the database identified by the given key.
                     * @param {string} key the key
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'get',
                    value: function get(key) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this2._db.transaction(function (tx) {
                                    tx.executeSql("select key, value from kv where key = ? limit 1", [key], function (tx, res) {
                                        if (res.rows.length > 0) {
                                            var item = res.rows.item(0);
                                            resolve(item.value);
                                        }
                                        resolve(null);
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Set the value in the database for the given key. Existing values will be overwritten.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        var _this3 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this3._db.transaction(function (tx) {
                                    tx.executeSql('insert or replace into kv(key, value) values (?, ?)', [key, value], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Remove the value in the database for the given key.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        var _this4 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this4._db.transaction(function (tx) {
                                    tx.executeSql('delete from kv where key = ?', [key], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return SqlStorage;
            })(StorageEngine);

            _export('SqlStorage', SqlStorage);

            SqlStorage.BACKUP_LOCAL = 2;
            SqlStorage.BACKUP_LIBRARY = 1;
            SqlStorage.BACKUP_DOCUMENTS = 0;
        }
    };
});
System.register('ionic/platform/storage/storage', [], function (_export) {
    /**
     * Storage is an easy way to store key/value pairs and other complicated
     * data in a way that uses a variety of storage engines underneath.
     *
     * For most cases, we recommend the SqlStorage system as it will store
     * data in a file in the app's sandbox. LocalStorage should ONLY be used
     * for temporary data as it may be "cleaned up" by the operation system
     * during low disk space situations.
     */
    'use strict';

    var Storage, StorageEngine;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            Storage = (function () {
                function Storage(strategyCls) {
                    _classCallCheck(this, Storage);

                    this._strategy = new strategyCls();
                }

                _createClass(Storage, [{
                    key: 'get',
                    value: function get(key) {
                        return this._strategy.get(key);
                    }
                }, {
                    key: 'getJson',
                    value: function getJson(key) {
                        try {
                            return JSON.parse(this._strategy.get(key));
                        } catch (e) {
                            console.warn('Storage getJson(): unable to parse value for key', key, ' as JSON');
                            return null;
                        }
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return this._strategy.set(key, value);
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return this._strategy.remove(key);
                    }
                }, {
                    key: 'query',
                    value: function query(_query) {
                        return this._strategy.query(key);
                    }
                }]);

                return Storage;
            })();

            _export('Storage', Storage);

            StorageEngine = (function () {
                function StorageEngine() {
                    _classCallCheck(this, StorageEngine);
                }

                _createClass(StorageEngine, [{
                    key: 'get',
                    value: function get(key, value) {
                        throw Error("get() not implemented for this storage engine");
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        throw Error("set() not implemented for this storage engine");
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        throw Error("remove() not implemented for this storage engine");
                    }
                }, {
                    key: 'query',
                    value: function query(_query2) {
                        throw Error("query() not implemented for this storage engine");
                    }
                }]);

                return StorageEngine;
            })();

            _export('StorageEngine', StorageEngine);
        }
    };
});
System.register("ionic/platform/vibration/vibration", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Vibration;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Vibration = (function () {
                function Vibration() {
                    _classCallCheck(this, Vibration);
                }

                _createClass(Vibration, null, [{
                    key: "vibrate",
                    value: function vibrate(pattern) {
                        if (!navigator.vibrate) {
                            this.pluginWarn();
                            console.log('Vibrate (dev): ', pattern);
                        } else {
                            navigator.vibrate(pattern);
                        }
                    }
                }]);

                return Vibration;
            })();

            _export("Vibration", Vibration);

            _export("Vibration", Vibration = __decorate([NativePlugin({
                name: 'Vibration',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-vibration'
                }
            }), __metadata('design:paramtypes', [])], Vibration));
        }
    };
});
System.register("ionic/native/battery/battery", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, _Battery;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _Battery = (function () {
                function Battery() {
                    _classCallCheck(this, Battery);
                }

                _createClass(Battery, null, [{
                    key: "getStatus",
                    value: function getStatus() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (navigator.getBattery) {
                                navigator.getBattery().then(function (battery) {
                                    _this.battery = battery;
                                    resolve(_Battery._format(battery));
                                });
                            } else {
                                var fnCb = function fnCb(battery) {
                                    resolve(battery);
                                    window.removeEventListener('batterystatus', fnCb);
                                };
                                window.addEventListener('batterystatus', fnCb);
                            }
                        });
                    }
                }, {
                    key: "_format",
                    value: function _format(batteryObj) {
                        if (typeof batteryObj.isPlugged !== 'undefined') {
                            // This is the old format, map it to the new format
                            util.extend(batteryObj, {
                                charging: batteryObj.isPlugged,
                                level: batteryObj.level / 100,
                                chargingTime: 0,
                                dischargingTime: 0 //not provided
                            });
                        }
                        return batteryObj;
                    }
                }]);

                return Battery;
            })();

            _export("Battery", _Battery);

            _Battery = __decorate([NativePlugin({
                name: 'Battery',
                platforms: {
                    cordova: 'cordova-plugin-battery-status'
                }
            }), __metadata('design:paramtypes', [])], _Battery);
        }
    };
});
System.register("ionic/native/device/device", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, _Device;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _Device = (function () {
                function Device() {
                    _classCallCheck(this, Device);
                }

                _createClass(Device, null, [{
                    key: "getDevice",

                    /**
                     * Returns the whole device object.
                     * @see https://github.com/apache/cordova-plugin-device
                     * @returns {Object} The device object.
                     */
                    value: function getDevice() {
                        return this.ifPlugin(window.device, function () {
                            return device;
                        }, function () {
                            return {
                                name: _Device.getName(),
                                model: _Device.getModel(),
                                platform: _Device.getPlatform(),
                                uuid: _Device.getUUID(),
                                version: _Device.getVersion()
                            };
                        });
                    }

                    /**
                     * Returns the Cordova version.
                     * @see https://github.com/apache/cordova-plugin-device#devicecordova
                     * @returns {String} The Cordova version.
                     */
                }, {
                    key: "getCordova",
                    value: function getCordova() {
                        this.ifPlugin(window.device, function () {
                            return device.cordova;
                        });
                    }

                    /**
                     * Returns the name of the device's model or product.
                     * @see https://github.com/apache/cordova-plugin-device#devicemodel
                     * @returns {String} The name of the device's model or product.
                     */
                }, {
                    key: "getModel",
                    value: function getModel() {
                        this.ifPlugin(window.device, function () {
                            return device.model;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * @deprecated device.name is deprecated as of version 2.3.0. Use device.model instead.
                     * @returns {String}
                     */
                }, {
                    key: "getName",
                    value: function getName() {
                        this.ifPlugin(window.device, function () {
                            return device.name;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device's operating system name.
                     * @see https://github.com/apache/cordova-plugin-device#deviceplatform
                     * @returns {String} The device's operating system name.
                     */
                }, {
                    key: "getPlatform",
                    value: function getPlatform() {
                        this.ifPlugin(window.device, function () {
                            return device.name;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device's Universally Unique Identifier.
                     * @see https://github.com/apache/cordova-plugin-device#deviceuuid
                     * @returns {String} The device's Universally Unique Identifier
                     */
                }, {
                    key: "getUUID",
                    value: function getUUID() {
                        this.ifPlugin(window.device, function () {
                            return device.uuid;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the operating system version.
                     * @see https://github.com/apache/cordova-plugin-device#deviceversion
                     * @returns {String}
                     */
                }, {
                    key: "getVersion",
                    value: function getVersion() {
                        this.ifPlugin(window.device, function () {
                            return device.version;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device manufacturer.
                     * @returns {String}
                     */
                }, {
                    key: "getManufacturer",
                    value: function getManufacturer() {
                        this.ifPlugin(window.device, function () {
                            return device.manufacturer;
                        }, function () {
                            return 'unknown';
                        });
                    }
                }]);

                return Device;
            })();

            _export("Device", _Device);

            _Device = __decorate([NativePlugin({
                name: 'Device',
                platforms: {
                    cordova: 'cordova-plugin-device'
                }
            }), __metadata('design:paramtypes', [])], _Device);
        }
    };
});
System.register("ionic/native/contacts/contacts", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Contacts;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Contacts = (function () {
                function Contacts() {
                    _classCallCheck(this, Contacts);
                }

                _createClass(Contacts, null, [{
                    key: "save",
                    value: function save(contact) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.save(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "remove",
                    value: function remove(contact) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this2.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.remove(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "clone",
                    value: function clone(contact) {
                        if (!navigator.contacts) {
                            this.pluginWarn();
                            return null;
                        }
                        var deviceContact = navigator.contacts.create(contact);
                        return deviceContact.clone(contact);
                    }
                }, {
                    key: "find",
                    value: function find(options) {
                        return new Promise(function (resolve, reject) {
                            var fields = options.fields || ['id', 'displayName'];
                            delete options.fields;
                            if (Object.keys(options).length === 0) {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                }, options);
                            }
                        });
                    }
                }, {
                    key: "pickContact",
                    value: function pickContact() {
                        return new Promise(function (resolve, reject) {
                            navigator.contacts.pickContact(function (contact) {
                                resolve(contact);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Contacts;
            })();

            _export("Contacts", Contacts);

            _export("Contacts", Contacts = __decorate([NativePlugin({
                name: 'Contacts',
                platforms: {
                    cordova: 'cordova-plugin-contacts'
                }
            }), __metadata('design:paramtypes', [])], Contacts));
        }
    };
});
System.register("ionic/native/camera/camera", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, Camera;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Camera = (function () {
                function Camera() {
                    _classCallCheck(this, Camera);
                }

                _createClass(Camera, null, [{
                    key: "getPicture",
                    value: function getPicture(options) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.camera) {
                                _this.pluginWarn();
                                resolve(null);
                                return;
                            }
                            var options = util.defaults({
                                quality: 80,
                                destinationType: window.Camera.DestinationType.DATA_URL,
                                sourceType: window.Camera.PictureSourceType.CAMERA,
                                allowEdit: true,
                                encodingType: window.Camera.EncodingType.JPEG,
                                popoverOptions: window.CameraPopoverOptions,
                                saveToPhotoAlbum: false
                            }, options);
                            navigator.camera.getPicture(function (imageData) {
                                resolve(imageData);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "cleanup",
                    value: function cleanup() {
                        return new Promise(function (resolve, reject) {
                            navigator.camera.cleanup(function () {
                                resolve();
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Camera;
            })();

            _export("Camera", Camera);

            _export("Camera", Camera = __decorate([NativePlugin({
                name: 'Camera',
                platforms: {
                    cordova: 'cordova-plugin-camera'
                }
            }), __metadata('design:paramtypes', [])], Camera));
        }
    };
});
System.register("ionic/native/device-motion/device-motion", ["rx", "ionic/util", "../plugin"], function (_export) {
    "use strict";

    var Rx, util, NativePlugin, __decorate, __metadata, _DeviceMotion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceMotion = (function () {
                function DeviceMotion() {
                    _classCallCheck(this, DeviceMotion);
                }

                _createClass(DeviceMotion, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        // Mimic the DeviceMotionEvent
                        return util.extend({
                            acceleration: result,
                            accelerationIncludingGravity: result,
                            rotationRate: 0,
                            interval: 0,
                            native: true
                        }, result);
                    }
                }, {
                    key: "getCurrentAcceleration",
                    value: function getCurrentAcceleration() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                                var fnCb = function fnCb(eventData) {
                                    resolve(_DeviceMotion._wrap(eventData));
                                    window.removeEventListener('devicemotion', fnCb);
                                };
                                window.addEventListener('devicemotion', fnCb);
                            } else if (navigator.accelerometer) {
                                navigator.accelerometer.getCurrentAcceleration(function (result) {
                                    resolve(_DeviceMotion._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device motion events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchAcceleration",
                    value: function watchAcceleration(options) {
                        if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    observer.onNext(_DeviceMotion._wrap(eventData));
                                };
                                window.addEventListener('devicemotion', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('devicemotion', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.accelerometer.watchAcceleration(function (result) {
                                        observer.onNext(_DeviceMotion._wrap(result));
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.accelerometer.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceMotion;
            })();

            _export("DeviceMotion", _DeviceMotion);

            _DeviceMotion = __decorate([NativePlugin({
                name: 'Device Motion',
                platforms: {
                    cordova: 'cordova-plugin-device-motion'
                }
            }), __metadata('design:paramtypes', [])], _DeviceMotion);
        }
    };
});
System.register("ionic/native/device-orientation/device-orientation", ["rx", "ionic/util", "../plugin"], function (_export) {
    "use strict";

    var Rx, util, NativePlugin, __decorate, __metadata, _DeviceOrientation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceOrientation = (function () {
                function DeviceOrientation() {
                    _classCallCheck(this, DeviceOrientation);
                }

                _createClass(DeviceOrientation, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        return util.extend({
                            alpha: result.magneticHeading,
                            magneticHeading: result.webkitCompassHeading || result.alpha
                        }, result);
                    }
                }, {
                    key: "getCurrentHeading",
                    value: function getCurrentHeading() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceOrientationEvent) {
                                var fnCb = function fnCb(eventData) {
                                    resolve(_DeviceOrientation._wrap(eventData));
                                    window.removeEventListener('deviceorientation', fnCb);
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            } else if (navigator.compass) {
                                navigator.compass.getCurrentHeading(function (result) {
                                    resolve(_DeviceOrientation._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device orientation events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchHeading",
                    value: function watchHeading(options) {
                        if (window.DeviceOrientationEvent) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    observer.onNext(_DeviceOrientation._wrap(eventData));
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('deviceorientation', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.compass.watchHeading(function (result) {
                                        observer.onNext(_DeviceOrientation._wrap(result));
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.compass.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceOrientation;
            })();

            _export("DeviceOrientation", _DeviceOrientation);

            _DeviceOrientation = __decorate([NativePlugin({
                name: 'Device Orientation',
                platforms: {
                    cordova: 'cordova-plugin-device-orientation'
                }
            }), __metadata('design:paramtypes', [])], _DeviceOrientation);
        }
    };
});
System.register("ionic/native/geolocation/geolocation", ["rx", "../plugin"], function (_export) {
    "use strict";

    var Rx, NativePlugin, __decorate, __metadata, Geolocation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Geolocation = (function () {
                function Geolocation() {
                    _classCallCheck(this, Geolocation);
                }

                _createClass(Geolocation, null, [{
                    key: "getCurrentPosition",
                    value: function getCurrentPosition(options) {
                        return new Promise(function (resolve, reject) {
                            navigator.geolocation.getCurrentPosition(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "watchPosition",
                    value: function watchPosition(options) {
                        var watchID = undefined;
                        var source = Rx.Observable.create(function (observer) {
                            watchID = navigator.geolocation.watchPosition(function (result) {
                                observer.onNext(result);
                            }, function (err) {
                                observer.onError(err, observer);
                            }, options);
                        });
                        return {
                            source: source,
                            watchID: watchID,
                            clear: function clear() {
                                navigator.geolocation.clearWatch(watchID);
                            }
                        };
                    }
                }, {
                    key: "clearWatch",
                    value: function clearWatch(watchID) {
                        return navigator.geolocation.clearWatch(watchID);
                    }
                }]);

                return Geolocation;
            })();

            _export("Geolocation", Geolocation);

            _export("Geolocation", Geolocation = __decorate([NativePlugin({
                name: 'Geolocation',
                platforms: {
                    cordova: 'cordova-plugin-geolocation'
                }
            }), __metadata('design:paramtypes', [])], Geolocation));
        }
    };
});
System.register("ionic/plugins/applinks/applinks", ["../plugin"], function (_export) {
    /**
     * Open installed apps on the device. Note: Android and iOS have different ways of
     * opening and specifying launch params, so they have separate launch functions.
     *
     * Example:
     *
     * if(platform.is('ios') {
     *   AppLinks.check('twitter://').then((installed) => {
     *     AppLinks.openIOS('twitter://user?screen_name=ionicframework')
     *   }, (err) => {
     *
     *   })
     * } else if(platform.is('android') {
     *   AppLinks.check('com.twitter.android').then((installed) => {
     *     AppLinks.openAndroid([["action", "VIEW"], ['twitter://user?screen_name=ionicframework']])
     *   })
     * }
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, AppLinks;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            AppLinks = (function () {
                function AppLinks() {
                    _classCallCheck(this, AppLinks);
                }

                _createClass(AppLinks, null, [{
                    key: "openIOS",

                    /**
                     * Open app on iOS with a given URL (iOS), or scheme (Android)
                     */
                    value: function openIOS(url) {
                        this.ifPlugin(function () {
                            navigator.startApp.start(url);
                        });
                    }

                    /**
                     * Open app on Android with a given scheme and params.
                     */
                }, {
                    key: "openAndroid",
                    value: function openAndroid(args) {
                        this.ifPlugin(function () {
                            var _navigator$startApp;

                            (_navigator$startApp = navigator.startApp).start.apply(_navigator$startApp, _toConsumableArray(args));
                        });
                    }

                    /**
                     * Check if an installed app can be opened from the given URL.
                     */
                }, {
                    key: "canOpen",
                    value: function canOpen(urlOrScheme) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            var hasPlugin = _this.ifPlugin(function () {
                                navigator.startApp.check(urlOrScheme, function (message) {
                                    resolve(message);
                                }, function (err) {
                                    reject(err);
                                });
                            });
                            if (!hasPlugin) {
                                reject('Plugin not installed');
                            }
                        });
                    }
                }]);

                return AppLinks;
            })();

            _export("AppLinks", AppLinks);

            _export("AppLinks", AppLinks = __decorate([NativePlugin({
                name: 'AppLinks',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-statusbar'
                },
                pluginCheck: function pluginCheck() {
                    return !!navigator.startApp;
                }
            }), __metadata('design:paramtypes', [])], AppLinks));
        }
    };
});
System.register("ionic/plugins/camera/camera", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, Camera;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Camera = (function () {
                function Camera() {
                    _classCallCheck(this, Camera);
                }

                _createClass(Camera, null, [{
                    key: "getPicture",
                    value: function getPicture(options) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.camera) {
                                _this.pluginWarn();
                                resolve(null);
                                return;
                            }
                            var options = util.defaults({
                                quality: 80,
                                destinationType: window.Camera.DestinationType.DATA_URL,
                                sourceType: window.Camera.PictureSourceType.CAMERA,
                                allowEdit: true,
                                encodingType: window.Camera.EncodingType.JPEG,
                                popoverOptions: window.CameraPopoverOptions,
                                saveToPhotoAlbum: false
                            }, options);
                            navigator.camera.getPicture(function (imageData) {
                                resolve(imageData);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "cleanup",
                    value: function cleanup() {
                        return new Promise(function (resolve, reject) {
                            navigator.camera.cleanup(function () {
                                resolve();
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Camera;
            })();

            _export("Camera", Camera);

            _export("Camera", Camera = __decorate([NativePlugin({
                name: 'Camera',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-camera'
                },
                pluginCheck: function pluginCheck() {
                    return !!navigator.camera;
                }
            }), __metadata('design:paramtypes', [])], Camera));
        }
    };
});
System.register("ionic/plugins/battery/battery", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, _Battery;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _Battery = (function () {
                function Battery() {
                    _classCallCheck(this, Battery);
                }

                _createClass(Battery, null, [{
                    key: "getStatus",
                    value: function getStatus() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (navigator.getBattery) {
                                navigator.getBattery().then(function (battery) {
                                    _this.battery = battery;
                                    resolve(_Battery._format(battery));
                                });
                            } else {
                                var fnCb = function fnCb(battery) {
                                    resolve(battery);
                                    window.removeEventListener('batterystatus', fnCb);
                                };
                                window.addEventListener('batterystatus', fnCb);
                            }
                        });
                    }
                }, {
                    key: "_format",
                    value: function _format(batteryObj) {
                        if (typeof batteryObj.isPlugged !== 'undefined') {
                            // This is the old format, map it to the new format
                            util.extend(batteryObj, {
                                charging: batteryObj.isPlugged,
                                level: batteryObj.level / 100,
                                chargingTime: 0,
                                dischargingTime: 0 //not provided
                            });
                        }
                        return batteryObj;
                    }
                }]);

                return Battery;
            })();

            _export("Battery", _Battery);

            _Battery = __decorate([NativePlugin({
                name: 'Battery',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-battery-status'
                }
            }), __metadata('design:paramtypes', [])], _Battery);
        }
    };
});
System.register("ionic/plugins/camera-roll/camera-roll", ["../plugin"], function (_export) {
    /**
     * Save and load photos from the Camera Roll
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, CameraRoll;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            CameraRoll = (function () {
                function CameraRoll() {
                    _classCallCheck(this, CameraRoll);
                }

                _createClass(CameraRoll, null, [{
                    key: "save",

                    /**
                     * Save the base64 encoded image to the camera roll.
                     */
                    value: function save(base64String) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            _this.ifPlugin(function () {
                                window.CameraRoll.saveToCameraRoll(base64String, function () {
                                    resolve();
                                }, function (err) {
                                    reject(err);
                                });
                            });
                        });
                    }

                    /**
                     * Get photos from the camera roll
                     */
                }, {
                    key: "getPhotos",
                    value: function getPhotos(options) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            _this2.ifPlugin(function () {
                                window.CameraRoll.saveToCameraRoll(base64String);
                            });
                        });
                    }
                }]);

                return CameraRoll;
            })();

            _export("CameraRoll", CameraRoll);

            _export("CameraRoll", CameraRoll = __decorate([NativePlugin({
                name: 'CameraRoll',
                platforms: ['ios'],
                engines: {
                    cordova: 'cordova-plugin-camera-roll'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.CameraRoll;
                }
            }), __metadata('design:paramtypes', [])], CameraRoll));
        }
    };
});
System.register("ionic/plugins/barcode/barcode", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Barcode;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Barcode = (function () {
                function Barcode() {
                    _classCallCheck(this, Barcode);
                }

                _createClass(Barcode, null, [{
                    key: "scan",

                    /**
                     * Scan a barcode.
                     *
                     * @return Promise that resolves with an object of the format: {
                     *   text: text that was scanned,
                     *   format: format of barcode,
                     *   cancelled: was it canceled?
                     * }
                     */
                    value: function scan() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            var hasPlugin = _this.ifPlugin(function () {
                                window.cordova.plugins.barcodeScanner.scan(function (result) {
                                    resolve(result);
                                }, function (err) {
                                    reject(err);
                                });
                            });
                            if (!hasPlugin) {
                                reject('No scanner available');
                            }
                        });
                    }

                    /**
                     * Encode the given data in a barcode.
                     *
                     * @param type the type to use for encoding (if in doubt, use TYPE_TEXT).
                     * @param data the data to encode
                     * @return Promise
                     */
                }, {
                    key: "encode",
                    value: function encode(type, data) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            var hasPlugin = _this2.ifPlugin(function () {
                                window.cordova.plugins.barcodeScanner.encode(type, data, function (result) {
                                    resolve(result);
                                }, function (err) {
                                    reject(err);
                                });
                            });
                            if (!hasPlugin) {
                                reject('No scanner available');
                            }
                        });
                    }
                }]);

                return Barcode;
            })();

            _export("Barcode", Barcode);

            Barcode.TEXT_TYPE = "TEXT_TYPE";
            Barcode.EMAIL_TYPE = "EMAIL_TYPE";
            Barcode.PHONE_TYPE = "PHONE_TYPE";
            Barcode.SMS_TYPE = "SMS_TYPE";
            _export("Barcode", Barcode = __decorate([NativePlugin({
                name: 'Barcode',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'phonegap-plugin-barcodescanner'
                },
                pluginCheck: function pluginCheck() {
                    return window.cordova && window.cordova.plugins && window.cordova.plugins.barcodeScanner;
                }
            }), __metadata('design:paramtypes', [])], Barcode));
        }
    };
});
System.register("ionic/plugins/contacts/contacts", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Contacts;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Contacts = (function () {
                function Contacts() {
                    _classCallCheck(this, Contacts);
                }

                _createClass(Contacts, null, [{
                    key: "save",
                    value: function save(contact) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.save(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "remove",
                    value: function remove(contact) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this2.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.remove(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "clone",
                    value: function clone(contact) {
                        if (!navigator.contacts) {
                            this.pluginWarn();
                            return null;
                        }
                        var deviceContact = navigator.contacts.create(contact);
                        return deviceContact.clone(contact);
                    }
                }, {
                    key: "find",
                    value: function find(options) {
                        return new Promise(function (resolve, reject) {
                            var fields = options.fields || ['id', 'displayName'];
                            delete options.fields;
                            if (Object.keys(options).length === 0) {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                }, options);
                            }
                        });
                    }
                }, {
                    key: "pickContact",
                    value: function pickContact() {
                        return new Promise(function (resolve, reject) {
                            navigator.contacts.pickContact(function (contact) {
                                resolve(contact);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Contacts;
            })();

            _export("Contacts", Contacts);

            _export("Contacts", Contacts = __decorate([NativePlugin({
                name: 'Contacts',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-contacts'
                }
            }), __metadata('design:paramtypes', [])], Contacts));
        }
    };
});
System.register("ionic/plugins/device/device", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, _Device;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _Device = (function () {
                function Device() {
                    _classCallCheck(this, Device);
                }

                _createClass(Device, null, [{
                    key: "getDevice",

                    /**
                     * Returns the whole device object.
                     * @see https://github.com/apache/cordova-plugin-device
                     * @returns {Object} The device object.
                     */
                    value: function getDevice() {
                        return this.ifPlugin(function () {
                            return device;
                        }, function () {
                            return {
                                name: _Device.getName(),
                                model: _Device.getModel(),
                                platform: _Device.getPlatform(),
                                uuid: _Device.getUUID(),
                                version: _Device.getVersion()
                            };
                        });
                    }

                    /**
                     * Returns the Cordova version.
                     * @see https://github.com/apache/cordova-plugin-device#devicecordova
                     * @returns {String} The Cordova version.
                     */
                }, {
                    key: "getCordova",
                    value: function getCordova() {
                        this.ifPlugin(function () {
                            return device.cordova;
                        });
                    }

                    /**
                     * Returns the name of the device's model or product.
                     * @see https://github.com/apache/cordova-plugin-device#devicemodel
                     * @returns {String} The name of the device's model or product.
                     */
                }, {
                    key: "getModel",
                    value: function getModel() {
                        this.ifPlugin(function () {
                            return device.model;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * @deprecated device.name is deprecated as of version 2.3.0. Use device.model instead.
                     * @returns {String}
                     */
                }, {
                    key: "getName",
                    value: function getName() {
                        this.ifPlugin(function () {
                            return device.name;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device's operating system name.
                     * @see https://github.com/apache/cordova-plugin-device#deviceplatform
                     * @returns {String} The device's operating system name.
                     */
                }, {
                    key: "getPlatform",
                    value: function getPlatform() {
                        this.ifPlugin(function () {
                            return device.name;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device's Universally Unique Identifier.
                     * @see https://github.com/apache/cordova-plugin-device#deviceuuid
                     * @returns {String} The device's Universally Unique Identifier
                     */
                }, {
                    key: "getUUID",
                    value: function getUUID() {
                        this.ifPlugin(function () {
                            return device.uuid;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the operating system version.
                     * @see https://github.com/apache/cordova-plugin-device#deviceversion
                     * @returns {String}
                     */
                }, {
                    key: "getVersion",
                    value: function getVersion() {
                        this.ifPlugin(function () {
                            return device.version;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device manufacturer.
                     * @returns {String}
                     */
                }, {
                    key: "getManufacturer",
                    value: function getManufacturer() {
                        this.ifPlugin(function () {
                            return device.manufacturer;
                        }, function () {
                            return 'unknown';
                        });
                    }
                }]);

                return Device;
            })();

            _export("Device", _Device);

            _Device = __decorate([NativePlugin({
                name: 'Device',
                plugins: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-device'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.device;
                }
            }), __metadata('design:paramtypes', [])], _Device);
        }
    };
});
System.register("ionic/native/vibration/vibration", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Vibration;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Vibration = (function () {
                function Vibration() {
                    _classCallCheck(this, Vibration);
                }

                _createClass(Vibration, null, [{
                    key: "vibrate",
                    value: function vibrate(pattern) {
                        if (!navigator.vibrate) {
                            this.pluginWarn();
                            console.log('Vibrate (dev): ', pattern);
                        } else {
                            navigator.vibrate(pattern);
                        }
                    }
                }]);

                return Vibration;
            })();

            _export("Vibration", Vibration);

            _export("Vibration", Vibration = __decorate([NativePlugin({
                name: 'Vibration',
                platforms: {
                    cordova: 'cordova-plugin-vibration'
                }
            }), __metadata('design:paramtypes', [])], Vibration));
        }
    };
});
System.register("ionic/plugins/device-orientation/device-orientation", ["rx", "ionic/util", "../plugin"], function (_export) {
    "use strict";

    var Rx, util, NativePlugin, __decorate, __metadata, _DeviceOrientation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceOrientation = (function () {
                function DeviceOrientation() {
                    _classCallCheck(this, DeviceOrientation);
                }

                _createClass(DeviceOrientation, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        return util.extend({
                            alpha: result.magneticHeading,
                            magneticHeading: result.webkitCompassHeading || result.alpha
                        }, result);
                    }
                }, {
                    key: "getCurrentHeading",
                    value: function getCurrentHeading() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceOrientationEvent) {
                                var fnCb = function fnCb(eventData) {
                                    resolve(_DeviceOrientation._wrap(eventData));
                                    window.removeEventListener('deviceorientation', fnCb);
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            } else if (navigator.compass) {
                                navigator.compass.getCurrentHeading(function (result) {
                                    resolve(_DeviceOrientation._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device orientation events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchHeading",
                    value: function watchHeading(options) {
                        if (window.DeviceOrientationEvent) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    observer.onNext(_DeviceOrientation._wrap(eventData));
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('deviceorientation', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.compass.watchHeading(function (result) {
                                        observer.onNext(_DeviceOrientation._wrap(result));
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.compass.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceOrientation;
            })();

            _export("DeviceOrientation", _DeviceOrientation);

            _DeviceOrientation = __decorate([NativePlugin({
                name: 'Device Orientation',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-device-orientation'
                }
            }), __metadata('design:paramtypes', [])], _DeviceOrientation);
        }
    };
});
System.register("ionic/plugins/dialogs/dialogs", ["../plugin"], function (_export) {
    /**
     * A native dialogs system. Native dialogs can give you a bit more
     * control over the UI than the browser built-ins, though the Dialogs
     * plugin will fall back to the built-ins when necessary.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, Dialogs;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Dialogs = (function () {
                function Dialogs() {
                    _classCallCheck(this, Dialogs);
                }

                _createClass(Dialogs, null, [{
                    key: "alert",

                    /**
                     * Trigger an alert prompt.
                     *
                     * @param message the message to show
                     * @param title the title to show
                     * @param buttonName the button label to use (not available on browser fallback)
                     * @return Promise
                     */
                    value: (function (_alert) {
                        function alert(_x, _x2, _x3) {
                            return _alert.apply(this, arguments);
                        }

                        alert.toString = function () {
                            return _alert.toString();
                        };

                        return alert;
                    })(function (message, title, buttonName) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this.pluginWarn();
                                alert(message);
                                resolve();
                            } else {
                                navigator.notification.alert(message, function () {
                                    resolve();
                                }, title, buttonName);
                            }
                        });
                    })

                    /**
                     * Trigger a confirm prompt.
                     *
                     * @param message the message to show
                     * @param title the title to show
                     * @param buttonLabels the button labels to use (not available on browser fallback)
                     * @return Promise that resolves with the index of the button selected (zero indexed). 1 is OK on browser fallback
                     */
                }, {
                    key: "confirm",
                    value: (function (_confirm) {
                        function confirm(_x4, _x5, _x6) {
                            return _confirm.apply(this, arguments);
                        }

                        confirm.toString = function () {
                            return _confirm.toString();
                        };

                        return confirm;
                    })(function (message, title, buttonLabels) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this2.pluginWarn();
                                var ok = confirm(message);
                                // Use 2 as OK
                                resolve(ok ? 2 : 0);
                            } else {
                                navigator.notification.confirm(message, function (buttonIndex) {
                                    resolve(buttonIndex - 1);
                                }, title, buttonLabels);
                            }
                        });
                    })
                }, {
                    key: "prompt",
                    value: (function (_prompt) {
                        function prompt(_x7, _x8, _x9, _x10) {
                            return _prompt.apply(this, arguments);
                        }

                        prompt.toString = function () {
                            return _prompt.toString();
                        };

                        return prompt;
                    })(function (message, title, buttonLabels, defaultText) {
                        var _this3 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this3.pluginWarn();
                                var response = prompt(message);
                                // Use 1 as OK
                                resolve(response);
                            } else {
                                navigator.notification.prompt(message, function (results) {
                                    resolve(results.input1, buttonIndex - 1);
                                }, title, buttonLabels, defaultText);
                            }
                        });
                    })

                    /**
                     * Beep n times. Not available on browser.
                     * @param times the number of times to beep
                     */
                }, {
                    key: "beep",
                    value: function beep(times) {
                        navigator.notification && navigator.notification.beep(times);
                    }
                }]);

                return Dialogs;
            })();

            _export("Dialogs", Dialogs);

            _export("Dialogs", Dialogs = __decorate([NativePlugin({
                name: 'Dialogs',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-dialogs'
                }
            }), __metadata('design:paramtypes', [])], Dialogs));
        }
    };
});
System.register("ionic/plugins/geolocation/geolocation", ["rx", "../plugin"], function (_export) {
    "use strict";

    var Rx, NativePlugin, __decorate, __metadata, Geolocation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Geolocation = (function () {
                function Geolocation() {
                    _classCallCheck(this, Geolocation);
                }

                _createClass(Geolocation, null, [{
                    key: "getCurrentPosition",
                    value: function getCurrentPosition(options) {
                        return new Promise(function (resolve, reject) {
                            navigator.geolocation.getCurrentPosition(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "watchPosition",
                    value: function watchPosition(options) {
                        var watchID = undefined;
                        var source = Rx.Observable.create(function (observer) {
                            watchID = navigator.geolocation.watchPosition(function (result) {
                                observer.onNext(result);
                            }, function (err) {
                                observer.onError(err, observer);
                            }, options);
                        });
                        return {
                            source: source,
                            watchID: watchID,
                            clear: function clear() {
                                navigator.geolocation.clearWatch(watchID);
                            }
                        };
                    }
                }, {
                    key: "clearWatch",
                    value: function clearWatch(watchID) {
                        return navigator.geolocation.clearWatch(watchID);
                    }
                }]);

                return Geolocation;
            })();

            _export("Geolocation", Geolocation);

            _export("Geolocation", Geolocation = __decorate([NativePlugin({
                name: 'Geolocation',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-geolocation'
                }
            }), __metadata('design:paramtypes', [])], Geolocation));
        }
    };
});
System.register("ionic/plugins/keyboard/keyboard", ["../plugin"], function (_export) {
    /**
     * Manage the native keyboard. Note: this plugin performs mainly in the native
     * app context. Most operations are non-functional in a normal web browser as
     * keyboard control is limited.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, Keyboard;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Keyboard = (function () {
                function Keyboard() {
                    _classCallCheck(this, Keyboard);
                }

                _createClass(Keyboard, null, [{
                    key: "setAccessoryBarVisible",

                    /**
                     * Set whether the accessory bar is visible.
                     *
                     * Note: this only works while running natively (accessory bar cannot be removed
                     * in most web browsers), and by default the bar is hidden when running natively.
                     *
                     * @param isVisible whether the accessory bar is visible
                     */
                    value: function setAccessoryBarVisible(isVisible) {
                        this.ifPlugin(function () {
                            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(!isVisible);
                        });
                    }

                    /**
                     * Close the keyboard.
                     */
                }, {
                    key: "close",
                    value: function close() {
                        this.ifPlugin(function () {
                            cordova.plugins.Keyboard.close();
                        });
                    }

                    /**
                     * Show the keyboard. Does nothing on iOS (has to be triggered from an input)
                     */
                }, {
                    key: "show",
                    value: function show() {
                        this.ifPlugin(function () {
                            cordova.plugins.Keyboard.show();
                        });
                    }

                    /**
                     * @return the visibility of the keyboard.
                     */
                }, {
                    key: "isVisible",
                    value: function isVisible() {
                        return this.ifPlugin(function () {
                            return cordova.plugins.Keyboard.isVisible;
                        });
                    }
                }]);

                return Keyboard;
            })();

            _export("Keyboard", Keyboard);

            _export("Keyboard", Keyboard = __decorate([NativePlugin({
                name: 'Keyboard',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'ionic-plugin-keyboard'
                },
                pluginCheck: function pluginCheck() {
                    return window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard;
                }
            }), __metadata('design:paramtypes', [])], Keyboard));
        }
    };
});
System.register("ionic/plugins/loading/loading", ["../plugin"], function (_export) {
    /**
     * Simple loading popup indicators.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, Loading;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Loading = (function () {
                function Loading() {
                    _classCallCheck(this, Loading);
                }

                _createClass(Loading, null, [{
                    key: "simple",
                    value: function simple(dim, label, detail) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showSimple(dim);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showSimpleWithLabel(dim, label);
                                return;
                            }
                            window.ProgressIndicator.showSimpleWithLabelDetail(dim, label, detail);
                        });
                    }
                }, {
                    key: "determinate",
                    value: function determinate(dim, timeout, label) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showDeterminate(dim, timeout);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showSimpleWithLabel(dim, timeout, label);
                                return;
                            }
                        });
                    }
                }, {
                    key: "annular",
                    value: function annular(dim, timeout, label) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showAnnular(dim, timeout);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showAnnularWithLabel(dim, timeout, label);
                                return;
                            }
                        });
                    }
                }, {
                    key: "bar",
                    value: function bar(dim, timeout, label) {
                        this.ifPlugin(function () {
                            if (typeof label === 'undefined') {
                                window.ProgressIndicator.showBar(dim, timeout);
                                return;
                            }
                            if (typeof detail === 'undefined') {
                                window.ProgressIndicator.showBarWithLabel(dim, timeout, label);
                                return;
                            }
                        });
                    }
                }, {
                    key: "success",
                    value: function success(dim, label) {
                        this.ifPlugin(function () {
                            window.ProgressIndicator.showSuccess(dim, label);
                        });
                    }
                }, {
                    key: "hide",
                    value: function hide() {
                        this.ifPlugin(function () {
                            window.ProgressIndicator.hide();
                        });
                    }
                }]);

                return Loading;
            })();

            _export("Loading", Loading);

            _export("Loading", Loading = __decorate([NativePlugin({
                name: 'Loading',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-progressindicator'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.ProgressIndicator;
                }
            }), __metadata('design:paramtypes', [])], Loading));
        }
    };
});
System.register("ionic/plugins/device-motion/device-motion", ["rx", "ionic/util", "../plugin"], function (_export) {
    "use strict";

    var Rx, util, NativePlugin, __decorate, __metadata, _DeviceMotion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceMotion = (function () {
                function DeviceMotion() {
                    _classCallCheck(this, DeviceMotion);
                }

                _createClass(DeviceMotion, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        // Mimic the DeviceMotionEvent
                        return util.extend({
                            acceleration: result,
                            accelerationIncludingGravity: result,
                            rotationRate: 0,
                            interval: 0,
                            native: true
                        }, result);
                    }
                }, {
                    key: "getCurrentAcceleration",
                    value: function getCurrentAcceleration() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                                var fnCb = function fnCb(eventData) {
                                    resolve(_DeviceMotion._wrap(eventData));
                                    window.removeEventListener('devicemotion', fnCb);
                                };
                                window.addEventListener('devicemotion', fnCb);
                            } else if (navigator.accelerometer) {
                                navigator.accelerometer.getCurrentAcceleration(function (result) {
                                    resolve(_DeviceMotion._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device motion events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchAcceleration",
                    value: function watchAcceleration(options) {
                        if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    observer.onNext(_DeviceMotion._wrap(eventData));
                                };
                                window.addEventListener('devicemotion', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('devicemotion', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.accelerometer.watchAcceleration(function (result) {
                                        observer.onNext(_DeviceMotion._wrap(result));
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.accelerometer.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceMotion;
            })();

            _export("DeviceMotion", _DeviceMotion);

            _DeviceMotion = __decorate([NativePlugin({
                name: 'Device Motion',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-device-motion'
                }
            }), __metadata('design:paramtypes', [])], _DeviceMotion);
        }
    };
});
System.register("ionic/native/dialogs/dialogs", ["../plugin"], function (_export) {
    /**
     * A native dialogs system. Native dialogs can give you a bit more
     * control over the UI than the browser built-ins, though the Dialogs
     * plugin will fall back to the built-ins when necessary.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, Dialogs;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Dialogs = (function () {
                function Dialogs() {
                    _classCallCheck(this, Dialogs);
                }

                _createClass(Dialogs, null, [{
                    key: "alert",

                    /**
                     * Trigger an alert prompt.
                     *
                     * @param message the message to show
                     * @param title the title to show
                     * @param buttonName the button label to use (not available on browser fallback)
                     * @return Promise
                     */
                    value: (function (_alert) {
                        function alert(_x, _x2, _x3) {
                            return _alert.apply(this, arguments);
                        }

                        alert.toString = function () {
                            return _alert.toString();
                        };

                        return alert;
                    })(function (message, title, buttonName) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this.pluginWarn();
                                alert(message);
                                resolve();
                            } else {
                                navigator.notification.alert(message, function () {
                                    resolve();
                                }, title, buttonName);
                            }
                        });
                    })

                    /**
                     * Trigger a confirm prompt.
                     *
                     * @param message the message to show
                     * @param title the title to show
                     * @param buttonLabels the button labels to use (not available on browser fallback)
                     * @return Promise that resolves with the index of the button selected (zero indexed). 1 is OK on browser fallback
                     */
                }, {
                    key: "confirm",
                    value: (function (_confirm) {
                        function confirm(_x4, _x5, _x6) {
                            return _confirm.apply(this, arguments);
                        }

                        confirm.toString = function () {
                            return _confirm.toString();
                        };

                        return confirm;
                    })(function (message, title, buttonLabels) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this2.pluginWarn();
                                var ok = confirm(message);
                                // Use 2 as OK
                                resolve(ok ? 2 : 0);
                            } else {
                                navigator.notification.confirm(message, function (buttonIndex) {
                                    resolve(buttonIndex - 1);
                                }, title, buttonLabels);
                            }
                        });
                    })
                }, {
                    key: "prompt",
                    value: (function (_prompt) {
                        function prompt(_x7, _x8, _x9, _x10) {
                            return _prompt.apply(this, arguments);
                        }

                        prompt.toString = function () {
                            return _prompt.toString();
                        };

                        return prompt;
                    })(function (message, title, buttonLabels, defaultText) {
                        var _this3 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.notification) {
                                _this3.pluginWarn();
                                var response = prompt(message);
                                // Use 1 as OK
                                resolve(response);
                            } else {
                                navigator.notification.prompt(message, function (results) {
                                    resolve(results.input1, buttonIndex - 1);
                                }, title, buttonLabels, defaultText);
                            }
                        });
                    })

                    /**
                     * Beep n times. Not available on browser.
                     * @param times the number of times to beep
                     */
                }, {
                    key: "beep",
                    value: function beep(times) {
                        navigator.notification && navigator.notification.beep(times);
                    }
                }]);

                return Dialogs;
            })();

            _export("Dialogs", Dialogs);

            _export("Dialogs", Dialogs = __decorate([NativePlugin({
                name: 'Dialogs',
                platforms: {
                    cordova: 'cordova-plugin-dialogs'
                }
            }), __metadata('design:paramtypes', [])], Dialogs));
        }
    };
});
System.register("ionic/plugins/statusbar/statusbar", ["../plugin"], function (_export) {
    /**
     * Manage the appearance of the native status bar.
     */
    "use strict";

    var NativePlugin, __decorate, __metadata, _StatusBar;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _StatusBar = (function () {
                function StatusBar() {
                    _classCallCheck(this, StatusBar);
                }

                _createClass(StatusBar, null, [{
                    key: "show",

                    /**
                     * Show the StatusBar
                     */
                    value: function show() {
                        this.ifPlugin(function () {
                            window.StatusBar.show();
                        });
                    }

                    /**
                     * Hide the StatusBar
                     */
                }, {
                    key: "hide",
                    value: function hide() {
                        this.ifPlugin(function () {
                            window.StatusBar.hide();
                        });
                    }

                    /**
                     * Hide the StatusBar
                     *
                     * Options:
                     *
                     * StatusBar.DEFAULT
                     * StatusBar.LIGHT_CONTENT
                     * StatusBar.BLACK_TRANSLUCENT
                     * StatusBar.BLACK_OPAQUE
                     *
                     * @param style the style from above
                     */
                }, {
                    key: "setStyle",
                    value: function setStyle(style) {
                        this.ifPlugin(function () {
                            switch (style) {
                                case _StatusBar.DEFAULT:
                                    window.StatusBar.styleDefault();
                                    break;
                                case _StatusBar.LIGHT_CONTENT:
                                    window.StatusBar.styleLightContent();
                                    break;
                                case _StatusBar.BLACK_TRANSLUCENT:
                                    window.StatusBar.styleBlackTranslucent();
                                    break;
                                case _StatusBar.BLACK_OPAQUE:
                                    window.StatusBar.styleBlackOpaque();
                                    break;
                            }
                        });
                    }

                    /**
                     * Set the status bar to a specific hex color (CSS shorthand supported!).
                     *
                     * iOS note: you must call StatusBar.setOverlay(false) to enable color changing.
                     *
                     * @param hex the hex value of the color.
                     */
                }, {
                    key: "setHexColor",
                    value: function setHexColor(hex) {
                        this.ifPlugin(function () {
                            window.StatusBar.backgroundColorByHexName(hex);
                        });
                    }

                    /**
                     * Set the status bar to a specific named color. Valid options:
                     * black, darkGray, lightGray, white, gray, red, green, blue, cyan, yellow, magenta, orange, purple, brown.
                     *
                     * iOS note: you must call StatusBar.setOverlay(false) to enable color changing.
                     *
                     * @param name the name of the color (from above)
                     */
                }, {
                    key: "setNamedColor",
                    value: function setNamedColor(name) {
                        this.ifPlugin(function () {
                            window.StatusBar.backgroundColorByName(name);
                        });
                    }

                    /**
                     * Set whether the status bar overlays the main app view. The default
                     * is true.
                     *
                     * @param doesOverlay whether the status bar overlays the main app view.
                     */
                }, {
                    key: "setOverlays",
                    value: function setOverlays(doesOverlay) {
                        this.ifPlugin(function () {
                            window.StatusBar.overlaysWebView(doesOverlay);
                        });
                    }
                }]);

                return StatusBar;
            })();

            _export("StatusBar", _StatusBar);

            _StatusBar.DEFAULT = 0;
            _StatusBar.LIGHT_CONTENT = 1;
            _StatusBar.BLACK_TRANSLUCENT = 2;
            _StatusBar.BLACK_OPAQUE = 3;
            _StatusBar = __decorate([NativePlugin({
                name: 'StatusBar',
                platforms: ['ios', 'android'],
                engines: {
                    cordova: 'cordova-plugin-statusbar'
                },
                pluginCheck: function pluginCheck() {
                    return !!window.StatusBar;
                }
            }), __metadata('design:paramtypes', [])], _StatusBar);
        }
    };
});
System.register("ionic/plugins/vibration/vibration", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Vibration;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Vibration = (function () {
                function Vibration() {
                    _classCallCheck(this, Vibration);
                }

                _createClass(Vibration, null, [{
                    key: "vibrate",
                    value: function vibrate(pattern) {
                        if (!navigator.vibrate) {
                            this.pluginWarn();
                            console.log('Vibrate (dev): ', pattern);
                        } else {
                            navigator.vibrate(pattern);
                        }
                    }
                }]);

                return Vibration;
            })();

            _export("Vibration", Vibration);

            _export("Vibration", Vibration = __decorate([NativePlugin({
                name: 'Vibration',
                platforms: ['ios', 'android', 'web'],
                engines: {
                    cordova: 'cordova-plugin-vibration'
                }
            }), __metadata('design:paramtypes', [])], Vibration));
        }
    };
});
System.register('ionic/components/aside/extensions/gestures', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, AsideTargetGesture, AsideGesture, LeftAsideGesture, RightAsideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            AsideTargetGesture = (function (_SlideEdgeGesture) {
                _inherits(AsideTargetGesture, _SlideEdgeGesture);

                function AsideTargetGesture(aside) {
                    _classCallCheck(this, AsideTargetGesture);

                    var asideElement = aside.getNativeElement();
                    _get(Object.getPrototypeOf(AsideTargetGesture.prototype), 'constructor', this).call(this, asideElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 0
                    });
                    this.aside = aside;
                }

                _createClass(AsideTargetGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        return this.aside.isOpen;
                    }

                    // Set CSS, then wait one frame for it to apply before sliding starts
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform(slide.distance);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setSliding(false);
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                            this.aside.setDoneTransforming(!this.aside.isOpen);
                        } else {
                            this.aside.setDoneTransforming(this.aside.isOpen);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideTargetGesture;
            })(SlideEdgeGesture);

            AsideGesture = (function (_SlideEdgeGesture2) {
                _inherits(AsideGesture, _SlideEdgeGesture2);

                function AsideGesture(aside) {
                    _classCallCheck(this, AsideGesture);

                    // TODO figure out the sliding element, dont just use the parent
                    var contentElement = aside.getContentElement();
                    _get(Object.getPrototypeOf(AsideGesture.prototype), 'constructor', this).call(this, contentElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 75
                    });
                    this.aside = aside;
                    this.slideElement = contentElement;
                    this.listen();
                    var contentGesture = new AsideTargetGesture(aside);
                    contentGesture.listen();
                }

                _createClass(AsideGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        // Only restrict edges if the aside is closed
                        return this.aside.isOpen ? true : _get(Object.getPrototypeOf(AsideGesture.prototype), 'canStart', this).call(this, ev);
                    }

                    // Set CSS, then wait one frame for it to apply before sliding starts
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform(slide.distance);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setSliding(false);
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                            this.aside.setDoneTransforming(!this.aside.isOpen);
                        } else {
                            this.aside.setDoneTransforming(false);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideGesture;
            })(SlideEdgeGesture);

            LeftAsideGesture = (function (_AsideGesture) {
                _inherits(LeftAsideGesture, _AsideGesture);

                function LeftAsideGesture() {
                    _classCallCheck(this, LeftAsideGesture);

                    _get(Object.getPrototypeOf(LeftAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                return LeftAsideGesture;
            })(AsideGesture);

            _export('LeftAsideGesture', LeftAsideGesture);

            RightAsideGesture = (function (_LeftAsideGesture) {
                _inherits(RightAsideGesture, _LeftAsideGesture);

                function RightAsideGesture() {
                    _classCallCheck(this, RightAsideGesture);

                    _get(Object.getPrototypeOf(RightAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                /*
                 Not supported right now
                export class TopAsideGesture extends AsideGesture {
                  onSlide(slide, ev) {
                    this.aside.setTransform(slide.distance);
                  }
                  getSlideBoundaries() {
                    return {
                      min: 0,
                      max: this.aside.height()
                    };
                  }
                }
                
                export class BottomAsideGesture extends TopAsideGesture {
                  getElementStartPos(slide, ev) {
                    return this.aside.isOpen ? slide.min : slide.max;
                  }
                  getSlideBoundaries() {
                    return {
                      min: -this.aside.height(),
                      max: 0
                    };
                  }
                }
                */

                _createClass(RightAsideGesture, [{
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.aside.width(),
                            max: 0
                        };
                    }
                }]);

                return RightAsideGesture;
            })(LeftAsideGesture);

            _export('RightAsideGesture', RightAsideGesture);
        }
    };
});
System.register('ionic/components/aside/extensions/types', ['ionic/util/dom'], function (_export) {
    // TODO use setters instead of direct dom manipulation
    'use strict';

    var CSS, asideManipulator, contentManipulator, backdropManipulator, AsideType, AsideTypeOverlay, AsideTypePush, AsideTypeReveal;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtilDom) {
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            asideManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.getNativeElement().classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.getNativeElement().classList[open ? 'add' : 'remove']('open');
                },
                setTransform: function setTransform(t) {
                    if (t === null) {
                        this.aside.getNativeElement().style[CSS.transform] = '';
                    } else {
                        this.aside.getNativeElement().style[CSS.transform] = 'translate3d(' + t + 'px,0,0)';
                    }
                }
            };
            contentManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.contentElement.classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.contentElement.classList[open ? 'add' : 'remove']('aside-open-' + this.aside.side);
                },
                setTransform: function setTransform(t) {
                    if (t === null) {
                        this.aside.contentElement.style[CSS.transform] = '';
                    } else {
                        this.aside.contentElement.style[CSS.transform] = 'translate3d(' + t + 'px,0,0)';
                    }
                }
            };
            backdropManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.backdrop.isTransitioning = sliding;
                    //.classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    var amt = open ? 0.32 : 0;
                    this.aside.backdrop.backgroundColor = 'rgba(0,0,0,' + amt + ')';
                },
                setTransform: function setTransform(t) {
                    if (t === null) {
                        t = this.aside.width();
                    }
                    var fade = 0.32 * t / this.aside.width();
                    this.aside.backdrop.backgroundColor = 'rgba(0,0,0,' + fade + ')';
                }
            };

            AsideType = function AsideType(aside) {
                _classCallCheck(this, AsideType);

                this.aside = aside;
                setTimeout(function () {
                    aside.contentElement.classList.add('aside-content');
                });
            };

            _export('AsideType', AsideType);

            AsideTypeOverlay = (function (_AsideType) {
                _inherits(AsideTypeOverlay, _AsideType);

                function AsideTypeOverlay() {
                    _classCallCheck(this, AsideTypeOverlay);

                    _get(Object.getPrototypeOf(AsideTypeOverlay.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(AsideTypeOverlay, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                        backdropManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                        backdropManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                        backdropManipulator.setTransform.call(this, t);
                    }
                }, {
                    key: 'setDoneTransforming',
                    value: function setDoneTransforming(willOpen) {
                        asideManipulator.setTransform.call(this, null);
                        backdropManipulator.setTransform.call(this, null);
                        asideManipulator.setOpen.call(this, willOpen);
                        backdropManipulator.setOpen.call(this, willOpen);
                    }
                }]);

                return AsideTypeOverlay;
            })(AsideType);

            _export('AsideTypeOverlay', AsideTypeOverlay);

            AsideTypePush = (function (_AsideType2) {
                _inherits(AsideTypePush, _AsideType2);

                function AsideTypePush() {
                    _classCallCheck(this, AsideTypePush);

                    _get(Object.getPrototypeOf(AsideTypePush.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(AsideTypePush, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                        contentManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                        contentManipulator.setTransform.call(this, t);
                    }
                }, {
                    key: 'setDoneTransforming',
                    value: function setDoneTransforming(willOpen) {
                        asideManipulator.setOpen.call(this, willOpen);
                        asideManipulator.setTransform.call(this, null);
                        contentManipulator.setOpen.call(this, willOpen);
                        contentManipulator.setTransform.call(this, null);
                    }
                }]);

                return AsideTypePush;
            })(AsideType);

            _export('AsideTypePush', AsideTypePush);

            AsideTypeReveal = (function (_AsideType3) {
                _inherits(AsideTypeReveal, _AsideType3);

                function AsideTypeReveal() {
                    _classCallCheck(this, AsideTypeReveal);

                    _get(Object.getPrototypeOf(AsideTypeReveal.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(AsideTypeReveal, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(sliding) {
                        console.log('Reveal setting open', sliding);
                        contentManipulator.setOpen.call(this, sliding);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        contentManipulator.setTransform.call(this, t);
                    }
                }, {
                    key: 'setDoneTransforming',
                    value: function setDoneTransforming(willOpen) {
                        contentManipulator.setOpen.call(this, willOpen);
                        contentManipulator.setTransform.call(this, null);
                    }
                }]);

                return AsideTypeReveal;
            })(AsideType);

            _export('AsideTypeReveal', AsideTypeReveal);
        }
    };
});
System.register('ionic/components/menu/extensions/gestures', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, MenuGenericGestureHandler, MenuContentGesture, LeftMenuGesture, RightMenuGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            MenuGenericGestureHandler = (function (_SlideEdgeGesture) {
                _inherits(MenuGenericGestureHandler, _SlideEdgeGesture);

                function MenuGenericGestureHandler(menu, targetElement, threshold) {
                    _classCallCheck(this, MenuGenericGestureHandler);

                    _get(Object.getPrototypeOf(MenuGenericGestureHandler.prototype), 'constructor', this).call(this, targetElement, {
                        direction: menu.side === 'left' || menu.side === 'right' ? 'x' : 'y',
                        edge: menu.side,
                        threshold: threshold
                    });
                    this.menu = menu;
                    this.listen();
                }

                // Set CSS, then wait one frame for it to apply before sliding starts

                _createClass(MenuGenericGestureHandler, [{
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart(slide, ev) {
                        this.menu.setProgressStart();
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.menu.setProgess(slide.distance / slide.max);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        var shouldComplete = Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5;
                        this.menu.setProgressFinish(shouldComplete);
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.menu.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.menu.width()
                        };
                    }
                }]);

                return MenuGenericGestureHandler;
            })(SlideEdgeGesture);

            MenuContentGesture = (function (_MenuGenericGestureHandler) {
                _inherits(MenuContentGesture, _MenuGenericGestureHandler);

                function MenuContentGesture(menu) {
                    _classCallCheck(this, MenuContentGesture);

                    _get(Object.getPrototypeOf(MenuContentGesture.prototype), 'constructor', this).call(this, menu, menu.getContentElement(), 75);
                }

                _createClass(MenuContentGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        return this.menu.isOpen ? true : _get(Object.getPrototypeOf(MenuContentGesture.prototype), 'canStart', this).call(this, ev);
                    }
                }]);

                return MenuContentGesture;
            })(MenuGenericGestureHandler);

            _export('MenuContentGesture', MenuContentGesture);

            LeftMenuGesture = (function (_MenuContentGesture) {
                _inherits(LeftMenuGesture, _MenuContentGesture);

                function LeftMenuGesture(menu) {
                    _classCallCheck(this, LeftMenuGesture);

                    _get(Object.getPrototypeOf(LeftMenuGesture.prototype), 'constructor', this).call(this, menu);
                }

                return LeftMenuGesture;
            })(MenuContentGesture);

            _export('LeftMenuGesture', LeftMenuGesture);

            RightMenuGesture = (function (_LeftMenuGesture) {
                _inherits(RightMenuGesture, _LeftMenuGesture);

                function RightMenuGesture(menu) {
                    _classCallCheck(this, RightMenuGesture);

                    _get(Object.getPrototypeOf(RightMenuGesture.prototype), 'constructor', this).call(this, menu);
                }

                _createClass(RightMenuGesture, [{
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.menu.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.menu.width(),
                            max: 0
                        };
                    }
                }]);

                return RightMenuGesture;
            })(LeftMenuGesture);

            _export('RightMenuGesture', RightMenuGesture);
        }
    };
});
System.register('ionic/components/menu/extensions/types', ['../menu', 'ionic/animations/animation'], function (_export) {
    /**
     * Menu Type
     * Base class which is extended by the various types. Each
     * type will provide their own animations for open and close
     * and registers itself with Menu.
     */
    'use strict';

    var Menu, Animation, MenuType, MenuRevealType, MenuOverlayType, OPACITY, TRANSLATE_X, CENTER;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_menu) {
            Menu = _menu.Menu;
        }, function (_ionicAnimationsAnimation) {
            Animation = _ionicAnimationsAnimation.Animation;
        }],
        execute: function () {
            MenuType = (function () {
                function MenuType(menu) {
                    _classCallCheck(this, MenuType);

                    this.open = new Animation();
                    this.close = new Animation();
                }

                /**
                 * Menu Reveal Type
                 * The content slides over to reveal the menu underneath.
                 * The menu itself, which is under the content, does not move.
                 */

                _createClass(MenuType, [{
                    key: 'setOpen',
                    value: function setOpen(shouldOpen) {
                        var _this = this;

                        return new Promise(function (resolve) {
                            if (shouldOpen) {
                                _this.open.playbackRate(1).onFinish(resolve, true).play();
                            } else {
                                _this.close.playbackRate(1).onFinish(resolve, true).play();
                            }
                        });
                    }
                }, {
                    key: 'setProgressStart',
                    value: function setProgressStart(isOpen) {
                        this.isOpening = !isOpen;
                        this.seek && this.seek.dispose();
                        // clone the correct animation depending on open/close
                        if (this.isOpening) {
                            this.seek = this.open.clone();
                        } else {
                            this.seek = this.close.clone();
                        }
                        // the cloned animation should not use an easing curve during seek
                        this.seek.easing('linear').progressStart();
                    }
                }, {
                    key: 'setProgess',
                    value: function setProgess(value) {
                        // adjust progress value depending if it opening or closing
                        if (!this.isOpening) {
                            value = 1 - value;
                        }
                        this.seek.progress(value);
                    }
                }, {
                    key: 'setProgressFinish',
                    value: function setProgressFinish(shouldComplete) {
                        var _this2 = this;

                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        var isOpen = this.isOpening && shouldComplete;
                        if (!this.isOpening && !shouldComplete) {
                            isOpen = true;
                        }
                        this.seek.progressFinish(shouldComplete).then(function () {
                            _this2.isOpening = false;
                            resolve(isOpen);
                        });
                        return promise;
                    }
                }, {
                    key: 'onDestory',
                    value: function onDestory() {
                        this.open && this.open.dispose();
                        this.close && this.close.dispose();
                        this.seek && this.seek.dispose();
                    }
                }]);

                return MenuType;
            })();

            _export('MenuType', MenuType);

            MenuRevealType = (function (_MenuType) {
                _inherits(MenuRevealType, _MenuType);

                function MenuRevealType(menu) {
                    _classCallCheck(this, MenuRevealType);

                    _get(Object.getPrototypeOf(MenuRevealType.prototype), 'constructor', this).call(this);
                    var easing = 'ease';
                    var duration = 250;
                    var openedX = menu.width() * (menu.side == 'right' ? -1 : 1) + 'px';
                    this.open.easing(easing).duration(duration);
                    this.close.easing(easing).duration(duration);
                    var contentOpen = new Animation(menu.getContentElement());
                    contentOpen.fromTo(TRANSLATE_X, CENTER, openedX);
                    this.open.add(contentOpen);
                    var contentClose = new Animation(menu.getContentElement());
                    contentClose.fromTo(TRANSLATE_X, openedX, CENTER);
                    this.close.add(contentClose);
                }

                return MenuRevealType;
            })(MenuType);

            Menu.register('reveal', MenuRevealType);
            /**
             * Menu Overlay Type
             * The menu slides over the content. The content
             * itself, which is under the menu, does not move.
             */

            MenuOverlayType = (function (_MenuType2) {
                _inherits(MenuOverlayType, _MenuType2);

                function MenuOverlayType(menu) {
                    _classCallCheck(this, MenuOverlayType);

                    _get(Object.getPrototypeOf(MenuOverlayType.prototype), 'constructor', this).call(this);
                    var easing = 'ease';
                    var duration = 250;
                    var backdropOpacity = 0.5;
                    var closedX = menu.width() * (menu.side == 'right' ? 1 : -1) + 'px';
                    this.open.easing(easing).duration(duration);
                    this.close.easing(easing).duration(duration);
                    var menuOpen = new Animation(menu.getMenuElement());
                    menuOpen.fromTo(TRANSLATE_X, closedX, CENTER);
                    this.open.add(menuOpen);
                    var backdropOpen = new Animation(menu.getBackdropElement());
                    backdropOpen.fromTo(OPACITY, 0.01, backdropOpacity);
                    this.open.add(backdropOpen);
                    var menuClose = new Animation(menu.getMenuElement());
                    menuClose.fromTo(TRANSLATE_X, CENTER, closedX);
                    this.close.add(menuClose);
                    var backdropClose = new Animation(menu.getBackdropElement());
                    backdropClose.fromTo(OPACITY, backdropOpacity, 0.01);
                    this.close.add(backdropClose);
                }

                return MenuOverlayType;
            })(MenuType);

            Menu.register('overlay', MenuOverlayType);
            OPACITY = 'opacity';
            TRANSLATE_X = 'translateX';
            CENTER = '0px';
        }
    };
});